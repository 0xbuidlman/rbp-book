<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book
  PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<book id="I_book_d1e1"><title>Ruby Best Practices</title><bookinfo><othercredit role="proofreader"><firstname>Sada</firstname><surname>Preisch</surname></othercredit><othercredit role="interiordesigner"><firstname>David</firstname><surname>Futato</surname></othercredit><othercredit role="illustrator"><firstname>Robert</firstname><surname>Romano</surname></othercredit><copyright><year>2009</year><holder>Gregory Brown</holder></copyright><!-- All rights reserved. --><publisher><publishername>O’Reilly Media, Inc.</publishername><address format="linespecific">
      <street>1005 Gravenstein Highway North</street>
      <city>Sebastopol</city>
      <state>CA</state>
      <postcode>95472</postcode>
    </address></publisher><legalnotice role="printlocation"><para>Printed in the United States of America.</para></legalnotice><legalnotice role="printer"><para>[M]</para></legalnotice><legalnotice role="use"><para>O’Reilly books may be purchased for educational, business, or sales
    promotional use. Online editions are also available for most titles
    (<ulink role="orm:hideurl:ital" url="http://my.safaribooksonline.com/?portal=oreilly">http://my.safaribooksonline.com</ulink>).
    For more information, contact our corporate/institutional sales
    department: 800-998-9938 or <email>corporate@oreilly.com</email>.</para></legalnotice><legalnotice role="trademarks"><para>O’Reilly and the O’Reilly logo are registered trademarks of O’Reilly
    Media, Inc. <citetitle>Ruby Best Practices</citetitle>, the image of a
    green crab, and related trade dress are trademarks of O’Reilly Media,
    Inc.</para><para>Many of the designations used by manufacturers and sellers to
    distinguish their products are claimed as trademarks. Where those
    designations appear in this book, and O’Reilly Media, Inc. was aware of a
    trademark claim, the designations have been printed in caps or initial
    caps.</para></legalnotice><legalnotice role="damages"><para>While every precaution has been taken in the preparation of this
    book, the publisher and author assume no responsibility for errors or
    omissions, or for damages resulting from the use of the information
    contained herein. In March 2010, this work will be released under the
    Creative Commons Attribution-Noncommercial-Share Alike 3.0 <phrase role="keep-together">License</phrase>. To view a copy of this license,
    visit <ulink url="http://creativecommons.org/licenses/by-nc-sa/3.0/">http://creativecommons.org/licenses/by-nc-sa/3.0/</ulink>
    or send a letter to Creative Commons, 171 2nd Street, Suite 300, San
    Francisco, California, 94105, USA.</para></legalnotice><isbn>9780596523008</isbn><edition>1</edition><author><firstname>Gregory</firstname><surname>Brown</surname><authorblurb><para><phrase role="bold">Gregory Brown</phrase> is a New Haven,
      Connecticut-based Rubyist who spends most of his time on free software
      projects in Ruby. His main projects are Prawn and Ruport. He also is in
      possession of a small bamboo plant that seems to be invincible, and he
      is quite proud of this accomplishment.</para></authorblurb></author><editor><firstname>Mike</firstname><surname>Loukides</surname></editor><editor role="production"><firstname>Sarah</firstname><surname>Schneider</surname></editor><editor role="copy"><firstname>Nancy</firstname><surname>Kotary</surname></editor><othercredit role="indexer"><firstname>Ellen</firstname><surname>Troutman Zaig</surname></othercredit><othercredit role="coverdesigner"><firstname>Karen</firstname><surname>Montgomery</surname></othercredit><othercredit role="foreword-author"><firstname>Yukihiro</firstname><othername>“Matz”</othername><surname>Matsumoto</surname></othercredit><printhistory><formalpara><title>First Edition</title><para>June, 2009</para></formalpara></printhistory><mediaobject role="cover" id="coverd1e4"><imageobject role="front-large" remap="lrg"><imagedata format="JPG" fileref="covers/9780596523008_lrg.jpg"/></imageobject><imageobject role="front" remap="s"><imagedata format="GIF" fileref="covers/9780596523008_s.gif"/></imageobject><imageobject role="front-small" remap="xs"><imagedata format="GIF" fileref="covers/9780596523008_xs.gif"/></imageobject><imageobject role="thumbnail" remap="cs"><imagedata format="GIF" fileref="covers/9780596523008_cs.gif"/></imageobject></mediaobject></bookinfo><preface id="ch00a-1-fm2xml" role="foreword"><prefaceinfo><author><firstname>Yukihiro</firstname><othername>“Matz”</othername><surname>Matsumoto</surname><affiliation/></author><date>June 2009, Japan</date></prefaceinfo><title id="ch00a-67975">Foreword</title><para>In 1993, when Ruby was born, Ruby had nothing. No user base except for
  me and a few close friends. No tradition. No idioms except for a few
  inherited from Perl, though I regretted most of them afterward.</para><para>But the language forms the community. The community nourishes the
  culture. In the last decade, users increased—hundreds of thousands of
  programmers fell in love with Ruby. They put great effort into the language
  and its community. Projects were born. Idioms tailored for Ruby were
  invented and introduced. Ruby was influenced by Lisp and other functional
  programming languages. Ruby formed relationships between technologies and
  methodologies such as test-driven development and duck typing.</para><para>This book introduces a map of best practices of the language as of
  2009. I’ve known Greg Brown for years, and he is an experienced Ruby
  developer who has contributed a lot of projects to the language, such as
  Ruport and Prawn. I am glad he compiled his knowledge into this book.</para><para>His insights will help you become a better Ruby programmer.</para></preface><preface id="preface"><title>Preface</title><para>Some programming languages excel at turning coders into clockwork
  oranges. By <phrase role="keep-together">enforcing</phrase> rigid rules
  about how software must be structured and implemented, it is possible to
  prevent a developer from doing anything dangerous. However, this comes at a
  high cost, stifling the essential creativity and passion that separates the
  masterful coder from the mediocre. Thankfully, Ruby is about as far from
  this bleak reality as you can possibly imagine.</para><para>As a language, Ruby is designed to allow developers to express
  themselves freely. It is meant to operate at the programmer’s level,
  shifting the focus away from the machine and toward the problem at hand.
  However, Ruby is highly malleable, and is nothing more than putty in the
  hands of the developer. With a rigid mindset that tends to overcomplicate
  things, you will produce complex Ruby code. With a light and unencumbered
  outlook, you will produce simple and beautiful programs. In this book,
  you’ll be able to clearly see the difference between the two, and find a
  clear path laid out for you if you choose to seek the latter.</para><para>A dynamic, expressive, and open language does not fit well into strict
  patterns of proper and improper use. However, this is not to say that
  experienced Rubyists don’t agree on general strategies for attacking
  problems. In fact, there is a great degree of commonality in the way that
  professional Ruby developers approach a wide range of challenges. My goal in
  this book has been to curate a collection of these techniques and practices
  while preserving their original context. Much of the code discussed in this
  book is either directly pulled from or inspired by popular open source Ruby
  projects, which is an ideal way to keep in touch with the practical world
  while still studying what it means to write better code.</para><para>If you were looking for a book of recipes to follow, or code to copy
  and paste, you’ve come to the wrong place. This book is much more about how
  to go about solving problems in Ruby than it is about the exact solution you
  should use. Whenever someone asks the question “What is the right way to do
  this in Ruby?”, the answer is always “It depends.” If you read this book,
  you’ll learn how to go with the flow and come up with good solutions even as
  everything keeps changing around you. At this point, Ruby stops being scary
  and starts being beautiful, which is where all the fun begins.</para><sect1 id="I_sect1_d1e173"><title>Audience</title><para>This book isn’t really written with the Ruby beginner in mind, and
    certainly won’t be very useful to someone brand new to programming.
    Instead, I assume a decent technical grasp of the Ruby language and at
    least some practical experience in developing software with it. However,
    you needn’t be some guru in order to benefit from this book. The most
    important thing is that you actually care about improving the way you
    write Ruby code.</para><para>As long as you have at least an intermediate level of experience,
    reading through the book should be enjoyable. You’ll want to have your
    favorite reference book handy to look things up as needed. Either
    <citetitle><ulink url="http://oreilly.com/catalog/9780596516178/">The Ruby
    Programming Language</ulink></citetitle> by David Flanagan and Yukihiro
    Matsumoto (O’Reilly) or <emphasis>Programming Ruby</emphasis>, Third
    Edition, by Dave Thomas (Pragmatic Bookshelf) should do the trick.</para><para>It is also important to note that this is a Ruby 1.9 book. It makes
    no attempt to provide notes on the differences between Ruby 1.8 and 1.9
    except for in a brief appendix designed specifically for that purpose.
    Although many of the code samples will likely work with little or no
    modifications for earlier versions of Ruby, Ruby 1.9 is the way forward,
    and I have chosen to focus on it exclusively in this book. Although the
    book may still be useful to those maintaining legacy code, it is
    admittedly geared more toward the forward-looking crowd.</para></sect1><sect1 id="I_sect1_d1e189"><title>About This Book</title><para>This book is designed to be read by chapter, but the chapters are
    not in any particular order. The book is split into two parts, with eight
    chapters forming its core and three appendixes included as supplementary
    material. Despite the fact that you can read these topics in any order
    that you’d like, it is recommended that you read the entire book. Lots of
    the topics play off of each other, and reading through them all will give
    you a solid base in some powerful Ruby techniques and practices.</para><para>Each of the core chapters starts off with a case study that is meant
    to serve as an introduction to the topic it covers. Every case study is
    based on code from real Ruby projects, and is meant to provide a practical
    experience in code reading and exploration. The best way to work through
    these examples is to imagine that you are working through a foreign
    codebase with a fellow developer, discussing the interesting bits as you
    come across them. In this way, you’ll be able to highlight the exciting
    parts without getting bogged down on every last detail. You are not
    expected to understand every line of code in the case studies in this
    book, but instead should just treat them as useful <phrase role="keep-together">exercises</phrase> that prepare you for studying the
    underlying topics.</para><para>Once you’ve worked your way through the case study, the remainder of
    each core chapter fills in details on specific subtopics related to the
    overall theme. These tend to mix real code in with some abstract examples,
    preferring the former but falling back to the latter when necessary to
    keep things easy to understand. Some code samples will be easy to run as
    they are listed; others might only be used for illustration purposes. This
    should be easy enough to figure out as you go along based on the context.
    I wholeheartedly recommend running examples when they’re relevant and
    stopping frequently to conduct your own explorations as you read this
    book. The sections are kept somewhat independent of one another to make it
    easy for you to take as many breaks as you need, and each wraps up with
    some basic reminders to refresh your memory of what you just read.</para><para>Although the core chapters are the essential part of this book, the
    appendixes should not be overlooked. You’ll notice that they’re slightly
    different in form and content from the main discussion, but maintain the
    overall feel of the book. You’ll get the most out of them if you read them
    after you’ve completed the main part of the book, as they tend to assume
    that you’re already familiar with the rest of the content.</para><para>That’s pretty much all there is to it. The key things to remember
    are that you aren’t going to get much out of this book by skimming for
    content on a first read, and that you should keep your brain engaged while
    you work your way through the content. If you read this entire book
    without writing any code in the process, you’ll probably rob yourself of
    the full experience. So pop open your favorite editor, start with the
    topic from the chapter listing that interests you most, and get
    hacking!</para></sect1><sect1 id="I_sect1_d1e205"><title>Conventions Used in This Book</title><para>The following typographical conventions are used in this
    book:</para><variablelist><varlistentry><term>Italic</term><listitem><para>Indicates new terms, URLs, email addresses, filenames, and
          file extensions.</para></listitem></varlistentry><varlistentry><term><literal moreinfo="none">Constant width</literal></term><listitem><para>Used for program listings, as well as within paragraphs to
          refer to program elements such as variable or function names,
          databases, data types, environment variables, statements, and
          keywords.</para></listitem></varlistentry><varlistentry><term><userinput moreinfo="none">Constant width
        bold</userinput></term><listitem><para>Shows commands or other text that should be typed literally by
          the user.</para></listitem></varlistentry><varlistentry><term><replaceable>Constant width italic</replaceable></term><listitem><para>Shows text that should be replaced with user-supplied values
          or by values determined by context.</para></listitem></varlistentry></variablelist></sect1><sect1 id="I_sect1_d1e238"><title>Using Code Examples</title><para>This book is here to help you get your job done. In general, you may
    use the code in this book in your programs and documentation. You do not
    need to contact us for permission unless you’re reproducing a significant
    portion of the code. For example, writing a program that uses several
    chunks of code from this book does not require permission. Selling or
    distributing a CD-ROM of examples from O’Reilly books does require
    permission. Answering a question by citing this book and quoting example
    code does not require permission. Incorporating a significant amount of
    example code from this book into your product’s documentation does require
    permission.</para><para>We appreciate, but do not require, attribution. An attribution
    usually includes the title, author, publisher, and ISBN. For example:
    “<emphasis>Ruby Best Practices</emphasis> by Gregory Brown. Copyright 2009
    Gregory Brown, 978-0-596-52300-8.”</para><para>If you feel your use of code examples falls outside fair use or the
    permission given here, feel free to contact us at
    <email>permissions@oreilly.com</email>.</para></sect1><sect1 id="I_sect1_d1e253"><title>Safari® Books Online</title><note role="safarienabled"><para>When you see a Safari® Books Online icon on the cover of your
      favorite technology book, that means the book is available online
      through the O’Reilly Network Safari Bookshelf.</para></note><para>Safari offers a solution that’s better than e-books. It’s a virtual
    library that lets you easily search thousands of top tech books, cut and
    paste code samples, download chapters, and find quick answers when you
    need the most accurate, current information. Try it for free at <ulink role="orm:hideurl:ital" url="http://my.safaribooksonline.com/?portal=oreilly">http://my.safaribooksonline.com</ulink>.</para></sect1><sect1 id="I_sect1_d1e264"><title>How to Contact Us</title><para>Please address comments and questions concerning this book to the
    publisher:</para><simplelist type="vert"><member>O’Reilly Media, Inc.</member><member>1005 Gravenstein Highway North</member><member>Sebastopol, CA 95472</member><member>800-998-9938 (in the United States or Canada)</member><member>707-829-0515 (international or local)</member><member>707-829-0104 (fax)</member></simplelist><para>O’Reilly has a web page for this book, where we list errata,
    examples, and any additional information. You can access this page
    at:</para><simplelist type="vert"><member><ulink url="http://oreilly.com/catalog/9780596523008/"/></member></simplelist><para>Gregory maintains a community-based page for this book at:</para><simplelist type="vert"><member><ulink url="http://rubybestpractices.com"/></member></simplelist><para>To comment or ask technical questions about this book, send email
    to:</para><simplelist type="vert"><member><email>bookquestions@oreilly.com</email></member></simplelist><para>For more information about our books, conferences, Resource Centers,
    and the <phrase role="keep-together">O’Reilly</phrase> Network, see our
    website at:</para><simplelist type="vert"><member><ulink url="http://www.oreilly.com"/></member></simplelist></sect1><sect1 id="I_sect1_d1e307"><title>Acknowledgments</title><para>Over the course of writing <citetitle>Ruby Best
    Practices</citetitle>, I was thoroughly supported by my friends, family,
    and fellow hackers. I want to thank each and every one of the folks who’ve
    helped out with this book, because it would not exist without them.</para><para>This book did not have a typical technical review process, but
    instead was supported by an excellent advisory board whose members
    participated in group discussion and the occasional review as each chapter
    was released. These folks not only helped catch technical errors, but
    helped me sketch out the overall vision for how the book should come
    together as well. Participants included James Britt, Francis Hwang, Hart
    Larew, Chris Lee, Jeremy McAnally, and Aaron Patterson.</para><para>Rounding out the group was the best pair of guiding mentors I could
    hope for, Brad Ediger and James Edward Gray II. Both have published Ruby
    books, and have worked with me extensively on a number of Ruby projects.
    James and Brad were both instrumental in producing this book, and to my
    career as a software developer in general. I have learned a ton from each
    of them, and thanks to their help with <citetitle>RBP</citetitle>, I can
    now pass their knowledge on to you.</para><para>Much of the source code in this book comes from the open source Ruby
    community. Although I talk about my own projects (Prawn and Ruport) a lot,
    most of the code I show is actually from other contributors or at least
    originated from good ideas that came up in mailing list discussions,
    feature requests, and so on. In addition to these two projects, I also
    have benefited from studying a whole slew of other gems, including but not
    limited to: activesupport, builder, camping, faker, flexmock, gibberish,
    haml, highline, lazy, nokogiri, pdf-writer, and rspec. Great thanks go out
    to all of the developers of these projects, whom I’ve tried to acknowledge
    directly wherever I can throughout the text.</para><para>Of course, without Yukihiro Matsumoto (Matz), we wouldn’t have Ruby
    in the first place. After writing this book, I am more impressed than ever
    by the language he has designed. If I’m lucky, this book will help show
    people just how beautiful Ruby can be.</para><para>Producing the technical content for this work was daunting, but only
    part of the overall picture. My editor, Mike Loukides, and the entire
    O’Reilly production team have made publishing this book a very comfortable
    experience. After overcoming major fears about the hurdles of working with
    a mainstream publisher, I’ve found the folks at O’Reilly to be helpful,
    accommodating, and supportive. It is especially nice that this book will
    become an open community resource less than a year after it prints. This
    measure is one I hope to see other technical book publishers adopt, and
    one I’m very thankful that O’Reilly was open to.</para><para>Finally, I need to thank the folks who’ve helped me keep my sanity
    while working on this huge project. My future wife, Jia Wu, has been
    amazingly supportive of me, and helped make sure that I occasionally ate
    and slept while working on this book. On the weekends, we’d usually escape
    for an bit and spend time with my close friends and family. Though they
    didn’t have anything to do with the project itself, without Pete, Paul,
    Mom, Dad, and Vinny, I doubt you’d be reading this book right now. Thanks
    to all of you, even if you’ll never need to read this book.</para><para>So many people helped out in countless different ways, that I’m sure
    I’ve missed someone important while compiling this list. To make sure
    these folks get their well-deserved credit, please keep an eye on the
    acknowledgments page at <ulink url="http://rubybestpractices.com"/>
    and let me know if there is someone who needs to be added to the list. But
    for now, if I’ve failed to list you here, thank you and please know that
    I’ve not forgotten what you’ve done to help me.</para></sect1></preface><chapter id="ch01"><title>Driving Code Through Tests</title><para>If you’ve done some Ruby—even a little bit—you have probably heard of
  <emphasis>test-driven development</emphasis> (TDD). Many advocates present
  this software practice as the “secret key” to programming success. However,
  it’s still a lot of work to convince people that writing tests that are
  often longer than their implementation code can actually lower the total
  time spent on a project and increase overall efficiency.<indexterm class="startofrange" id="ch01_testing" significance="normal"><primary>testing</primary></indexterm><indexterm id="I_indexterm1_d1e345" significance="normal"><primary>TDD (test-driven development)</primary></indexterm></para><para>In my work, I’ve found most of the claims about the benefits of TDD to
  be true. My code is better because I write tests that document the expected
  behaviors of my software while verifying that my code is meeting its
  requirements. By writing automated tests, I can be sure that once I narrow
  down the source of a bug and fix it, it’ll never resurface without me
  knowing right away. Because my tests are automated, I can hand my code off
  to others and mechanically assert my expectations, which does more for me
  than a handwritten specification ever could do.</para><para>However, the important thing to take home from this is that automated
  testing is really no different than what we did before we discovered it. If
  you’ve ever tried to narrow down a bug with a print statement based on a
  conditional, you’ve already written a primitive form of automated
  testing:</para><screen format="linespecific">if foo != "blah"
  puts "I expected 'blah' but foo contains #{foo}"
end</screen><para>If you’ve ever written an example to verify that a bug exists in an
  earlier version of code, but not in a later one, you’ve written something
  not at all far from the sorts of things you’ll write through TDD. The only
  difference is that one-off examples do not adequately account for the
  problems that can arise during integration with other modules. This problem
  can become huge, and is one that unit testing frameworks handle quite
  well.<indexterm id="I_indexterm1_d1e356" significance="normal"><primary>unit testing</primary><see>testing; tests</see></indexterm></para><para>Even if you already know a bit about testing and have been using it in
  your work, you might still feel like it doesn’t come naturally. You write
  tests because you see the long-term benefits, but you usually write your
  code first. It takes you a while to write your tests, because it seems like
  the code you wrote is difficult to pin down behavior-wise. In the end,
  testing becomes a necessary evil. You appreciate the safety net, but except
  for when you fall, you’d rather just focus on keeping your balance and
  moving forward.</para><para>Masterful Rubyists will tell you otherwise, and for good reason.
  Testing may be hard, but it truly does make your job of writing software
  easier. This chapter will show you how to integrate automated testing into
  your workflow, without forcing you to relearn the troubleshooting skills
  you’ve already acquired. By making use of the best practices discussed here,
  you’ll be able to more easily see the merits of TDD in your own work.</para><sect1 id="I_sect11_d1e365"><title>A Quick Note on Testing Frameworks</title><para>Ruby provides a unit testing framework in its standard library
    called <filename moreinfo="none">minitest/unit</filename>. This library provides a
    user-level compatibility layer with the popular
    <filename moreinfo="none">test/unit</filename> library, which has been fairly standard in
    the Ruby community for some time now. There are significant differences
    between the <filename moreinfo="none">minitest/unit</filename> and
    <filename moreinfo="none">test/unit</filename> implementations, but as we won’t be
    building low-level extensions in this chapter, you can assume that the
    code here will work in both <filename moreinfo="none">minitest/unit</filename> and
    <filename moreinfo="none">test/unit</filename> without modification.<indexterm id="I_indexterm1_d1e389" significance="normal"><primary>test/unit library</primary></indexterm><indexterm id="I_indexterm1_d1e392" significance="normal"><primary>minitest/unit library</primary></indexterm><indexterm id="I_indexterm1_d1e395" significance="normal"><primary>unit testing framework (minitest/unit)</primary></indexterm><indexterm id="I_indexterm1_d1e398" significance="normal"><primary>testing</primary><secondary>frameworks for</secondary></indexterm></para><para>For what it’s worth, I don’t have a very strong preference when it
    comes to testing frameworks. I am using the <literal moreinfo="none">Test::Unit</literal> API here because it is part of
    standard Ruby, and because it is fundamentally easy to hack on and extend.
    Many of the existing alternative testing frameworks are built on top of
    <literal moreinfo="none">Test::Unit</literal>, and you will almost
    certainly need to have a working knowledge of it as a Ruby developer.
    However, if you’ve been working with a noncompatible framework such as
    <ulink url="http://rspec.info">RSpec</ulink>, there’s nothing wrong with
    that. The ideas here should be mostly portable to your framework of
    choice.</para><para>And now we can move on. Before digging into the nuts and bolts of
    writing tests, we’ll examine what it means for code to be easily testable,
    by looking at some real examples.</para></sect1><sect1 id="I_sect11_d1e416"><title>Designing for Testability</title><para>Describing testing with the phrase “Red, Green, Refactor” makes it
    seem fairly straightforward. Most people interpret this as the process of
    writing some failing tests, getting those tests to pass, and then cleaning
    up the code without causing the tests to fail again. This general
    assumption is exactly correct, but a common misconception is how much work
    needs to be done between each phase of this cycle.<indexterm id="I_indexterm1_d1e421" significance="normal"><primary>testing</primary><secondary>designing for testability</secondary></indexterm></para><para>For example, if we try to solve our whole problem all in one big
    chunk, add tests to verify that it works, then clean up our code, we end
    up with implementations that are very difficult to test, and even more
    challenging to refactor. The following example illustrates just how bad
    this problem can get if you’re not careful. It’s from some payroll
    management code I wrote in a hurry a couple of years ago:<indexterm id="I_indexterm1_d1e428" significance="normal"><primary>refactoring</primary></indexterm></para><?dbfo-need height=”1in”
?><screen format="linespecific">def time_data_for_week(week_data,start,employee_id)

  data = Hash.new { |h,k| h[k] = Hash.new }

  %w[M T W TH F S].zip((0..6).to_a).each do |day,offset|

    date = (start + offset.days).beginning_of_day

    data[day][:lunch_hours] = LunchTime.find(:all, conditions:
      ["employee_id = ? and day between ? and ?",
          employee_id, date, date + 1.day - 1.second] ).inject(0) { |s,r|
            s + r.duration
          }

   times = [[:sick_hours    , "Sick"    ],
            [:personal_hours, "Personal"],
            [:vacation_hours, "Vacation"],
            [:other_hours,    "Other"   ]]

   times.each do |a,b|
     data[day][a] = OtherTime.find(:all, conditions:
       ["employee_id = ? and category = '#{b}' and date between ? and ?",
         employee_id, date, date + 1.day - 1.second] ).inject(0) { |s,r|
           s + r.hours
         }
   end

    d = week_data.find { |d,_| d == date }
    next unless d

    d = d[-1]
    data[day].merge!(
      regular_hours: d.inject(0) { |s,e|
        s + (e.end_time ? (e.end_time - e.start_time) / 3600 : 0)
      } - data[day][:lunch_hours],
      start_time: d.map { |e| e.start_time }.sort[0],
        end_time: d.map { |e| e.end_time }.compact.sort[-1]
    )
  end

  sums = Hash.new(0)

  data.each do |k,v|
    [:regular_hours, :lunch_hours, :sick_hours,
     :personal_hours, :vacation_hours, :other_hours].each { |h|
       sums[h] += v[h].to_f }
   end

  Table(:day,:start_time,:end_time,:regular_hours,:lunch_hours,
        :sick_hours,:personal_hours,:vacation_hours, :other_hours) do |t|
     %w[M T W TH F S].each { |d| t &lt;&lt; {day: d}.merge(data[d]) }
     t &lt;&lt; []
     t &lt;&lt; { day: "&lt;b&gt;Totals&lt;/b&gt;" }.merge(sums)
  end
end</screen><para>When you looked at the preceding example, did you have an easy time
    understanding it? If you didn’t, you don’t need to worry, because I can
    hardly remember what this code does, and I’m the one who wrote it. Though
    it is certainly possible to produce better code than this without
    employing TDD, it’s actually quite difficult to produce something this
    ugly if you are writing your tests first. This is especially true if you
    manage to keep your iterations nice and tight. The very nature of
    test-driven development lends itself to breaking your code up into
    smaller, simpler chunks that are easy to work with. It’s safe to say that
    we don’t see any of those attributes here.</para><para>Now that we’ve seen an example of what not to do, we can investigate
    the true benefits of TDD in the setting of a real project. What follows is
    the process that I went through while developing a simple feature for the
    Prawn PDF generation library. But first, a small diversion is
    necessary.<indexterm id="I_indexterm1_d1e438" significance="normal"><primary>Prawn PDF generation library</primary></indexterm></para><sidebar id="I_sidebar1_d1e441"><title>A Test::Unit Trick to Know About</title><para>Usually, test cases written with
      <filename moreinfo="none">minitest/unit</filename> or <filename moreinfo="none">test/unit</filename>
      look like this:</para><screen format="linespecific">class MyThingieTest &lt; Test::Unit::TestCase
  def test_must_be_empty
    #...
  end

  def test_must_be_awesome
    #...
  end
end</screen><para>But in all the examples you’ll see in this chapter, we’ll be
      writing our tests like this:</para><screen format="linespecific">class MyThingieTest &lt; Test::Unit::TestCase
  must "be empty" do
    #...
  end

  must "be awesome" do
    #...
  end
end</screen><para>If you’ve used <literal moreinfo="none">Test::Unit</literal>
      before, you might be a bit confused by the use of the <literal moreinfo="none">must()</literal> method here. This is actually a custom
      addition largely based on the <literal moreinfo="none">test()</literal>
      method in the <emphasis>activesupport</emphasis> gem. All this code does
      is automatically generate test methods for you, improving the clarity of
      our examples a bit. You don’t really need to worry about how this works,
      but for the curious, the implementation can be found at <ulink url="http://github.com/sandal/rbp/tree/master/testing/test_unit_extensions.rb">http://github.com/sandal/rbp/tree/master/testing/test_unit_extensions.rb</ulink>.<indexterm id="I_indexterm1_d1e476" significance="normal"><primary>activesupport gem</primary><secondary>test( ) method</secondary></indexterm></para><para>We also discuss this in <xref linkend="ch03" xrefstyle="chap-num-title"/>, as an example of how to make custom
      extensions to preexisting objects. So although you only need to
      understand how <literal moreinfo="none">must()</literal> is used here,
      you’ll get a chance to see how it is built later on.</para></sidebar><para>The code we’re about to look at was originally part of Prawn’s early
    support for inline styling, which allows users to make use of bold and
    italic typefaces within a single string of text. In practice, these
    strings look very similar to the most basic HTML markup:<indexterm id="I_indexterm1_d1e490" significance="normal"><primary>Prawn PDF generation library</primary><secondary>inline styling support</secondary></indexterm><indexterm id="I_indexterm1_d1e495" significance="normal"><primary>inline styling</primary></indexterm></para><screen format="linespecific">"This is a string with &lt;b&gt;bold, &lt;i&gt;bold italic&lt;/i&gt;&lt;/b&gt; and &lt;i&gt;italic&lt;/i&gt; text"</screen><para>Although the details of how Prawn actually converts these strings
    into stylized text that can be properly rendered within a PDF document are
    somewhat gory, the process of breaking up the string and parsing out the
    style tags is quite straightforward. We’ll focus on this aspect of things,
    stepping through the design and development process until we end up with a
    simple function that behaves as follows:</para><screen format="linespecific">&gt;&gt; StyleParser.process("Some &lt;b&gt;bold&lt;/b&gt; and &lt;i&gt;italic&lt;/i&gt; text")
=&gt; ["Some ", "&lt;b&gt;", "bold", "&lt;/b&gt;", " and ", "&lt;i&gt;", "italic", "&lt;/i&gt;", " text"]</screen><para>This example demonstrates the final product, but the initial pass at
    things wasn’t so polished. I started by considering the possibility of
    passing all the strings rendered in Prawn through style processing, so the
    initial case I thought of was actually to allow the method to return the
    string itself when it did not detect any style data. My early example
    looked something like this:</para><screen format="linespecific">class TestInlineStyleParsing &lt; Test::Unit::TestCase
  must "simply return the string if styles are not found" do
    @pdf = Prawn::Document.new
    assert_equal "Hello World", @pdf.parse_inline_styles("Hello World")
  end
end</screen><para>My initial functionality looked something like this:</para><screen format="linespecific">class Prawn::Document
  def parse_inline_styles(text)
    text
  end
end</screen><para>This caused my example to run without failure, and is quite possibly
    the most boring code imaginable. However, working in small steps like this
    helps keep things simple and also allows you to sanity-check that things
    are working as expected. Seeing that this was the case, I was able to move
    forward with another set of examples. The modified test case ended up
    looking like this:</para><screen format="linespecific">class TestInlineStyleParsing &lt; Test::Unit::TestCase
  must "simply return the string if styles are not found" do
    @pdf = Prawn::Document.new
    assert_equal "Hello World", @pdf.parse_inline_styles("Hello World")
  end

  must "parse italic tags" do
    @pdf = Prawn::Document.new
    assert_equal ["Hello ", "&lt;i&gt;", "Fine", "&lt;/i&gt;", " World"],
                  @pdf.parse_inline_styles("Hello &lt;i&gt;Fine&lt;/i&gt; World")
  end

  must "parse bold tags" do
    @pdf = Prawn::Document.new
    assert_equal ["Some very ", "&lt;b&gt;", "bold text", "&lt;/b&gt;"],
      @pdf.parse_inline_styles("Some very &lt;b&gt;bold text&lt;/b&gt;")
  end

end</screen><para>Despite the fact that I’m writing a book titled <citetitle>Ruby Best
    Practices</citetitle>, I freely admit that I write some dumb code
    sometimes. For evidence, we can look at the first bit of code that made
    this example work:</para><screen format="linespecific">def parse_inline_styles(text)
  require "strscan"

  sc = StringScanner.new(text)
  output = []
  last_pos = 0

  loop do
    if sc.scan_until(/&lt;\/?[ib]&gt;/)
      pre = sc.pre_match[last_pos..-1]
      output &lt;&lt; pre unless pre.empty?
      output &lt;&lt; sc.matched
      last_pos = sc.pos
    else
      output &lt;&lt; sc.rest if sc.rest?
      break output
    end
  end

  output.length == 1 ? output.first : output
end</screen><para>That’s way longer than it needs to be. Luckily, a useful aspect of
    using automated behavior verification is that it is helpful during
    refactoring. I had planned to send this code out to the
    <emphasis>ruby-talk</emphasis> mailing list so that I could learn the
    elegant solution that I knew must exist but couldn’t quite muster in my
    first pass. Before I could do that though, I needed to add another example
    to clarify the intended behavior:<indexterm id="I_indexterm1_d1e529" significance="normal"><primary>refactoring</primary><secondary>using automated behavior verification</secondary></indexterm><indexterm id="I_indexterm1_d1e534" significance="normal"><primary>automated behavior verification</primary></indexterm></para><screen format="linespecific">must "parse mixed italic and bold tags" do
  @pdf = Prawn::Document.new
  assert_equal ["Hello ", "&lt;i&gt;", "Fine ", "&lt;b&gt;", "World", "&lt;/b&gt;", "&lt;/i&gt;"],
    @pdf.parse_inline_styles("Hello &lt;i&gt;Fine &lt;b&gt;World&lt;/b&gt;&lt;/i&gt;")
end</screen><para>Some folks might make the claim that a good test suite makes it
    easier to communicate with customers, but I’ve never been too sure about
    that. What I do know is that tests are downright awesome for describing a
    problem to your fellow developers. Within minutes of posting my examples
    to <emphasis>ruby-talk</emphasis>, I had a much better implementation in
    hand:<footnote><para>Thanks to Robert Dober, <emphasis>ruby-talk</emphasis> post
        #309593.</para></footnote></para><screen format="linespecific">def parse_inline_styles(text)
  segments = text.split( %r{(&lt;/?.*?&gt;)} ).reject {|x| x.empty? }
  segments.size == 1 ? segments.first : segments
end</screen><para>Running the examples showed that this code accomplished what my
    earlier code did, as there were no failures. However, your code is only as
    correct as the examples you choose, and as it turns out, this code gave me
    more than I bargained for. It parsed out anything within angle braces,
    meaning it’d pull out the tags in the following string:</para><programlisting id="I_programlisting1_d1e555" format="linespecific">"Hello &lt;indigo&gt;Charlie&lt;/indigo&gt;"</programlisting><para>Though this might be useful in some situations, I really wanted to
    parse out only the two specific tags I planned to handle, so I added an
    example to cover this:</para><screen format="linespecific">must "not split out other tags than &lt;i&gt;, &lt;b&gt;, &lt;/i&gt;, &lt;/b&gt;" do
  @pdf = Prawn::Document.new
  assert_equal ["Hello &lt;indigo&gt;Ch", "&lt;/b&gt;", "arl", "&lt;/b&gt;", "ie&lt;/indigo&gt;"],
    @pdf.parse_inline_styles("Hello &lt;indigo&gt;Ch&lt;/b&gt;arl&lt;/b&gt;ie&lt;/indigo&gt;")
end</screen><para>This new example resulted in a failure, as expected. The required
    change was simple, and caused everything to pass again:</para><screen format="linespecific">def parse_inline_styles(text)
  segments = text.split( %r{(&lt;/?[ib]&gt;)} ).delete_if{|x| x.empty? }
  segments.size == 1 ? segments.first : segments
end</screen><para>I originally planned to pass through this function every string that
    Prawn attempted to render, and this influenced the way the initial
    interface was specified. However, later I realized that it would be better
    to check to see whether a string had any style tags in it before
    attempting to parse it. Because the process of rendering the text is
    handled in two very different ways depending on whether there are inline
    styles present, I needed to handle only the case when there were tags to
    be extracted in my parser:</para><screen format="linespecific">def parse_inline_styles(text)
  text.split( %r{(&lt;/?[ib]&gt;)} ).delete_if{|x| x.empty? }
end</screen><para>This cleanup caused one of my examples to fail, because it broke the
    old default <phrase role="keep-together">behavior</phrase>:</para><screen format="linespecific">  1) Failure:
test_simply_return_the_string_if_styles_are_not_found(TestInlineStyleParsing) [...]:
&lt;"Hello World"&gt; expected but was
&lt;["Hello World"]&gt;.</screen><para>As this example was no longer relevant, I simply removed it and was
    back under the green light. But I still needed a related feature, which
    was the ability to test whether <phrase role="keep-together">a string
    needed to be parsed</phrase>. I considered making this a private method on
    <literal moreinfo="none" role="keep-together">Prawn::Document</literal>,
    but it led to some ugly code:</para><?dbfo-need height=”1in”
?><screen format="linespecific">must "be able to check whether a string needs to be parsed" do
  @pdf = Prawn::Document.new
  assert ! @pdf.send(:style_tag?, "Hello World")
  assert @pdf.send(:style_tag?, "Hello &lt;i&gt;Fine&lt;/i&gt; World")
end</screen><para>Most of the time when I need to use <literal moreinfo="none">send()</literal> to call a private method in one of my
    tests, I try to rethink my interface. Sometimes it’s a necessary evil, but
    most of the time it <phrase role="keep-together">just means that things
    are looking to be refactored.</phrase> When I first added <literal moreinfo="none" role="keep-together">Document#parse_inline_styles</literal>, it didn’t
    concern me much to add a single utility method for this purpose. However,
    once I found out that I needed an additional helper method, I began to
    rethink the problem. I realized things would look better if I wrapped the
    code up in a module.</para><para>I updated my examples to reflect this change, and cleaned them up a
    bit by adding a <literal moreinfo="none">setup</literal> method, which
    gets run before each individual test:</para><screen format="linespecific">class TestInlineStyleParsing &lt; Test::Unit::TestCase

  def setup
    @parser = Prawn::Document::Text::StyleParser
  end

  must "parse italic tags" do
    assert_equal ["Hello ", "&lt;i&gt;", "Fine", "&lt;/i&gt;", " World"],
      @parser.process("Hello &lt;i&gt;Fine&lt;/i&gt; World")
  end

  must "parse bold tags" do
    assert_equal ["Some very ", "&lt;b&gt;", "bold text", "&lt;/b&gt;"],
      @parser.process("Some very &lt;b&gt;bold text&lt;/b&gt;")
  end

  must "parse mixed italic and bold tags" do
    assert_equal ["Hello ", "&lt;i&gt;", "Fine ", "&lt;b&gt;", "World", "&lt;/b&gt;", "&lt;/i&gt;"],
      @parser.process("Hello &lt;i&gt;Fine &lt;b&gt;World&lt;/b&gt;&lt;/i&gt;")
  end

  must "not split out other tags than &lt;i&gt;, &lt;b&gt;, &lt;/i&gt;, &lt;/b&gt;" do
    assert_equal ["Hello &lt;indigo&gt;Ch", "&lt;/b&gt;", "arl", "&lt;/b&gt;", "ie&lt;/indigo&gt;"],
      @parser.process("Hello &lt;indigo&gt;Ch&lt;/b&gt;arl&lt;/b&gt;ie&lt;/indigo&gt;")
  end

  must "be able to check whether a string needs to be parsed" do
    assert @parser.style_tag?("Hello &lt;i&gt;Fine&lt;/i&gt; World")
    assert !@parser.style_tag?("Hello World")
  end

end</screen><para>Because these features didn’t really rely on anything within
    <literal moreinfo="none">Prawn::Document</literal>, it made me happy to
    give them a home of their own, ready to be expanded later as needed. I
    created the module and dropped in the trivial check that made up the
    <literal moreinfo="none">style_tag?</literal> <phrase role="keep-together">feature</phrase>:</para><screen format="linespecific">module StyleParser
  extend self

  def process(text)
    text.split( %r{(&lt;/?[ib]&gt;)} ).delete_if{|x| x.empty? }
  end

  def style_tag?(text)
    !!(text =~ %r{(&lt;/?[ib]&gt;)})
  end
end</screen><para>With the tests passing, I snuck in one more bit of cleanup under the
    green light, just to make things a little more DRY:<footnote><para>Don’t Repeat Yourself.</para></footnote></para><screen format="linespecific">module StyleParser
  extend self

  TAG_PATTERN = %r{(&lt;/?[ib]&gt;)}

  def process(text)
    text.split(TAG_PATTERN).delete_if{|x| x.empty? }
  end

  def style_tag?(text)
    !!(text =~ TAG_PATTERN)
  end
end</screen><para>With these two simple features in hand, I was then ready to work on
    implementing the inline styling support in Prawn, which I can assure you
    was far less pleasant to hack together.<footnote><para>In fact, it wasn’t until several months later that an acceptable
        inline styling tool saw the light of day, thanks to the efforts of
        Jamis Buck.</para></footnote> Even though this example was quite simple, it captures the
    entire process of evolving a feature by using progressively tweaked
    examples from start to finish. Although the end result is an automated
    safety net that verifies that my methods behave as I’ve specified them,
    you can see that the process of problem discovery, refactoring, and
    iterative design are the true fruits of test-driven development. This is
    what justifies spending time writing tests that are often longer than your
    implementation. The resulting examples are mostly a helpful side effect;
    the power of this technique is in what insight you gain through writing
    them in the first place.<indexterm id="I_indexterm1_d1e633" significance="normal"><primary>iterative design</primary></indexterm><indexterm id="I_indexterm1_d1e636" significance="normal"><primary>TDD (test-driven development)</primary><secondary>problem discovery, refactoring, and iterative
        design</secondary></indexterm></para><para>Now that we’ve seen the process in action, we’ll take a step back
    and go over some testing fundamentals. Although this stuff may be familiar
    to folks who are already accustomed to TDD, it doesn’t hurt to brush up on
    the essentials, as they form a foundation for the more advanced stuff that
    we’ll tackle a little later.</para></sect1><sect1 id="I_sect11_d1e643"><title>Testing Fundamentals</title><para>A few good habits go a long way when it comes to TDD. We’ll now take
    a look at some key techniques that help make writing solid and
    maintainable tests much easier.<indexterm id="I_indexterm1_d1e648" significance="normal"><primary>TDD (test-driven development)</primary><seealso>testing</seealso></indexterm></para><sect2><title>Well-Focused Examples</title><para>A common beginner habit in testing is to create a single example
      that covers all of the edge cases for a given method. An example of this
      might be something along these lines:<indexterm id="I_indexterm1_d1e658" significance="normal"><primary>edge cases for a method, writing example to test</primary></indexterm><indexterm id="I_indexterm1_d1e661" significance="normal"><primary>testing</primary><secondary>using well-focused examples</secondary></indexterm></para><screen format="linespecific">class VolumeTest &lt; Test::Unit::TestCase
  must "compute volume based on length, width, and height" do
    # defaults to l=w=h=1
    assert_equal 1, volume

    #when given 1 arg, set l=x, set w,h = 1
    x = 6
    assert_equal x, volume(x)

    # when given 2 args, set l=x, w=y and h=1
    y = 2
    assert_equal x*y, volume(x,y)

    # when given 3 args, set l=x, w=y and h=z
    z = 7
    assert_equal x*y*z, volume(x,y,z)

    # when given a hash, use :length, :width, :height
    assert_equal x*y*z, volume(length: x, width: y, height: z)
  end
end</screen><para>Though it is relatively easy to type things out this way, there
      are some limitations that are worth noting. One of the most obvious
      issues with this approach is that it isn’t very organized. Compare the
      previous example to the next, and you’ll see how much easier it is to
      read things when they are cleanly separated out:</para><screen format="linespecific">class VolumeTest &lt; Test::Unit::TestCase

  must "return 1 by default if no arguments are given" do
    # defaults to l=w=h=1
    assert_equal 1, volume
  end

  must "set l=x, set w,h = 1 when given 1 numeric argument" do
    x = 6
    assert_equal x, volume(x)
  end

  must "set l=x, w=y, and h=1 when given 2 arguments" do
    x, y = 6, 2
    assert_equal x*y, volume(x,y)
  end

  must "set l=x, w=y, and h=z when given 3 arguments" do
    x,y,z = 6, 2, 7
    assert_equal x*y*z, volume(x,y,z)
  end

  must "use :length, :width, and :height when given a hash argument" do
    x,y,z = 6, 2, 7
    assert_equal x*y*z, volume(length: x, width: y, height: z)
  end

end</screen><para>However, the improved clarity is actually one of the lesser
      reasons why this code is better. In the former example, your failure
      report will include only the first assertion that was violated; the code
      that follows it will not even be executed. When you get the report back,
      you’ll get a message that shows you the numeric expected/actual values,
      but it will be titled something like, “a volume function should compute
      volume based on length width and height,” which is not very instructive
      for determining which case caused the problem.</para><para>In the latter approach, every single example will run, testing all
      of the cases simultaneously. This means that if a change you make to
      your code affects three out of the four cases, your tests will report
      back three out of four cases rather than just the first failed assertion
      in the example. They’ll have more useful names, too, each uniquely
      pointing back to the individual <literal moreinfo="none">must()</literal> call that failed.</para><para>Although the code shown here is unlikely to have side effects,
      there is an additional benefit to splitting up examples: each one runs
      in its own clean-slate environment. This means you can use <literal moreinfo="none">setup</literal> and <literal moreinfo="none">teardown</literal> methods to manage pre- and
      postprocessing, but the code will run largely independent of your other
      examples. The benefit here is that you’ll avoid the problem of
      accidentally depending on some side effect or state that is left hanging
      around as a result of another method call. Because of this, your tests
      will be more isolated and less likely to run into false positives or
      strange errors.<indexterm id="I_indexterm1_d1e687" significance="normal"><primary>side effects</primary><secondary>avoiding in testing</secondary></indexterm></para></sect2><sect2><title>Testing Exceptions</title><para>Code is not merely specified by the way it acts under favorable
      conditions. Although it’d be great if we could assume conservative input
      and liberal output constraints, this just doesn’t seem to be practical
      in most cases. This means that our code will often need to raise
      appropriate exceptions when it isn’t able to handle the request it has
      been given, or if it detects misuse that deserves further attention.
      Luckily, <literal moreinfo="none">Test::Unit</literal> makes it easy for
      us to specify both when code should raise a certain error, and when we
      expect it to run without error. We’ll take a look at a trivial little
      lockbox object that provides rudimentary access control to get a feel
      for how this looks. See if you can understand the tests just by reading
      through them:<indexterm id="I_indexterm1_d1e700" significance="normal"><primary>exceptions</primary><secondary>testing</secondary></indexterm><indexterm id="I_indexterm1_d1e705" significance="normal"><primary>testing</primary><secondary>exceptions</secondary></indexterm></para><?dbfo-need height=”1in”
?><screen format="linespecific">class LockBoxTest &lt; Test::Unit::TestCase

  def setup
    @lock_box = LockBox.new( password: "secret",
                              content: "My Secret Message" )
  end

  must "raise an error when an invalid password is used" do
    assert_raises(LockBox::InvalidPassword) do
      @lock_box.unlock("kitten")
    end
  end

  must "Not raise error when a valid password is used" do
    assert_nothing_raised do
      @lock_box.unlock("secret")
    end
  end

  must "prevent access to content by default" do
    assert_raises(LockBox::UnauthorizedAccess) do
      @lock_box.content
    end
  end

  must "allow access to content when box is properly unlocked" do
    assert_nothing_raised do
      @lock_box.unlock("secret")
      @lock_box.content
    end
  end

end</screen><para>As you can see, these tests read pretty clearly. Testing your
      exceptions is as easy as using the <literal moreinfo="none">assert_raises()</literal> and <literal moreinfo="none">assert_nothing_raised()</literal> methods with the
      relevant error class names. We can take a quick look at the
      implementation of <literal moreinfo="none">LockBox</literal> to see what
      the code that satisfies these tests looks like:<indexterm id="I_indexterm1_d1e724" significance="normal"><primary>assert_nothing_raised( ) method</primary></indexterm><indexterm id="I_indexterm1_d1e727" significance="normal"><primary>assert_raises( ) method</primary></indexterm></para><screen format="linespecific">class LockBox

  UnauthorizedAccess = Class.new(StandardError)
  InvalidPassword    = Class.new(StandardError)

  def initialize(options)
    @locked   = true
    @password = options[:password]
    @content  = options[:content]
  end

  def unlock(pass)
    @password == pass ? @locked = false : raise(InvalidPassword)
  end
<?dbfo-need height="1in"
?>
  def content
    @locked ? raise(UnauthorizedAccess) : @content
  end
end</screen><para>Nothing too fancy is going on here—just a few conditional
      arguments and a pair of custom exceptions.<footnote><para>The syntax used for creating errors here is just a shortcut
          for <literal moreinfo="none">class MyCustomError &lt; StandardError;
          end</literal>.</para></footnote> But if we failed to test the cases that generated the
      exceptions, we wouldn’t have full test coverage. Generally speaking, any
      time your methods might intentionally raise an error, you’ll want to set
      up test cases that cover both the condition where this error is raised
      as well as the case where it is not. This will help make sure that your
      error can actually be raised, while ensuring that it isn’t raised
      unconditionally. Testing this way will help you catch trivial mistakes
      up front, which is always a good thing.</para></sect2><sect2><title>Run the Whole Suite at Once</title><para>Though the examples we have worked with so far might fit well in a
      single file, you’ll eventually want to split up your tests across
      several files. However, that doesn’t mean that you should run them only
      in isolation!<indexterm id="I_indexterm1_d1e748" significance="normal"><primary>testing</primary><secondary>running entire suite at once</secondary></indexterm></para><para>A key feature of automated testing is that it gives you a
      comprehensive sense of how your software is running as a system, not
      just on a component-by-component basis. To keep aware of any problems
      that might occur during refactoring or wiring in new features, it is
      beneficial to run your entire suite of examples on every change.
      Luckily, using Ruby’s standard project automation tool, this is trivial.
      Here is a sample <literal moreinfo="none" role="keep-together">Rakefile</literal> that uses some of the most
      common conventions:<indexterm id="I_indexterm1_d1e758" significance="normal"><primary>rake test command</primary><secondary>using to automate running of test suite</secondary></indexterm></para><screen format="linespecific">require "rake/testtask"

task :default =&gt; [:test]

Rake::TestTask.new do |test|
  test.libs &lt;&lt; "test"
  test.test_files = Dir[ "test/test_*.rb" ]
  test.verbose = true
end</screen><para>This code makes it so <literal moreinfo="none">rake test</literal>
      will run every Ruby file in the <filename moreinfo="none">test/</filename> folder of
      your project that starts with <filename moreinfo="none">test_</filename> and ends with
      the <filename moreinfo="none">.rb</filename> extension. A typical directory layout that
      works with this sort of command looks like this:<indexterm id="I_indexterm1_d1e779" significance="normal"><primary>directory layout, running tests on entire suite</primary></indexterm></para><screen format="linespecific">test/
  test_foo.rb
  test_bar.rb</screen><para>You can tweak which files get run by changing the glob pattern
      passed to <literal moreinfo="none">Dir</literal>. These work pretty much
      the same as they do on the command line, so you can just put one
      together that suits your file layout.</para><para>Now, if you’ve got some expensive resources you’re writing tests
      against, such as file I/O, database interaction, or some network
      operation, you may be a bit nervous about the idea of running all your
      tests on every change you make. This may be due to performance concerns
      or due to the fact that you simply can’t afford to do frequent
      <emphasis>live</emphasis> tests of your external resources. However, in
      most cases, this problem can be worked around, and actually leads to
      better tests.</para><para>The solution I’m alluding to is <emphasis>mock objects</emphasis>,
      and how they can be used to avoid dependencies on external resources.
      We’ll go over several advanced concepts in the following section, but
      mocks are as good a place to start as any, so we’ll work with them
      first. Before we do that though, let’s review some of the key guidelines
      that outline testing fundamentals:<indexterm id="I_indexterm1_d1e799" significance="normal"><primary>testing</primary><secondary>key guidelines for testing fundamentals</secondary></indexterm><indexterm id="I_indexterm1_d1e804" significance="normal"><primary>dependencies</primary><secondary sortas="external">on external resources, avoiding by
          using mock objects</secondary></indexterm><indexterm id="I_indexterm1_d1e809" significance="normal"><primary>mock objects</primary><secondary>avoiding external resource dependencies</secondary></indexterm></para><itemizedlist><listitem><para>Keep your test cases atomic. If you are testing a function
          with multiple interfaces, write multiple examples. Also, write an
          example for each edge case you want to test.</para></listitem><listitem><para>Don’t just check function input and output, also use <literal moreinfo="none">assert_raises()</literal> and <literal moreinfo="none">assert_nothing_raised()</literal> to test that
          exceptions are being thrown under the right conditions, and not
          unexpectedly.</para></listitem><listitem><para>Use a rake task to automate running your test suite, and run
          all of your examples on every change to ensure that integration
          issues are caught as soon as they are introduced. Running tests
          individually may save time by catching problems early, but before
          moving from feature to feature, it is crucial to run the whole
          suite.</para></listitem></itemizedlist></sect2></sect1><sect1 id="I_sect11_d1e831"><title>Advanced Testing Techniques</title><para>The most basic testing techniques will get you far, but when things
    get complicated, you need to break out the big guns. What follows are a
    few tricks to try out when you run into a roadblock.</para><sect2><title>Using Mocks and Stubs</title><para>In a perfect world, all the resources that we needed would be
      self-contained in our application, and all interactions would take place
      in constant time. In our real work, life is nothing like this. We’ve got
      to deal with user input, database interaction, web service calls, file
      I/O, and countless other moving parts that live outside of our
      application. Testing these things can be painful.<indexterm class="startofrange" id="ch01_testingmocksstubs" significance="normal"><primary>testing</primary><secondary>using mocks and stubs</secondary></indexterm></para><para>Sure, we could set up a development database that gets blown out
      and reloaded every time our tests run—that’s what Rails does. We could
      read and write from temporary files, clearing out our leftovers after
      each example runs. For things like web services, we could build a fake
      service that acts the way we expect our live service to act and run it
      on a staging server. The question here is not whether it is possible to
      do this, but whether it is necessary.</para><para>Sometimes, you really do need to deal with real-world data. This
      is especially true when you want to tune and optimize performance or
      test resource-dependent interactions. However, in most cases, our code
      is mainly interested only in the behavior of the things we interact
      with, not what they really are. This is where either a mock or a stub
      could come in handy.<indexterm id="I_indexterm1_d1e850" significance="normal"><primary>resources (external), removing dependencies on</primary></indexterm><indexterm id="I_indexterm1_d1e853" significance="normal"><primary>dependencies</primary><secondary sortas="external">on external code and resources,
          removing</secondary></indexterm></para><para>There are additional benefits to removing dependencies on external
      code and resources as well. By removing these extra layers, you are
      capable of isolating your examples so that they test only the code in
      question. This purposefully eliminates a lot of <phrase role="keep-together">inter</phrase><phrase role="keep-together">dependencies</phrase> within your tests and helps
      make sure that you find and fix problems in the right places, instead of
      everywhere their influence is felt.</para><para>Let’s start with a trivial example, to help you get your head
      around the concepts of mocks and stubs, and form a working definition of
      what they are.</para><para>What follows is some basic code that asks a user a yes or no
      question, waits for input, and then returns <literal moreinfo="none">true</literal> or
      <literal moreinfo="none">false</literal> based on the answer. A basic implementation
      might look like this:</para><screen format="linespecific">class Questioner

  def ask(question)
    puts question
    response = gets.chomp
    case(response)
    when /^y(es)?$/i
      true
    when /^no?$/i
      false
    else
      puts "I don't understand."
      ask question
    end
  end

end</screen><para>Go ahead and toy around with this a bit by executing something
      similar to this little chunk of code, to get a sense for how it
      works:</para><screen format="linespecific">q = Questioner.new
puts q.ask("Are you happy?") ? "Good I'm Glad" : "That's Too Bad"</screen><para>Interacting with this code by just running a simple script in the
      console is enough to show that it pretty much works as expected.
      However, how do we test it? Is it enough to break down the code so that
      it’s a bit more testable, allowing us to write tests for everything but
      the actual user interaction?</para><?dbfo-need height=”1in”
?><screen format="linespecific">class Questioner

  def ask(question)
    puts question
    response = yes_or_no(gets.chomp)
    response.nil? ? ask(question) : response
  end

  def yes_or_no(response)
    case(response)
    when /^y(es)?$/i
      true
    when /^no?$/i
      false
    end
  end

end</screen><para>Now most of the work is being done in <literal moreinfo="none">yes_or_no</literal>, which is easily testable:</para><screen format="linespecific">class QuestionerTest &lt; Test::Unit::TestCase

  def setup
    @questioner = Questioner.new
  end

  %w[y Y  YeS YES yes].each do |yes|
    must "return true when yes_or_no parses #{yes}" do
      assert @questioner.yes_or_no(yes), "#{yes.inspect} expected to parse as true"
    end
  end

  %w[n N no nO].each do |no|
    must "return false when yes_or_no parses #{no}" do
      assert ! @questioner.yes_or_no(no), "#{no.inspect} expected to parse as false"
    end
  end

  %w[Note Yesterday xyzaty].each do |mu|
    must "return nil because #{mu} is not a variant of 'yes' or 'no'" do
      assert_nil @questioner.yes_or_no(mu), "#{mu.inspect} expected to parse as nil"
    end
  end

end</screen><para>These examples will all pass, and most of your code will be
      tested, except for the trivial <literal moreinfo="none">ask()</literal>
      method. However, what if we wanted to build code that relies on the
      results of the <literal moreinfo="none">ask()</literal> method?</para><screen format="linespecific">class Questioner

  def inquire_about_happiness
    ask("Are you happy?") ? "Good I'm Glad" : "That's Too Bad"
  end

  def ask(question)
    puts question
    response = yes_or_no(gets.chomp)
    response.nil? ? ask(question) : response
  end

  def yes_or_no(response)
    case(response)
    when /^y(es)?$/i
      true
    when /^no?$/i
      false
    end
  end
end</screen><para>If we want to write tests that depend on the return value of
      <literal moreinfo="none">ask()</literal>, we’ll need to do something to
      prevent the need for direct user input. A relatively simple way to test
      <literal moreinfo="none">inquire_about_happiness()</literal> is to
      replace the <literal moreinfo="none">ask()</literal> method with a stub
      that <phrase role="keep-together">returns</phrase> our expected values
      for each scenario:<indexterm id="I_indexterm1_d1e918" significance="normal"><primary>stubs</primary><secondary>using in testing</secondary></indexterm></para><screen format="linespecific">class HappinessTest &lt; Test::Unit::TestCase
  def setup
    @questioner = Questioner.new
  end

  must "respond 'Good I'm Glad' when inquire_about_happiness gets 'yes'" do
    def @questioner.ask(question); true; end
    assert_equal "Good I'm Glad", @questioner.inquire_about_happiness
  end

  must "respond 'That's Too Bad' when inquire_about_happiness gets 'no'" do
    def @questioner.ask(question); false; end
    assert_equal "That's Too Bad", @questioner.inquire_about_happiness
  end
end</screen><para>If we wanted to be a bit more formal about things, we could use a
      third-party tool to make our stubbing more explicit and easier to work
      with. There are lots of options for this, but one I especially like is
      the <emphasis>flexmock</emphasis> gem by Jim Weirich. We’ll look at this
      tool in much greater detail when we discuss formal mocking, but for now,
      let’s just look at how it can be used to clean up our stubbing
      example:<indexterm id="I_indexterm1_d1e930" significance="normal"><primary>stubs</primary><secondary>third party tools for</secondary></indexterm><indexterm id="I_indexterm1_d1e935" significance="normal"><primary>Weirich, Jim</primary></indexterm><indexterm id="I_indexterm1_d1e938" significance="normal"><primary>flexmock gem</primary></indexterm></para><screen format="linespecific">require "flexmock/test_unit"

class HappinessTest &lt; Test::Unit::TestCase
  def setup
    @questioner = Questioner.new
  end

  must "respond 'Good I'm Glad' when inquire_about_happiness gets 'yes'" do
    stubbed = flexmock(@questioner, :ask =&gt; true)
    assert_equal "Good I'm Glad", stubbed.inquire_about_happiness
  end

  must "respond 'That's Too Bad' when inquire_about_happiness gets 'no'" do
    stubbed = flexmock(@questioner, :ask =&gt; false)
    assert_equal "That's Too Bad", stubbed.inquire_about_happiness
  end
end</screen><para>The example code accomplishes the same task as our manual
      stubbing, but does so in an arguably more pleasant and organized way.
      Though it might be overkill to pull in a third-party package just to
      stub out a method or two, you can see how this interface would be
      preferable if you needed to write tests that were a little more
      complicated, or at least more involved.</para><para>No matter how we implement them, stubs do allow us to improve our
      test coverage a bit more here. Still, let’s pause for a moment and ask
      ourselves a question: did we really finish our job? Looking at the code,
      we find that our naive implementation sans tests looks like this:</para><screen format="linespecific">class Questioner

  def inquire_about_happiness
    ask("Are you happy?") ? "Good I'm Glad" : "That's Too Bad"
  end

  def ask(question)
    puts question
    response = gets.chomp
    case(response)
    when /^y(es)?$/i
      true
    when /^no?$/i
      false
    else
      puts "I don't understand."
      ask question
    end
  end

end</screen><para>Our test-driven results turn out like this:</para><screen format="linespecific">class Questioner

  def inquire_about_happiness
    ask("Are you happy?") ? "Good I'm Glad" : "That's Too Bad"
  end

  def ask(question)
    puts question
    response = yes_or_no(gets.chomp)
    response.nil? ? ask(question) : response
  end
<?dbfo-need height="1in"
?>
  def yes_or_no(response)
    case(response)
    when /^y(es)?$/i
      true
    when /^no?$/i
      false
    end
  end

end</screen><para>Though we’ve successfully split out our
      <literal moreinfo="none">yes_or_no</literal> parser for testing, we still don’t have any
      automated checks for how our code will display a question to the user
      and how it will respond based on that code. Presently, the only safety
      net we have for our I/O code is our limited testing in our terminals,
      which can hardly be called robust. Although it is of course better to
      have some coverage than no coverage at all, we can do better
      here.</para><para>Ruby ships with a <literal moreinfo="none">StringIO</literal>
      class, which essentially is an <literal moreinfo="none">IO</literal>
      object that is implemented to work against a string rather than the
      typical file handles. Although I hesitate to call this a mock object, it
      comes close in practice. We’ll take a quick look at how you might use it
      to test I/O code, which is a nice stepping stone that can lead us into
      real mock territory.<indexterm id="I_indexterm1_d1e969" significance="normal"><primary>input and output</primary><secondary>using StringIO as mock for IO objects</secondary></indexterm><indexterm id="I_indexterm1_d1e974" significance="normal"><primary>mock objects</primary><secondary>StringIO class as</secondary></indexterm><indexterm id="I_indexterm1_d1e979" significance="normal"><primary>StringIO class</primary></indexterm></para><para>But before we can test with <literal moreinfo="none">StringIO</literal>, we need to make it so that our
      <literal moreinfo="none">Questioner</literal> class allows us to swap
      out the input and output sources for our own custom objects:</para><screen format="linespecific">class Questioner

  def initialize(in=STDIN,out=STDOUT)
    @input  = in
    @output = out
  end

  def ask(question)
    @output.puts question
    response = @input.gets.chomp
    case(response)
    when /^y(es)?$/i
      true
    when /^no?$/i
      false
    else
      @output.puts "I don't understand."
      ask question
    end
  end

end</screen><para>By default, nothing will change and I/O will still go to <literal moreinfo="none">STDIN</literal> and <literal moreinfo="none">STDOUT</literal>. However, this opens the door for
      replacing these I/O objects with a pair of <literal moreinfo="none">StringIO</literal>
      objects, allowing us to totally rethink our tests:</para><screen format="linespecific">class QuestionerTest &lt; Test::Unit::TestCase

  def setup
    @input  = StringIO.new
    @output = StringIO.new
    @questioner = Questioner.new(@input,@output)
    @question   = "Are you happy?"
  end

  ["y", "Y", "YeS", "YES", "yes"].each do |y|
    must "return false when parsing #{y}" do
       provide_input(y)
       assert @questioner.ask(@question), "Expected '#{y}' to be true"
       expect_output "#{@question}\n"
     end
   end

  ["n", "N", "no", "nO"].each do |no|
     must "return false when parsing #{no}" do
       provide_input(no)
       assert !@questioner.ask(@question)
       expect_output "#{@question}\n"
     end
   end

  [["y", true],["n", false]].each do |input,state|
    must "continue to ask for input until given #{input}" do
      provide_input "Note\nYesterday\nxyzaty\n#{input}"
      assert_equal state, @questioner.ask(@question)
      expect_output "#{@question}\nI don't understand.\n"*3 + "#{@question}\n"
    end
  end

  def provide_input(string)
    @input &lt;&lt; string
    @input.rewind
  end

  def expect_output(string)
    assert_equal string, @output.string
  end

end</screen><para>Without too much more effort, we were able to specify and test the
      full behavior of this trivial little program. We are able to test both
      the logic, and the actual I/O operations, to verify that they work as we
      expect them to. In this particular case, we were pretty lucky that Ruby
      ships with a library that acts like an I/O object and makes our testing
      easier. We won’t always be so lucky. What’s more, we don’t really need
      most of what <literal moreinfo="none">StringIO</literal> has to offer here. A lighter
      (albeit more abstract) approach would be to use a formal mocking
      framework to do the job. Let’s take a look at how this problem might be
      solved in flexmock, to make things a bit clearer:<indexterm id="I_indexterm1_d1e1010" significance="normal"><primary>flexmock gem</primary><secondary>testing IO objects and operations</secondary></indexterm></para><?dbfo-need height=”1in”
?><screen format="linespecific">require "flexmock/test_unit"

class QuestionerTest &lt; Test::Unit::TestCase

  def setup
    @input  = flexmock("input")
    @output = flexmock("output")
    @questioner = Questioner.new(@input,@output)
    @question   = "Are you happy?"
  end

  ["y", "Y", "YeS", "YES", "yes"].each do |y|
    must "return false when parsing #{y}" do
       expect_output @question
       provide_input(y)
       assert @questioner.ask(@question), "Expected '#{y}' to be true"
     end
   end

  ["n", "N", "no", "nO"].each do |no|
    must "return false when parsing #{no}" do
      expect_output @question
      provide_input(no)
      assert !@questioner.ask(@question)
    end
  end

  [["y", true], ["n", false]].each do |input, state|
    must "continue to ask for input until given #{input}" do
      %w[Yesterday North kittens].each do |i|
        expect_output @question
        provide_input(i)
        expect_output("I don't understand.")
      end

      expect_output @question
      provide_input(input)

      assert_equal state, @questioner.ask(@question)
    end
  end

  def provide_input(string)
    @input.should_receive(:gets =&gt; string).once
  end

  def expect_output(string)
    @output.should_receive(:puts).with(string).once
  end

end</screen><para>The interesting thing about this example is that <literal moreinfo="none">flexmock()</literal> returns a completely generic
      object, yet this accomplishes the same results as using
      <literal moreinfo="none">StringIO</literal>, which is finely tuned for emulating a real
      <literal moreinfo="none">IO</literal> object. The end result is that the
      latter example tends to focus on the interactions between your code and
      the resource, and that the former example is more directly bound to what
      an I/O object actually is. It can be beneficial to avoid such tight
      distinctions, especially when working in Ruby, where what an object
      actually is tends to be less important than what it can do.</para><para>To generalize: mock objects essentially break interactions down
      into the messages that an object should receive, the arguments that
      accompany the messages, the return values of the methods, whether a
      block is yielded, and whether any errors should be raised. If this
      sounds like a lot, don’t worry too much. The beauty of a mock object is
      that you need to specify only those things that are necessary to handle
      in your code.<indexterm id="I_indexterm1_d1e1032" significance="normal"><primary>mock objects</primary><secondary>summary of functionality</secondary></indexterm></para><para>Flexmock (like many of the other Ruby mocking options) is quite
      robust, and to go over it extensively here would take more than just a
      single section of a chapter. However, through this simple example, you
      can see that there are ways to avoid actively hitting your external
      resources while still being able to test your interactions with
      them.</para><para>Of course, using a mock object comes with its own cost, like
      anything else. In this example, if we changed the internal code to use
      <literal moreinfo="none">print()</literal> instead of <literal moreinfo="none">puts()</literal>, we would need to modify our mock
      object, but we would not need to modify our <literal moreinfo="none">StringIO</literal>-based solution. Although a mock
      object completely eliminates the need to worry about the internal state
      of your dependencies, it creates a tighter coupling to their interfaces.
      This means that some care should be taken when deciding just how much
      you want to mock out in any given test suite.<indexterm id="I_indexterm1_d1e1050" significance="normal"><primary>mock objects</primary><secondary>costs of using</secondary></indexterm></para><para>Learning how to build decent mock objects without going overboard
      takes some practice, but is not too hard once you get the hang of it. It
      ultimately forms one of the <emphasis>hard</emphasis> aspects of
      testing, and once that bridge is crossed, only a few more
      remain.<indexterm id="I_indexterm1_d1e1060" class="endofrange" startref="ch01_testingmocksstubs" significance="normal"/></para></sect2><sect2><title>Testing Complex Output</title><para>Dealing with programs that need to generate complex output can be
      a pain. Verifying that things actually work as you expect them to is
      important, but simply comparing raw output values in an automated test
      leads to examples that are nearly impossible to follow. However, we
      often resort to just dumping our expected data into our tests and
      <phrase role="keep-together">comparing</phrase> it to what we’re
      actually generating. This sort of test is useful for <phrase role="keep-together">detecting</phrase> when a problem arises, but
      finding the source of it, even with decent diff utilities, can be a real
      pain.<indexterm class="startofrange" id="ch01_IOtestingcomplexO" significance="normal"><primary>input and output</primary><secondary>testing complex output</secondary></indexterm><indexterm class="startofrange" id="ch01_testingcomplexoutput" significance="normal"><primary>testing</primary><secondary>complex output</secondary></indexterm></para><para>Imagine we’ve got a basic blog that needs to output RSS, which is
      really just a specialized XML format. The following example is a
      simplified version of what I use to generate the feeds in my blog. James
      Gray actually wrote the code for it, using XML Builder, another great
      gem from Jim Weirich:<indexterm class="startofrange" id="ch01_RSStesting" significance="normal"><primary>RSS feed, testing</primary></indexterm><indexterm id="I_indexterm1_d1e1087" significance="normal"><primary>XML</primary><secondary>RSS feeds</secondary></indexterm><indexterm id="I_indexterm1_d1e1092" significance="normal"><primary>Weirich, Jim</primary></indexterm><indexterm id="I_indexterm1_d1e1095" significance="normal"><primary>XML Builder</primary></indexterm></para><screen format="linespecific">require "builder"
require "ostruct"

class Blog &lt; OpenStruct
<?dbfo-need height="1in"
?>
  def entries
    @entries ||= []
  end

  def to_rss
    xml = Builder::XmlMarkup.new
    xml.instruct!
    xml.rss version: "2.0" do
      xml.channel do
        xml.title       title
        xml.link        "http://#{domain}/"
        xml.description  description
        xml.language    "en-us"

        @entries.each do |entry|
          xml.item do
            xml.title       entry.title
            xml.description entry.description
            xml.author      author
            xml.pubDate     entry.published_date
            xml.link        entry.url
            xml.guid        entry.url
          end
        end
      end
    end
  end

end</screen><para>We need to test that the output of this <literal moreinfo="none">to_rss</literal> method is what we expect it to be. The
      lazy approach would look like this:</para><screen format="linespecific">require "time"

class BlogTest &lt; Test::Unit::TestCase

FEED = &lt;&lt;-EOS
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;rss version="2.0"
&gt;&lt;channel&gt;&lt;title&gt;Awesome&lt;/title&gt;&lt;link&gt;http://majesticseacreature.com/&lt;/link&gt;
&lt;description&gt;Totally awesome&lt;/description&gt;&lt;language&gt;en-us&lt;/language&gt;&lt;item&gt;
&lt;title&gt;First Post&lt;/title&gt;&lt;description&gt;Nothing interesting&lt;/description&gt;
&lt;author&gt;Gregory Brown&lt;/author&gt;&lt;pubDate&gt;2008-08-08 00:00:00 -0400&lt;/pubDate&gt;
&lt;link&gt;http://majesticseacreature.com/awesome.html&lt;/link&gt;
&lt;guid&gt;http://majesticseacreature.com/awesome.html&lt;/guid&gt;&lt;/item&gt;&lt;/channel&gt;&lt;/rss&gt;
EOS

  def setup
    @blog = Blog.new
    @blog.title       = "Awesome"
    @blog.domain      = "majesticseacreature.com"
    @blog.description = "Totally awesome"
    @blog.author      = "Gregory Brown"
<?dbfo-need height="1in"
?>
    entry = OpenStruct.new
    entry.title          = "First Post"
    entry.description    = "Nothing interesting"
    entry.published_date = Time.parse("08/08/2008")
    entry.url            = "http://majesticseacreature.com/awesome.html"

    @blog.entries &lt;&lt; entry
  end


  must "have a totally awesome RSS feed" do
    assert_equal FEED.delete("\n"), @blog.to_rss
  end

end</screen><para>You could make this slightly less ugly by storing your output in a
      file, but it’s not much better:</para><screen format="linespecific">class BlogTest &lt; Test::Unit::TestCase

  def setup
    @blog = Blog.new
    @blog.title       = "Awesome"
    @blog.domain      = "majesticseacreature.com"
    @blog.description = "Totally awesome"
    @blog.author      = "Gregory Brown"

    entry = OpenStruct.new
    entry.title          = "First Post"
    entry.description    = "Nothing interesting"
    entry.published_date = Time.parse("08/08/2008")
    entry.url            = "http://majesticseacreature.com/awesome.html"

    @blog.entries &lt;&lt; entry
  end

  must "have a totally awesome RSS feed" do
    assert_equal File.read("expected.rss"), @blog.to_rss
  end

end</screen><para>In the end, the issue boils down to the fact that you’re
      definitely not focusing on the important parts of the problem if you
      have to check the output character by character. An RSS feed with some
      extra whitespace in it would be no less valid than the file shown here,
      yet it would cause an annoying failure in your tests.</para><para>Unless it really isn’t worth your time, the best way to deal with
      complex output is to parse it into a workable dataset before doing your
      comparisons. There are a few RSS feed parsers out there that would make
      quick work of a file like this. However, in the interest of generality,
      we could use a generic XML parser without much more effort.<indexterm id="I_indexterm1_d1e1119" significance="normal"><primary>parsers</primary><secondary>RSS and XML</secondary></indexterm><indexterm id="I_indexterm1_d1e1124" significance="normal"><primary>XML</primary><secondary>parsing in Ruby</secondary></indexterm></para><para>There are a few solid choices for XML parsing in Ruby, and even
      support for it in the standard library. However, the library that I find
      most pleasant to work with is the <emphasis role="keep-together">nokogiri</emphasis> gem, written by Aaron
      Patterson. Here’s what part of the tests look like after they’ve been
      reworked to use Nokogiri:<indexterm id="I_indexterm1_d1e1134" significance="normal"><primary>Patterson, Aaron</primary></indexterm><indexterm id="I_indexterm1_d1e1137" significance="normal"><primary>nokogiri gem</primary></indexterm></para><screen format="linespecific">require "time"
require "nokogiri"

class BlogTest &lt; Test::Unit::TestCase

  def setup
    @blog = Blog.new
    @blog.title       = "Awesome"
    @blog.domain      = "majesticseacreature.com"
    @blog.description = "Totally awesome"
    @blog.author      = "Gregory Brown"

    entry = OpenStruct.new
    entry.title          = "First Post"
    entry.description    = "Nothing interesting"
    entry.published_date = Time.parse("08/08/2008")
    entry.url            = "http://majesticseacreature.com/awesome.html"

    @blog.entries &lt;&lt; entry
    @feed = Nokogiri::XML(@blog.to_rss)
  end

  must "be RSS v 2.0" do
    assert_equal "2.0", @feed.at("rss")["version"]
  end

  must "have a title of Awesome" do
    assert_equal "Awesome", text_at("rss", "title")
  end

  must "have a description of Totally Awesome" do
    assert_equal "Totally awesome", text_at("rss", "description")
  end

  must "have an author of Gregory Brown" do
    assert_equal "Gregory Brown", text_at("rss", "author")
  end

  must "have an entry with the title: First Post" do
    assert_equal "First Post", text_at("item", "title")
  end

  def text_at(*args)
    args.inject(@feed) { |s,r| s.send(:at, r) }.inner_text
  end

end</screen><para>This is a huge improvement! Now, our tests actually look like
      they’re verifying the things we’re interested in, rather than simply
      checking our output against some amorphous code blob that we can’t
      easily inspect and verify.</para><para>Of course, this approach to testing complex data requires you to
      trust whatever you are using to parse your output, but as long as you
      can do that, the ability of whatever library you use to parse your
      output is from the very start an indication that you are producing
      meaningful results.<indexterm id="I_indexterm1_d1e1147" class="endofrange" startref="ch01_RSStesting" significance="normal"/></para><para>Not every file format you will encounter will have parsers
      available for it, of course. Some of the formats you need to produce may
      even be fully custom-made. However, providing that it isn’t impossible
      to build one, a parser will come in handy for making your tests more
      flexible and expressive. Consider this possibility before turning to
      direct file comparison as a last resort only.</para><para>We’re about to wrap up with a mixed bag of tips and tricks for
      keeping your test suite maintainable, but before we do that, let’s go
      over some of the highlights of the advanced testing techniques discussed
      in this section:<indexterm id="I_indexterm1_d1e1152" significance="normal"><primary>testing</primary><secondary>highlights of advanced testing techniques</secondary></indexterm></para><itemizedlist><listitem><para>Mocks and stubs can be used to remove external dependencies
          from tests while still verifying proper behavior and
          interaction.<indexterm id="I_indexterm1_d1e1161" significance="normal"><primary>mock objects</primary><secondary>uses of</secondary></indexterm></para></listitem><listitem><para>Stubs are used when we want to replace some functionality with
          canned results to make testing other code easier.<indexterm id="I_indexterm1_d1e1169" significance="normal"><primary>stubs</primary><secondary>uses of</secondary></indexterm></para></listitem><listitem><para>Mocks are used to create objects that can act in place of an
          external resource for the purpose of testing. Mock objects are set
          up with expected responses, which are then verified when the tests
          are run. This means that if you have something like <literal moreinfo="none">my_obj.should_receive(:foo).once</literal> and
          <literal moreinfo="none">foo</literal> is never called on <literal moreinfo="none">my_obj</literal>, this will result in a test
          failure. This is the primary difference between mocks and
          stubs.</para></listitem><listitem><para>When testing complex output, it is best to find a tool that
          parses the output format you are generating, and write your tests
          against its results.</para></listitem><listitem><para>When you can’t find a tool for parsing your output format, you
          might consider building one that parses only the values you are
          interested in, in addition to necessary basic validation of the
          document’s structure.</para></listitem><listitem><para>If it isn’t possible to parse your generated data without
          great effort, consider storing your expected output in its own file
          and loading it into your tests as needed, using a diff utility to
          compare expected and actual output.</para></listitem><listitem><para>For most XML formats, Nokogiri does a great job of parsing the
          document and making it easily searchable.<indexterm id="I_indexterm1_d1e1198" class="endofrange" startref="ch01_IOtestingcomplexO" significance="normal"/><indexterm id="I_indexterm1_d1e1199" class="endofrange" startref="ch01_testingcomplexoutput" significance="normal"/></para></listitem></itemizedlist></sect2></sect1><sect1 id="I_sect11_d1e1200"><title>Keeping Things Organized</title><para>Just like other code, test suites tend to grow in both size and
    complexity throughout the lifecycle of a project. The following techniques
    help keep things tidy and well factored, allowing your tests to continue
    to serve as a road map to your project.<indexterm id="I_indexterm1_d1e1205" significance="normal"><primary>testing</primary><secondary>keeping things organized</secondary></indexterm></para><sect2><title>Embedding Tests in Library Files</title><para>If you are working on a very small program or library, and you
      want to be able to run your tests while in development, but then require
      the code as part of another program later, there is a simple idiom that
      is useful for embedding your tests:<indexterm id="I_indexterm1_d1e1215" significance="normal"><primary>library files, embedding tests in</primary></indexterm><indexterm id="I_indexterm1_d1e1218" significance="normal"><primary>embedding tests in library files</primary></indexterm><indexterm id="I_indexterm1_d1e1221" significance="normal"><primary>testing</primary><secondary>keeping things organized</secondary><tertiary>embedding tests in library files</tertiary></indexterm></para><screen format="linespecific">class Foo
  ...
end

if __FILE__ == $PROGRAM_NAME
  require "test/unit"

  class TestFoo &lt; Test::Unit::TestCase
    #...
  end
end</screen><para>Simply wrapping your tests in this <literal moreinfo="none">if</literal> statement
      will allow running <literal moreinfo="none">ruby foo.rb</literal> to
      execute your tests, while <literal moreinfo="none">require
      "foo"</literal> will still work as expected without running the tests.
      This can be useful for sharing small programs with others, or for
      writing some tests while developing a small prototype of a larger
      application. However, once you start to produce more than a few test
      cases, be sure to break things back out into their normal directory
      structure. Giant files can be a bit unwieldy to deal with, and it is a
      bit awkward (even though it is possible) to treat your
      <filename moreinfo="none">lib/</filename> directory as if it were also your test
      suite.<indexterm id="I_indexterm1_d1e1244" significance="normal"><primary>foo.rb, running to execute tests</primary></indexterm></para></sect2><sect2><title>Test Helpers</title><para>When you begin to chain together a large amount of test cases, you
      might find that you are repeating some information across them. Some of
      the most common things in this regard are <literal moreinfo="none">require</literal>
      statements and basic helper functions.<indexterm id="I_indexterm1_d1e1255" significance="normal"><primary>helper functions for testing</primary></indexterm><indexterm id="I_indexterm1_d1e1258" significance="normal"><primary>require statements for testing</primary></indexterm><indexterm id="I_indexterm1_d1e1261" significance="normal"><primary>testing</primary><secondary>keeping things organized</secondary><tertiary>using test helpers</tertiary></indexterm></para><para>A good solution to keep things clean is to create a
      <filename moreinfo="none">test/test_helpers.rb</filename> file and then do all of your
      global configuration there. In your individual tests, you can require
      this file by expanding the direct path to it, using the following
      idiom:<indexterm id="I_indexterm1_d1e1273" significance="normal"><primary>test/test_helpers.rb file, creating</primary></indexterm></para><programlisting id="I_programlisting1_d1e1276" format="linespecific">require File.dirname(__FILE__) + '/test_helpers'</programlisting><para>This allows your test files to be run individually from any
      directory, not just the top-level directory. Here is a sample
      <filename moreinfo="none">test_helpers.rb</filename> from the Prawn project to give you
      a sense of what kinds of things might go into the file:</para><screen format="linespecific">require "rubygems"
require "test/unit"

$LOAD_PATH &lt;&lt; File.join(File.dirname(__FILE__), '..', 'lib')
require "prawn"
gem 'pdf-reader', "&gt;=0.7.3"
require "pdf/reader"
<?dbfo-need height="1in"
?>
def create_pdf
  @pdf = Prawn::Document.new(  left_margin: 0,  right_margin: 0,
                                  top_margin: 0, bottom_margin: 0 )
end

def observer(klass)
  @output = @pdf.render
  obs = klass.new
  PDF::Reader.string(@output,obs)
  obs
end

def parse_pdf_object(obj)
  PDF::Reader::Parser.new(
     PDF::Reader::Buffer.new(StringIO.new(obj)), nil).parse_token
end

puts "Prawn tests: Running on Ruby Version: #{RUBY_VERSION}"</screen><para>Here you can see that load path adjustments, project-specific
      dependencies, and some basic helper functions are being loaded. The
      helper functions are obviously Prawn-<phrase role="keep-together">specific</phrase>, but as you can see, they provide
      wrappers around common operations that need to be done in a number of
      our tests, which result in something like this in practice:</para><screen format="linespecific">class PolygonTest &lt; Test::Unit::TestCase

  must "draw each line passed to polygon()" do
    @pdf = Prawn::Document.new
    @pdf.polygon([100,500],[100,400],[200,400])

    line_drawing = observer(LineDrawingObserver)
    assert_equal [[100,500],[100,400],[200,400],[100,500]],
                   line_drawing.points
  end

end</screen><para>It’s completely up to you how far you wish to take this sort of
      thing. As a rule of thumb, if you find yourself using a feature in more
      than a few places, consider adding it to
      <filename moreinfo="none">test_helpers.rb</filename>. If you want a little more of a
      clean approach, you can wrap your helpers in a module, but depending on
      what you’re doing, just defining them at the top level might be fine as
      well.</para><para>Your helper file essentially allows you to centralize the support
      features for your test suite. When used effectively, this approach can
      greatly simplify your tests and <phrase role="keep-together">reduce</phrase> <phrase role="keep-together">duplicated</phrase> code that can lead to
      problems.</para></sect2><?dbfo-need height="1in"
?><sect2><title>Custom Assertions</title><para>In addition to building helper functions to support your examples,
      you can actually build custom assertions to augment the vocabulary of
      your tests.<indexterm id="I_indexterm1_d1e1313" significance="normal"><primary>assertions, custom, building for testing</primary></indexterm><indexterm id="I_indexterm1_d1e1316" significance="normal"><primary>testing</primary><secondary>keeping things organized</secondary><tertiary>building custom assertions</tertiary></indexterm></para><para>Porting an example from RSpec’s documentation, it is easy to see
      how simple it is to add a custom assertion to your tests. We want to
      transform a basic statement that looks like this:</para><programlisting id="I_programlisting1_d1e1325" format="linespecific">assert bob.current_zone.eql?(Zone.new("4"))</programlisting><para>into something a bit more friendly, such as:</para><programlisting id="I_programlisting1_d1e1329" format="linespecific">assert_in_zone("4", bob)</programlisting><para>To do this in <literal moreinfo="none">Test::Unit</literal>, we’ll
      make use of the low-level function <literal moreinfo="none">assert_block()</literal>. Here’s how you would define
      <literal moreinfo="none">assert_in_zone</literal> and its complement,
      <literal moreinfo="none">assert_not_in_zone</literal>:<indexterm id="I_indexterm1_d1e1345" significance="normal"><primary>assert_block( ) function, using to build custom
          assertions</primary></indexterm></para><screen format="linespecific">def assert_in_zone(expected, person)
  assert_block("Expected #{person.inspect} to be in Zone #{expected}") do
    person.current_zone.eql?(Zone.new(expected))
  end
end

def assert_not_in_zone(expected_zone, person)
  assert_block("Expected #{person.inspect} not to be in Zone #{expected}") do
    !person.current_zone.eql?(Zone.new(expected))
  end
end</screen><para>With these definitions in place, you can use the assertions as we
      specified earlier. When the statement is true, the assertion will pass;
      when it is false, the assertion will fail and display the custom
      message. All of the assertions in <literal moreinfo="none">Test::Unit</literal> can be built upon <literal moreinfo="none">assert_block</literal>, which indicates how powerful it
      can be for creating your own higher-level assertions.</para><para>We’re winding to a close with the discussion of testing practices,
      but here’s the recap of things you can do to keep your testing code neat
      and well formed:<indexterm id="I_indexterm1_d1e1360" significance="normal"><primary>testing</primary><secondary>keeping things organized</secondary><tertiary>summary of practices</tertiary></indexterm></para><itemizedlist><listitem><para>If you’re working with a tiny program, don’t bother with the
          formal directory structure—just use the simple idiom that allows
          your script to be both loaded as a library and run as an
          executable.</para></listitem><listitem><para>If your application is bigger, eliminate duplication by
          centralizing your boilerplate and support code in a
          <filename moreinfo="none">test/test_helpers.rb</filename> file that is required by
          all of your tests.</para></listitem><listitem><para>If your code seems to be doing a lot of complicated stuff and
          <literal moreinfo="none">Test::Unit</literal>’s built-in assertions aren’t doing the
          trick, build your own via the simple <literal moreinfo="none">assert_block</literal> <phrase role="keep-together">function</phrase>.</para></listitem></itemizedlist></sect2></sect1><?dbfo-need height="1in"
?><sect1 id="I_sect11_d1e1390"><title>Conclusions</title><para>Testing is a big topic—one that can easily span across several
    books. Each respective testing framework available in Ruby can be an
    equally huge topic, and one that is worth studying in its own right.
    Nevertheless, the goal of this chapter was to teach the principles behind
    test-driven development, rather than the exact technical applications you
    might encounter. It is important to remember that testing is meant to make
    your code better and more maintainable, not to lead you into confusion or
    make you feel like you’re stuck doing busywork instead of doing real
    coding.</para><para>Also remember that if your solution seems difficult to test, it may
    be a sign that your design is not flexible enough to easily be refactored
    or interacted with. By writing the tests before the code, and cleaning up
    after every small feature spike, it becomes easier and easier to avoid the
    common pitfalls of overly complex code.</para><para>Of course, there are cases in which things really just are difficult
    to test. You’ll know when you run into these things, as they often include
    dependence on a complex or difficult-to-pin-down external resource, or
    have some other special thing about them that just makes testing
    <emphasis>hard</emphasis>. In these cases, don’t let testing dogma get in
    your way: it doesn’t make sense to freeze in place simply because you
    can’t think of a good testing strategy. But by the same token, don’t let
    these things steal your focus away from the parts of your application that
    you actually can test. Try to remember that partial coverage is usually
    much better than no coverage at all.</para><para>The good thing is that for the most part, Ruby is a language that
    truly makes testing enjoyable, as long as you learn how to do it properly.
    The topics covered in this chapter will hopefully put you well on your
    way, but the best way to get into the swing of things is simply to get out
    there and start writing some tests. The rest will come together
    naturally.<indexterm id="I_indexterm1_d1e1404" class="endofrange" startref="ch01_testing" significance="normal"/></para></sect1></chapter><chapter id="ch02"><title>Designing Beautiful APIs</title><para>As developers, we experience the difference between good and bad
  programmatic interfaces every single day. Some modules we work with seem to
  speak right to us, clearly expressing their role in our project in a loud,
  confident voice. Others mumble nonsense and occasionally freak out on us in
  ways we’d never expect. In many ways, our code is only as good as its
  application programming interface (API). Good APIs provide exactly what we
  need, in the way we need it. Bad APIs confuse us and make us jump through
  hoops to get things working, pushing us one step closer to the dreaded “Big
  Rewrite.” Ruby provides the tools to build beautifully clear interfaces, but
  these same tools can produce chaos and disarray when placed in misguided
  hands.<indexterm id="I_indexterm2_d1e1410" significance="normal"><primary>designing APIs</primary><see>APIs, designing</see></indexterm><indexterm class="startofrange" id="ch02_APIdesign" significance="normal"><primary>APIs, designing</primary></indexterm></para><para>In this chapter, we’ll take a look at the infrastructure Ruby provides
  to help you design solid interfaces. We’ll examine both the technical
  details and the motivation behind the various different approaches, allowing
  you to see both the how and why that’s involved in designing “Rubyish” APIs.
  We’ll begin by looking through a practical example of API design from a real
  project, and then move on to more specific tips and tricks. Along the way,
  you’ll gain both conceptual and technical understanding of how to design
  suitable APIs for your Ruby projects.</para><sect1 id="I_sect12_d1e1420"><title>Designing for Convenience: Ruport’s Table( ) feature</title><para>In Ruby Reports (Ruport), virtually all of our users will need to
    work with tabular data at some point. This data can come from any number
    of sources, ranging from a simple CSV file to a complex data analysis
    procedure that produces tables as its output. Providing a simple, clear
    API that works well for all of these cases is a bit of a challenge.
    Although the ultimate goal of each of the different tasks that we can
    imagine is fundamentally the same, the means for accomplishing them are
    quite different.<indexterm class="startofrange" id="ch02_APIdesignconvenience" significance="normal"><primary>APIs, designing</primary><secondary>designing for convenience, Ruport Table( )
        method</secondary></indexterm><indexterm class="startofrange" id="ch02_RuportTable" significance="normal"><primary>Ruport</primary><secondary>Table( ) feature</secondary></indexterm></para><para>Our first instinct was to reflect this in the API, resulting in
    several different constructors for the different ways of building
    tables:</para><programlisting id="I_programlisting2_d1e1437" format="linespecific">table1 = Ruport::Data::Table.new(
   :column_names =&gt; %w[first_name last_name],
   :data         =&gt; [["Gregory","Brown"],["Deborah","Orlando"]] )

table2 = Ruport::Data::Table.load("people.csv")

csv = "first_name,last_name\nGregory,Brown\nDeborah\nOrlando\n"
table3 = Ruport::Data::Table.parse(csv)</programlisting><para>Although it is clear enough what is going on here, it is necessary
    to remember the names and signatures of several different methods. We were
    convinced we could do better, and eventually came up with this:<indexterm class="startofrange" id="ch02_Table" significance="normal"><primary>Table( ) method (Ruport)</primary></indexterm></para><programlisting id="I_programlisting2_d1e1444" format="linespecific">table1 = Table(%w[first_name last_name],
   :data =&gt; [["Gregory","Brown"],["Deborah","Orlando"]])

table2 = Table("people.csv")

csv = "first_name,last_name\nGregory,Brown\nDeborah,Orlando\n"
table3 = Table(:string =&gt; csv)</programlisting><para>Though the difference here is somewhat subtle, there is definitely
    something more natural about the way this code reads. Rather than feeling
    like we’re initializing a class, it feels more as if we’re converting our
    data into a <literal moreinfo="none">Table</literal> object. This is
    similar to the way a number of Ruby’s built-in methods work, including
    <literal moreinfo="none">Integer()</literal>, <literal moreinfo="none">Array()</literal>, and friends.</para><para>Introducing the <literal moreinfo="none">Table()</literal> method
    was a big win, as it simplified things for the most common cases in
    Ruport. However, rather than trashing the old interface, we instead opted
    to wrap it. This approach gives curmudgeons who dislike magic an
    alternative avenue while providing some additional benefits. The most
    obvious one is that the <literal moreinfo="none">Table()</literal> method
    itself is fairly simple code:</para><programlisting id="I_programlisting2_d1e1465" format="linespecific">def Table(*args,&amp;block)
  table = case args[0]
  when Array
    opts = args[1] || {}
    Ruport::Data::Table.new({:column_names =&gt; args[0]}.merge(opts),&amp;block)
  when /\.csv$/i
    Ruport::Data::Table.load(*args,&amp;block)
  when Hash
    if file = args[0].delete(:file)
      Ruport::Data::Table.load(file,args[0],&amp;block)
    elsif string = args[0].delete(:string)
      Ruport::Data::Table.parse(string,args[0],&amp;block)
    else
      Ruport::Data::Table.new(args[0],&amp;block)
    end
  else
     Ruport::Data::Table.new(:data =&gt; [], :column_names =&gt; args,&amp;block)
  end

  return table
end</programlisting><para>Though it may be a little bit busy with so much going on, the entire
    purpose of this method is simply to recognize the kind of table loading
    you are doing, then delegate to the appropriate constructor method. We do
    this by treating the arguments passed to the method as an array. We also
    capture any block passed to the method so that we can pass it down into
    the constructors, but we’ll get back to that later. For now, let’s simply
    focus on the array of arguments passed in.</para><para>We can walk through the examples already shown to get a sense of
    what’s going on. In our first example, we called the method with an array
    of column names, and a hash of options:</para><programlisting id="I_programlisting2_d1e1472" format="linespecific">table1 = Table(%w[first_name last_name],
  :data =&gt; [["Gregory","Brown"],["Deborah","Orlando"]])</programlisting><para>In this case, <literal moreinfo="none">args</literal> contains two elements: an
    array of column names and a hash of options. The structure looks like
    this:</para><programlisting id="I_programlisting2_d1e1479" format="linespecific">[ %w[first_name last_name],
  { :data =&gt; [["Gregory","Brown"],["Deborah","Orlando"]] } ]</programlisting><para>Our case statement matches <literal moreinfo="none">args[0]</literal> as an <literal moreinfo="none">Array</literal>, and pulls the <literal moreinfo="none">Hash</literal> out from <literal moreinfo="none">args[1]</literal>. After processing, our final call is
    equivalent to this:</para><programlisting id="I_programlisting2_d1e1495" format="linespecific">Ruport::Data::Table.new(
  :column_names =&gt; %w[first_name last_name],
  :data         =&gt; [["Gregory","Brown"],["Deborah","Orlando"]] )</programlisting><para>As you can see, this is exactly equivalent to the very first call
    shown in this chapter. If we left out the data parameter in our <literal moreinfo="none">Hash</literal>, we’d see the following translation:</para><programlisting id="I_programlisting2_d1e1502" format="linespecific">headings = %w[first_name last_name]
Ruport::Data::Table.new(:column_names =&gt; headings) == Table(headings) #=&gt; true</programlisting><para>Working with our second example is even easier. We’re passing a CSV
    filename like so:</para><programlisting id="I_programlisting2_d1e1506" format="linespecific">table2 = Table("people.csv")</programlisting><para>In this situation, <literal moreinfo="none">args</literal> is a single element array
    with <literal moreinfo="none">args[0]</literal> as <literal moreinfo="none">"people.csv"</literal>. Our case statement immediately
    matches this and then uses the array splat operator (<literal moreinfo="none">*</literal>)
    to pass the arguments directly to <literal moreinfo="none">Ruport::Data::Table.load()</literal>. In this case, our
    <literal moreinfo="none">Table()</literal> method is just being lazy,
    ultimately just acting identically to <literal moreinfo="none">Ruport::Data::Table.load()</literal> as long as your file
    ends in <filename moreinfo="none">.csv</filename>.<indexterm id="I_indexterm2_d1e1535" significance="normal"><primary>Ruport::Data::Table.load( )</primary></indexterm><indexterm id="I_indexterm2_d1e1538" significance="normal"><primary>* (array splat operator)</primary></indexterm><indexterm id="I_indexterm2_d1e1541" significance="normal"><primary>array splat operator (*)</primary></indexterm></para><para>What if your file has a nonstandard extension or no extension at
    all? Both you and <literal moreinfo="none">Table()</literal> need to do a
    bit more work. The most simple form would look like this:</para><programlisting id="I_programlisting2_d1e1550" format="linespecific">Table(:file =&gt; "people.txt")</programlisting><para>In this case, <literal moreinfo="none">args</literal> is a single
    element array containing a <literal moreinfo="none">Hash</literal>.
    However, we know this is not ambiguous, because our third example was also
    of this form:</para><programlisting id="I_programlisting2_d1e1560" format="linespecific">csv = "first_name,last_name\nGregory,Brown\nDeborah,Orlando\n"
table3 = Table(:string =&gt; csv)</programlisting><para>Also, although it has not been shown yet, <literal moreinfo="none">Table()</literal> also provides a compatible interface
    with <literal moreinfo="none">Ruport::Data::Table.new()</literal>. This
    means that the following code is also valid:<indexterm id="I_indexterm2_d1e1570" significance="normal"><primary>Ruport::Data::Table.new( )</primary></indexterm></para><programlisting id="I_programlisting2_d1e1573" format="linespecific">table4 = Table( :column_names =&gt; %w[first_name last_name],
                :data         =&gt; [["Gregory","Brown"],["Deborah","Orlando"]] )</programlisting><para>These three different cases are distinguished fairly easily, as you
    can see here:</para><programlisting id="I_programlisting2_d1e1577" format="linespecific">if file = args[0].delete(:file)
  Ruport::Data::Table.load(file,args[0],&amp;block)
elsif string = args[0].delete(:string)
  Ruport::Data::Table.parse(string,args[0],&amp;block)
else
  Ruport::Data::Table.new(args[0],&amp;block)
end</programlisting><para>This code attempts to be polite by removing the <literal moreinfo="none">:file</literal> or <literal moreinfo="none">:string</literal> option from the <literal moreinfo="none">options</literal> hash before delegating to the relevant
    constructor. This is a good practice when forwarding options hashes
    downstream, so as to avoid providing the underlying methods with options
    that it may not handle properly.<indexterm id="I_indexterm2_d1e1590" significance="normal"><primary>hashes</primary><secondary>option hashes, forwarding</secondary></indexterm><indexterm id="I_indexterm2_d1e1595" significance="normal"><primary>options hashes</primary><secondary>forwarding</secondary></indexterm></para><para>Putting this all together, we find that it is possible to be
    extremely flexible with Ruby interfaces. In fact, the following examples
    show even more advanced behavior that is possible with <literal moreinfo="none">Table()</literal>:</para><programlisting id="I_programlisting2_d1e1605" format="linespecific"># removes records that don't have a first name of Gregory
table = Table("foo.csv") do |t,r|
  t.filter { |r| r.first_name == "Gregory" }
  t &lt;&lt; r
end

# doubles the first column's values
table = Table("a","b","c") do |t|
  t.transform { |r| r["a"] *= 2 }
  t &lt;&lt; [1,2,3]
  t &lt;&lt; [4,5,6]
end</programlisting><para>Both examples build up a table within a block, but there is a key
    difference between the two. The first example is an iterator, walking over
    the rows of a CSV file as they are read in and parsed. The second example
    starts with an empty table and no data source to feed from, and allows
    users to build up a table from whatever sources they wish. The power here
    is that we can allow our blocks to act differently based on the expected
    number of arguments. This is only the tip of the iceberg when it comes to
    the kinds of things you can do with blocks, and in just a little bit,
    we’ll look at some fresh examples to really get a sense of one of Ruby’s
    most powerful API building tools.</para><para>For now, let’s take a step back and look at some kinds of argument
    processing that Ruby can do. The methods that Ruport’s <literal moreinfo="none">Table()</literal> method delegates to are a little too
    domain-specific to show this stuff off usefully, so instead we’ll use a
    few more basic examples to demonstrate the various different kinds of
    interfaces you can provide for methods in Ruby.<indexterm id="I_indexterm2_d1e1615" class="endofrange" startref="ch02_APIdesignconvenience" significance="normal"/><indexterm id="I_indexterm2_d1e1616" class="endofrange" startref="ch02_Table" significance="normal"/><indexterm id="I_indexterm2_d1e1617" class="endofrange" startref="ch02_RuportTable" significance="normal"/></para></sect1><sect1 id="I_sect12_d1e1618"><title>Ruby’s Secret Power: Flexible Argument Processing</title><para>When you think of a method, how do you envision its parameters?
    Depending on whom you ask, you might get a lot of different answers. Some
    folks might think of something vaguely mathematical, such as <literal moreinfo="none">f(x,y,z)</literal>, where each argument is necessary, and
    the order in which they are provided is significant. Others might think of
    methods as <phrase role="keep-together">manipulating</phrase>
    configuration data, where keyword-like parameters seem natural, e.g.,
    <literal moreinfo="none" role="keep-together">create_person( first_name:
    "Joe", last_name: "Frasier")</literal>. You might also contemplate mixing
    the two together, or dreaming up something else entirely.<indexterm class="startofrange" id="ch02_methodsargs" significance="normal"><primary>methods</primary><secondary>flexible argument processing</secondary></indexterm><indexterm class="startofrange" id="ch02_argsprocessflexible" significance="normal"><primary>argument processing, flexible</primary></indexterm><indexterm class="startofrange" id="ch02_APIflexibleargs" significance="normal"><primary>APIs, designing</primary><secondary>flexible argument processing</secondary></indexterm></para><para>Ruby provides a great deal of flexibility in how it handles method
    arguments, which might lead to some confusion. However, this is also a key
    part of building beautiful APIs in Ruby. The following examples give just
    a small taste of the kind of diversity you can expect in Ruby:</para><programlisting id="I_programlisting2_d1e1647" format="linespecific"># Standard ordinal arguments
def distance(x1,y1,x2,y2)
  Math.hypot(x2 - x1, y2 - y1)
end

# Ordinal arguments, with an optional argument
def load_file(name,mode="rb")
  File.open(name,mode)
end

# Pseudo-keyword arguments
def story(options)
  "#{options[:person]} went to town, riding on a #{options[:animal]}"
end

# Treating arguments as an Array
def distance2(*points)
  distance(*points.flatten)
end</programlisting><para>Invoking these methods shows how they look in action:</para><programlisting id="I_programlisting2_d1e1651" format="linespecific">&gt;&gt; distance(3,3,4,5)
=&gt; 2.23606797749979

&gt;&gt; load_file "foo.jpg"
=&gt; #&lt;File:foo.jpg&gt;
&gt;&gt; load_file "foo.jpg", "r"
=&gt; #&lt;File:foo.jpg&gt;
&gt;&gt; load_file "foo.jpg", "kitten"
ArgumentError: illegal access mode kitten ...

&gt;&gt; story(animal: "Tiger", person: "Yankee Doodle")
=&gt; "Yankee Doodle went to town, riding on a Tiger"
&gt;&gt; story(person: "Yankee Doodle", animal: "Tiger")
=&gt; "Yankee Doodle went to town, riding on a Tiger"

&gt;&gt; distance2 [3,3], [4,5]
=&gt; 2.23606797749979</programlisting><para>Each approach shown here has its merits, and how to choose the right
    one depends mainly on what your method needs to do. Let’s look at each of
    these trivial methods one by one to get a sense of their pros and
    cons.</para><sect2><title>Standard Ordinal Arguments</title><programlisting id="I_programlisting2_d1e1658" format="linespecific">def distance(x1,y1,x2,y2)
  Math.hypot(x2 - x1, y2 - y1)
end

&gt;&gt; distance(3,3,4,5)
=&gt; 2.23606797749979</programlisting><para>Ordinal argument processing is the most simple, but also the most
      restrictive way to pass arguments into your methods in Ruby. In this
      case, it may be all we need. All four arguments are necessary to do the
      calculation, and there is a logical way to order them. In situations
      like these, the no-frills approach is frequently good enough.<indexterm id="I_indexterm2_d1e1662" significance="normal"><primary>ordinal arguments</primary><secondary>standard</secondary></indexterm><indexterm id="I_indexterm2_d1e1667" significance="normal"><primary>argument processing, flexible</primary><secondary>standard ordinal arguments</secondary></indexterm></para></sect2><sect2><title>Ordinal Arguments with Optional Parameters</title><programlisting id="I_programlisting2_d1e1675" format="linespecific">def load_file(name,mode="rb")
  File.open(name,mode)
end

&gt;&gt; load_file "foo.jpg"
=&gt; #&lt;File:foo.jpg&gt;
&gt;&gt; load_file "foo.jpg", "r"
=&gt; #&lt;File:foo.jpg&gt;
&gt;&gt; load_file "foo.jpg", "kitten"
ArgumentError: illegal access mode kitten ...</programlisting><para>The ability to set default values makes ordinal arguments a bit
      more pleasant to work with in some cases. The example code provides a
      trivial wrapper on <literal moreinfo="none">File.open()</literal> that
      causes it to default to reading a binary file. For this default use, the
      method appears to accept a single argument, keeping the call clean and
      straightforward. However, a second argument can be provided if needed,
      due to this more flexible way of defining the interface.<indexterm id="I_indexterm2_d1e1682" significance="normal"><primary>argument processing, flexible</primary><secondary>ordinal arguments with optional parameters</secondary></indexterm><indexterm id="I_indexterm2_d1e1687" significance="normal"><primary>ordinal arguments</primary><secondary sortas="optional">with optional parameters</secondary></indexterm></para><para>However, what happens when we have more than one optional
      argument, such as in the following example code?</para><programlisting id="I_programlisting2_d1e1694" format="linespecific">def load_file2(name="foo.jpg",mode="rb")
  File.open(name,mode)
end</programlisting><para>For the obvious cases, this works as we might expect:</para><programlisting id="I_programlisting2_d1e1698" format="linespecific">&gt;&gt; load_file2
=&gt; #&lt;File:foo.jpg&gt;

&gt;&gt; load_file2 "bar.jpg"
=&gt; #&lt;File:bar.jpg&gt;

&gt;&gt; load_file2 "bar.jpg", "r"
=&gt; #&lt;File:bar.jpg&gt;

&gt;&gt; load_file2 "bar.jpg", "kitten"
ArgumentError: invalid access mode kitten ...</programlisting><para>However, the trouble arises when we want to use the default value
      for the first argument and override the second one. Sadly enough, we
      simply cannot do it using this approach. We’d need to supply both
      values, like this:</para><programlisting id="I_programlisting2_d1e1702" format="linespecific">&gt;&gt; load_file2 "foo.jpg", "r"
=&gt; #&lt;File:foo.jpg&gt;</programlisting><para>For this reason, it’s relatively rare to find a good use for
      multiple optional parameters in the ordinal format. When you do find
      yourself needing this sort of thing, there are most likely better
      options available, anyway.<indexterm id="I_indexterm2_d1e1706" significance="normal"><primary>pseudo-keyword arguments</primary></indexterm><indexterm id="I_indexterm2_d1e1709" significance="normal"><primary>argument processing, flexible</primary><secondary>pseudo-keyword arguments</secondary></indexterm></para></sect2><sect2><title>Pseudo-Keyword Arguments</title><programlisting id="I_programlisting2_d1e1717" format="linespecific">def story(options)
  "#{options[:person]} went to town, riding on a #{options[:animal]}"
end

&gt;&gt; story(animal: "Tiger", person: "Yankee Doodle")
=&gt; "Yankee Doodle went to town, riding on a Tiger"
&gt;&gt; story(person: "Yankee Doodle", animal: "Tiger")
=&gt; "Yankee Doodle went to town, riding on a Tiger"</programlisting><para>Although Ruby doesn’t have support for real keyword arguments, it
      does a pretty good job of imitating them. If we peek behind the curtain
      though, we find that we’re really dealing with something much more
      basic:<indexterm id="I_indexterm2_d1e1721" significance="normal"><primary>keyword arguments, Ruby and</primary></indexterm></para><programlisting id="I_programlisting2_d1e1724" format="linespecific">&gt;&gt; argument_hash = { :animal =&gt; "Tiger", :person =&gt; "Yankee Doodle" }
&gt;&gt; story(argument_hash)
=&gt; "Yankee Doodle went to town, riding on a Tiger"</programlisting><para>Seen in this form, all the magic disappears. The method is really
      only processing a single argument in the form of a basic <literal moreinfo="none">Hash</literal> of key/value pairs.<indexterm id="I_indexterm2_d1e1731" significance="normal"><primary>hashes</primary><secondary>pseudo-keyword arguments</secondary></indexterm></para><para>Utilizing some syntactic sugar, we can rearrange things a
      bit:</para><programlisting id="I_programlisting2_d1e1738" format="linespecific">&gt;&gt; argument_hash = { animal: "Tiger", person: "Yankee Doodle" }
&gt;&gt; story(argument_hash)
=&gt; "Yankee Doodle went to town, riding on a Tiger"</programlisting><para>If our hash happens to be the last (or the only) argument to the
      method, we can leave off the brackets when passing a <literal moreinfo="none">Hash</literal> literal. This gets us full circle back to
      the original:</para><programlisting id="I_programlisting2_d1e1745" format="linespecific">&gt;&gt; story(animal: "Tiger", person: "Yankee Doodle")
=&gt; "Yankee Doodle went to town, riding on a Tiger"</programlisting><para>With a basic understanding of the underlying mechanics, you can
      begin to see the benefits of this style of API. Perhaps the most
      significant is that the order in which you specify the arguments doesn’t
      matter at all, as you’ve seen in the example code. If we combine that
      feature with a basic idiom for setting default values passed in the
      hash, we come up with something pretty interesting:</para><programlisting id="I_programlisting2_d1e1749" format="linespecific">def story2(options={})
  options = { person: "Yankee Doodle", animal: "Tiger" }.merge(options)
  "#{options[:person]} went to town, riding on a #{options[:animal]}"
end

&gt;&gt; story2
=&gt; "Yankee Doodle went to town, riding on a Tiger"
&gt;&gt; story2(person: "Joe Frasier")
=&gt; "Joe Frasier went to town, riding on a Tiger"
&gt;&gt; story2(animal: "Kitteh")
=&gt; "Yankee Doodle went to town, riding on a Kitteh"
&gt;&gt; story2(animal: "Kitteh", person: "Joe Frasier")
=&gt; "Joe Frasier went to town, riding on a Kitteh"</programlisting><para>As you can see here, it is possible to handle multiple default
      values fairly elegantly. This avoids the problems we encountered when
      attempting to do something similar via simple default values for ordinal
      arguments. Though this example is a bit contrived, it’s worth mentioning
      that if one or more of your arguments are really mandatory, it’s worth
      it to break them out, like so:<indexterm id="I_indexterm2_d1e1754" significance="normal"><primary>options hashes</primary><secondary>mandatory arguments and</secondary></indexterm></para><programlisting id="I_programlisting2_d1e1759" format="linespecific">def write_story_to_file(file,options={})
  File.open(file,"w") { |f| f &lt;&lt; story2(options) }
end</programlisting><para>which enables fun stuff like:</para><programlisting id="I_programlisting2_d1e1763" format="linespecific">&gt;&gt; write_story_to_file "output.txt"
&gt;&gt; write_story_to_file "output.txt", animal: "Kitteh"
&gt;&gt; write_story_to_file "output.txt", person: "Joe Frasier"
&gt;&gt; write_story_to_file "output.txt", animal: "Slug", person: "Joe Frasier"</programlisting><para>Though you could write code to ensure that certain options are
      present in a hash, generally it is most natural to just let Ruby do the
      hard work for you by placing your mandatory arguments before your
      options hash in your method definition.<indexterm class="startofrange" id="ch02_arraysargument" significance="normal"><primary>arrays</primary><secondary>treating arguments as</secondary></indexterm><indexterm class="startofrange" id="ch02_argumentsarray" significance="normal"><primary>argument processing, flexible</primary><secondary>treating arguments as an array</secondary></indexterm></para></sect2><sect2><title>Treating Arguments As an Array</title><programlisting id="I_programlisting2_d1e1780" format="linespecific">def distance2(*points)
  distance(*points.flatten)
end

&gt;&gt; distance2 [3,3], [4,5]
=&gt; 2.23606797749979</programlisting><para>A powerful feature involves treating the passed arguments as an
      array. In the case of a distance method, we might want to provide the
      arguments in one of several different ways, depending on our situation.
      The previous example shows the primary use of this approach, which is to
      allow the data to be passed as two points. However, if you play around,
      you’ll find that a lot of other possibilities exist, some more sane than
      others. Here are a few to give you a sense of what’s going on
      here:</para><programlisting id="I_programlisting2_d1e1784" format="linespecific">&gt;&gt; distance2 [3],[3],[4],[5]
=&gt; 2.23606797749979
&gt;&gt; distance2 3,3,4,5
=&gt; 2.23606797749979
&gt;&gt; distance2 [3,3,4],5
=&gt; 2.23606797749979</programlisting><para>It should be clear at this point that Ruby is treating the
      arguments as one big array, flattening it down to eliminate any nesting,
      and then passing the four values as arguments to the original <literal moreinfo="none">distance()</literal> method. With this in mind, the
      following issues shouldn’t be too surprising:</para><programlisting id="I_programlisting2_d1e1791" format="linespecific">&gt;&gt; distance2 [3,3,4]
ArgumentError: wrong number of arguments (3 for 4) ...

&gt;&gt; distance2 [3,3,4],5,6
ArgumentError: wrong number of arguments (5 for 4) ...</programlisting><para>Still, our error messages are a bit obscure, and the fact that
      we’re wrapping another method might make things seem a bit tricky.
      Considering this issue, we can try to make something a little more solid
      using the same general approach:</para><programlisting id="I_programlisting2_d1e1795" format="linespecific">def distance3(*points)
  case(points.length)
  when 2
    x1,y1,x2,y2 = points.flatten
  when 4
    x1,y1,x2,y2 = points
  else
     raise ArgumentError,
        "Points may be specified as [x1,y1], [x2,y2] or x1,y1,x2,y2"
  end
  Math.hypot(x2 - x1, y2 - y1)
end</programlisting><para>In this case, our method behaves much more strictly:</para><programlisting id="I_programlisting2_d1e1799" format="linespecific">&gt;&gt; distance3 [3,3,4]
ArgumentError: Points may be specified as [x1,y1], [x2,y2] or x1,y1,x2,y2 ...

&gt;&gt; distance3 3,3,3,4,5
ArgumentError: Points may be specified as [x1,y1], [x2,y2] or x1,y1,x2,y2 ...

&gt;&gt; distance3 [3,3,3,4]
ArgumentError: Points may be specified as [x1,y1], [x2,y2] or x1,y1,x2,y2 ...

&gt;&gt; distance3 [3,3],[3,4]
=&gt; 1.0

&gt;&gt; distance3 3,3,3,4
=&gt; 1.0</programlisting><para>Though this may be a more robust way to write the method, it is
      more complicated. Playing fast and loose might not be a bad thing if you
      can expect your users to provide sane input. The following version is
      the compromise I might use in production code:</para><programlisting id="I_programlisting2_d1e1804" format="linespecific">def distance4(*points)
  x1,y1,x2,y2 = points.flatten
  raise ArgumentError unless [x1,y1,x2,y2].all? { |e| Numeric === e }
  Math.hypot(x2 - x1, y2 - y1)
end</programlisting><para>This code checks the first four arguments after flattening any
      nesting to make sure that they are <literal moreinfo="none">Numeric</literal> values, and then assigns them to the
      variables <literal moreinfo="none">x1</literal>, <literal moreinfo="none">y1</literal>, <literal moreinfo="none">x2</literal>, and
      <literal moreinfo="none">y2</literal>. Though it does not cover all edge
      cases, it does some sanity checks and makes sure that you’ve provided
      all the necessary data in a form that is usable by the method. In many
      cases, this will be good enough.</para><para>Although we’ve covered only some of the most basic argument forms
      here, these techniques form the basis for building solid Ruby APIs. The
      following short list of guidelines will help you in designing your
      methods:<indexterm id="I_indexterm2_d1e1825" significance="normal"><primary>APIs, designing</primary><secondary>guidelines for design of methods</secondary></indexterm></para><itemizedlist><listitem><para>Try to keep the number of ordinal arguments in your methods to
          a minimum.</para></listitem><listitem><para>If your method has multiple parameters with default values,
          consider using pseudo-keyword arguments via an options hash.</para></listitem><listitem><para>Use the array splat operator (<literal moreinfo="none">*</literal>) when you want to slurp up your
          arguments and pass them to another method.</para></listitem><listitem><para>The <literal moreinfo="none">*args</literal> idiom is also
          useful for supporting multiple simultaneous argument processing
          styles, as in <literal moreinfo="none">Table()</literal>, but can
          lead to complicated code.<indexterm id="I_indexterm2_d1e1852" significance="normal"><primary>*args idiom</primary></indexterm></para></listitem><listitem><para>Don’t use <literal moreinfo="none">*args</literal> when a
          normal combination of mandatory ordinal arguments and an options
          hash will do.</para></listitem><listitem><para>If some parameters are mandatory, avoid putting them in an
          options hash, and instead write a signature like <literal moreinfo="none">foo(mandatory1, mandatory2, options={})</literal>,
          <phrase role="keep-together">unless</phrase> there is a good reason
          not to.</para></listitem></itemizedlist><para>Although having a decent understanding of how argument processing
      works in Ruby will take you far, there are many situations that need a
      little more firepower. Ruby’s ability to utilize code blocks in
      association with method calls is often the answer. We’ll now dive into
      the various ways that working with blocks can simplify your interface as
      well as the internals of your methods.<indexterm id="I_indexterm2_d1e1872" class="endofrange" startref="ch02_methodsargs" significance="normal"/><indexterm id="I_indexterm2_d1e1873" class="endofrange" startref="ch02_argumentsarray" significance="normal"/><indexterm id="I_indexterm2_d1e1874" class="endofrange" startref="ch02_arraysargument" significance="normal"/><indexterm id="I_indexterm2_d1e1875" class="endofrange" startref="ch02_APIflexibleargs" significance="normal"/><indexterm id="I_indexterm2_d1e1876" class="endofrange" startref="ch02_argsprocessflexible" significance="normal"/></para></sect2></sect1><sect1 id="I_sect12_d1e1877"><title>Ruby’s Other Secret Power: Code Blocks</title><para>In Ruby, code blocks are everywhere. If you’ve ever used <literal moreinfo="none">Enumerable</literal>, you’ve worked with blocks. But what
    are they? Are they simply iterators, working to abstract away our need for
    the <literal moreinfo="none">for</literal> loop? They certainly do a good job of
    that:<indexterm id="I_indexterm2_d1e1888" significance="normal"><primary>iterators</primary><secondary>blocks as</secondary></indexterm><indexterm class="startofrange" id="ch02_APIscodeblocks" significance="normal"><primary>APIs, designing</primary><secondary>using code blocks</secondary></indexterm><indexterm class="startofrange" id="ch02_codeblocks" significance="normal"><primary>code blocks</primary></indexterm></para><programlisting id="I_programlisting2_d1e1901" format="linespecific">&gt;&gt; ["Blocks","are","really","neat"].map { |e| e.upcase }
=&gt; ["BLOCKS", "ARE", "REALLY", "NEAT"]</programlisting><para>But other blocks don’t really iterate over things—they just do
    helpful things for us. For example, they allow us to write something
    like:</para><programlisting id="I_programlisting2_d1e1905" format="linespecific">File.open("foo.txt","w") { |f| f &lt;&lt; "This is sexy" }</programlisting><para>instead of forcing us to write this:</para><programlisting id="I_programlisting2_d1e1909" format="linespecific">file = File.open("foo.txt","w")
file &lt;&lt; "This is tedious"
file.close</programlisting><para>So blocks are useful for iteration, and also useful for injecting
    some code between preprocessing and postprocessing operations in methods.
    But is that all they’re good for? Sticking with Ruby built-ins, we find
    that isn’t the case. Blocks can also shift our scope temporarily, giving
    us easier access to places we want to be:</para><programlisting id="I_programlisting2_d1e1913" format="linespecific">"This is a string".instance_eval do
   "O hai, can has reverse? #{reverse}. kthxbye"
 end

 #=&gt; "O hai, can has reverse? gnirts a si sihT. kthxbye"</programlisting><para>But blocks aren’t necessarily limited to code that gets run right
    away and then disappears. They can also form templates for what to do down
    the line, springing to action when ready:<indexterm id="I_indexterm2_d1e1917" significance="normal"><primary>templates, code blocks as</primary></indexterm></para><programlisting id="I_programlisting2_d1e1920" format="linespecific">&gt;&gt; foo = Hash.new { |h,k| h[k] = [] }
=&gt; {}
&gt;&gt; foo[:bar]
=&gt; []
&gt;&gt; foo[:bar] &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 3
=&gt; [1, 2, 3]
&gt;&gt; foo[:baz]
=&gt; []</programlisting><para>So even if we label all methods that accept a block as iterators, we
    know the story runs deeper than that. With this in mind, we can leverage
    some basic techniques to utilize any of the approaches shown here, as well
    as some more advanced tricks. By doing things in a way that is consistent
    with Ruby itself, we can make life easier for our users. Rather than
    piling on new concepts, we can allow them to reuse their previous
    knowledge. Let’s take a look at a few examples of how to do that
    now.<indexterm id="I_indexterm2_d1e1925" significance="normal"><primary>Enumerable module</primary></indexterm><indexterm id="I_indexterm2_d1e1928" significance="normal"><primary>code blocks</primary><secondary>working with Enumerable</secondary></indexterm></para><sect2><title>Working with Enumerable</title><para>The most common use of blocks in Ruby might be the most trivial.
      The following class implements a basic sorted list, and then mixes in
      the <literal moreinfo="none">Enumerable</literal> module. The block
      magic happens in <literal moreinfo="none">each()</literal>:</para><programlisting id="I_programlisting2_d1e1944" format="linespecific">class SortedList

  include Enumerable
<?dbfo-need height="1in"
?>
  def initialize
    @data = []
  end

  def &lt;&lt;(element)
    (@data &lt;&lt; element).sort!
  end

  def each
    @data.each { |e| yield(e) }
  end

end</programlisting><para>Our <literal moreinfo="none">each()</literal> method simply walks
      over each element in our <literal moreinfo="none">@data</literal> array
      and passes it through the block provided to the method by calling
      <literal moreinfo="none">yield</literal>. The resulting iterator works
      exactly the same as <literal moreinfo="none">Array#each</literal> and
      <literal moreinfo="none">Hash#each</literal> and all the Ruby built-ins,
      and indeed simply wraps <literal moreinfo="none">Array#each</literal> in
      this case:<indexterm id="I_indexterm2_d1e1969" significance="normal"><primary>iterators</primary><secondary>building custom</secondary></indexterm><indexterm id="I_indexterm2_d1e1974" significance="normal"><primary>Hash#each method</primary></indexterm><indexterm id="I_indexterm2_d1e1977" significance="normal"><primary>Array#each method</primary></indexterm></para><programlisting id="I_programlisting2_d1e1980" format="linespecific">&gt;&gt; a = SortedList.new
=&gt; #&lt;SortedList:0x5f0e74 @data=[]&gt;
&gt;&gt; a &lt;&lt; 4
=&gt; [4]
&gt;&gt; a &lt;&lt; 5
=&gt; [4, 5]
&gt;&gt; a &lt;&lt; 1
=&gt; [1, 4, 5]
&gt;&gt; a &lt;&lt; 7
=&gt; [1, 4, 5, 7]
&gt;&gt; a &lt;&lt; 3
=&gt; [1, 3, 4, 5, 7]

&gt;&gt; x = 0
=&gt; 0
&gt;&gt; a.each { |e| x += e }
=&gt; [1, 3, 4, 5, 7]
&gt;&gt; x
=&gt; 20</programlisting><para>This shouldn’t be surprising. What is really the interesting bit
      is that by including the module <literal moreinfo="none">Enumerable</literal>, we gain
      access to most of the other features we’re used to working with when
      processing Ruby’s built-in collections. Here are just a few
      examples:</para><programlisting id="I_programlisting2_d1e1987" format="linespecific">&gt;&gt; a.map { |e| "Element #{e}" }
=&gt; ["Element 1", "Element 3", "Element 4", "Element 5", "Element 7"]
&gt;&gt; a.inject(0) { |s,e| s + e }
=&gt; 20
&gt;&gt; a.to_a
=&gt; [1, 3, 4, 5, 7]
&gt;&gt; a.select { |e| e &gt; 3 }
=&gt; [4, 5, 7]</programlisting><para>In a lot of cases, the features provided by <literal moreinfo="none">Enumerable</literal> will be more than enough for
      traversing your data. However, it’s often useful to add other features
      that build on top of the <literal moreinfo="none">Enumerable</literal>
      methods. We can show this by adding a simple <phrase role="keep-together">reporting</phrase> <phrase role="keep-together">method</phrase> to <literal moreinfo="none">SortedList</literal>:<indexterm id="I_indexterm2_d1e2007" significance="normal"><primary>SortedList, adding reporting method to</primary></indexterm></para><programlisting id="I_programlisting2_d1e2010" format="linespecific">class SortedList
  def report(head)
    header = "#{head}\n#{'-'*head.length}"
    body = map{|e| yield(e)}.join("\n") + "\n"
    footer = "This report was generated at #{Time.now}\n"

    [header, body, footer].join("\n")
  end
end</programlisting><para>which, when run, produces output like this:</para><programlisting id="I_programlisting2_d1e2014" format="linespecific">&gt;&gt; puts a.report("So many fish") { |e| "#{e} fish" }
So many fish
------------
1 fish
3 fish
4 fish
5 fish
7 fish

This report was generated at 2008-07-22 22:47:20 -0400</programlisting><para>Building custom iterators is really that simple. This provides a
      great deal of flexibility, given that the code block can execute
      arbitrary expressions and do manipulations of its own as it walks across
      the elements. But as mentioned before, blocks can be used for more than
      just iteration.</para></sect2><sect2><title>Using Blocks to Abstract Pre- and Postprocessing</title><para>We looked at the block form of <literal moreinfo="none">File.open()</literal> as an example of how blocks can
      provide an elegant way to avoid repeating tedious setup and teardown
      steps. However, files are surely not the only resources that need to be
      properly managed. Network I/O via sockets is another place where this
      technique can come in handy.<indexterm class="startofrange" id="ch02_prepostprocessing" significance="normal"><primary>pre/postprocessing, using blocks to abstract</primary></indexterm><indexterm class="startofrange" id="ch02_methodscodeblocks" significance="normal"><primary>methods</primary><secondary>using code blocks to abstract pre- and
          postprocessing</secondary></indexterm><indexterm class="startofrange" id="ch02_socketsIO" significance="normal"><primary>sockets, network I/O via</primary></indexterm><indexterm class="startofrange" id="ch02_IOsockets" significance="normal"><primary>input and output</primary><secondary>network I/O via sockets</secondary></indexterm><indexterm class="startofrange" id="ch02_codeblocksprepostprocess" significance="normal"><primary>code blocks</primary><secondary>using to abstract pre- and postprocessing</secondary></indexterm></para><para>On the client side, we’d like to be able to create a method that
      allows us to send a message to a server, return its response, then
      cleanly close the connection. The first thing that comes to mind is
      something simple like this:</para><programlisting id="I_programlisting2_d1e2050" format="linespecific">require "socket"

class Client

  def initialize(ip="127.0.0.1",port=3333)
    @ip, @port = ip, port
  end

  def send_message(msg)
    socket = TCPSocket.new(@ip,@port)
    socket.puts(msg)
    response = socket.gets
  ensure
    socket.close
  end

end</programlisting><para>This is reasonably straightforward, but what happens when we want
      to add another method that waits to receive a message back from the
      server?</para><programlisting id="I_programlisting2_d1e2054" format="linespecific">require "socket"

class Client

  def initialize(ip="127.0.0.1",port=3333)
    @ip, @port = ip, port
  end

  def send_message(msg)
    socket = TCPSocket.new(@ip,@port)
    socket.puts(msg)
    response = socket.gets
  ensure
    socket.close
  end

  def receive_message
    socket = TCPSocket.new(@ip,@port)
    response = socket.gets
  ensure
    socket.close
  end

end</programlisting><para>This is starting to look messy, as we have repeated most of the
      code between <literal moreinfo="none" role="keep-together">send_message</literal> and <literal moreinfo="none">receive_message</literal>. Ordinarily, we’d break off
      the shared code into a private method that the two could share, but the
      trouble here is that the difference between these two methods is in the
      middle, not in a single extractable chunk. This is where blocks come to
      the rescue:</para><programlisting id="I_programlisting2_d1e2064" format="linespecific">require "socket"

class Client
  def initialize(ip="127.0.0.1",port=3333)
    @ip, @port = ip, port
  end

  def send_message(msg)
    connection do |socket|
      socket.puts(msg)
      socket.gets
    end
  end

  def receive_message
    connection { |socket| socket.gets }
  end

  private

  def connection
    socket = TCPSocket.new(@ip,@port)
    yield(socket)
  ensure
    socket.close
  end

end</programlisting><para>As you can see, the resulting code is a lot cleaner. As long as we
      use our <literal moreinfo="none">connection()</literal> method with a
      block, we won’t need to worry about opening and closing the <phrase role="keep-together"><literal moreinfo="none">TCPSocket</literal>—</phrase>it’ll handle that for us.
      This means we’ve captured that logic in one place, and can reuse it
      however we’d like.<indexterm id="I_indexterm2_d1e2076" class="endofrange" startref="ch02_prepostprocessing" significance="normal"/><indexterm id="I_indexterm2_d1e2077" class="endofrange" startref="ch02_methodscodeblocks" significance="normal"/><indexterm id="I_indexterm2_d1e2078" class="endofrange" startref="ch02_IOsockets" significance="normal"/><indexterm id="I_indexterm2_d1e2079" class="endofrange" startref="ch02_socketsIO" significance="normal"/><indexterm id="I_indexterm2_d1e2080" class="endofrange" startref="ch02_codeblocksprepostprocess" significance="normal"/></para><para>To make things a bit more interesting, let’s take a look at a
      simple server with which this code can interact, which gives us a chance
      to look at yet another way that blocks can be useful in interface
      design.</para></sect2><sect2><title>Blocks As Dynamic Callbacks</title><para>There is a lot of power in being able to pass around code blocks
      just like they were any other object. This allows for the capability of
      creating and storing dynamic callbacks, which can later be looked up and
      executed as needed.<indexterm class="startofrange" id="ch02_callbacksblocks" significance="normal"><primary>callbacks</primary><secondary>blocks as dynamic callbacks</secondary></indexterm><indexterm class="startofrange" id="ch02_codeblockscallback" significance="normal"><primary>code blocks</primary><secondary>as dynamic callbacks</secondary></indexterm></para><para>In order to play with our <literal moreinfo="none">Client</literal> code from the previous example, we’re
      going to create a trivial <literal moreinfo="none">TCPServer</literal>
      that attempts to match incoming messages against patterns to determine
      how it should respond. Rather than hardcoding behaviors into the server
      itself or relying on inheritance to handle responses, we will instead
      allow responses to be defined through ordinary method calls accompanied
      by a block. Our goal is to get an interface that looks like this:</para><programlisting id="I_programlisting2_d1e2106" format="linespecific">server = Server.new

server.handle(/hello/i) { "Hello from server at #{Time.now}" }
server.handle(/goodbye/i) { "Goodbye from server at #{Time.now}" }
server.handle(/name is (\w+)/) { |m| "Nice to meet you #{m[1]}!" }

server.run</programlisting><para>The first two examples are fairly simple, matching a single word
      and then responding with a generic message and timestamp. The third
      example is a bit more interesting, repeating the client’s name back in
      the response message. This will be accomplished by querying a simple
      <literal moreinfo="none">MatchData</literal> object, which is yielded to
      the block.</para><para>Though making this work might seem like black magic to the
      uninitiated, a look at its implementation reveals that it is actually a
      fairly pedestrian task:</para><programlisting id="I_programlisting2_d1e2115" format="linespecific">class Server

  def initialize(port=3333)
    @server   = TCPServer.new('127.0.0.1',port)
    @handlers = {}
  end

  def handle(pattern, &amp;block)
    @handlers[pattern] = block
  end

  def run
    while session = @server.accept
      msg = session.gets
      match = nil

      @handlers.each do |pattern,block|
        if match = msg.match(pattern)
          break session.puts(block.call(match))
        end
      end

      unless match
        session.puts "Server received unknown message: #{msg}"
      end
    end
  end

end</programlisting><para>The <literal moreinfo="none">handle()</literal> method slurps up
      the provided block using the <literal moreinfo="none">&amp;block</literal> syntax, and stores it in a hash
      keyed by the given pattern. When <literal moreinfo="none">Server#run</literal> is called, an endless loop is
      started that waits for and handles client connections. Each time a
      message is received, the hash of handlers is iterated over. If a pattern
      is found that matches the message, the associated block is called,
      providing the match data object so that the callback can respond
      accordingly.<indexterm id="I_indexterm2_d1e2128" significance="normal"><primary>&amp;block syntax</primary></indexterm></para><para>If you’d like to try this out, use the following code to spin up a
      server:</para><programlisting id="I_programlisting2_d1e2133" format="linespecific">server = Server.new

server.handle(/hello/i) { "Hello from server at #{Time.now}" }
server.handle(/goodbye/i) { "Goodbye from server at #{Time.now}" }
server.handle(/name is (\w+)/) { |m| "Nice to meet you #{m[1]}!" }

server.run</programlisting><para>Once you have that running and listening for connections, execute
      the following client code:</para><programlisting id="I_programlisting2_d1e2138" format="linespecific">client = Client.new

["Hello", "My name is Greg", "Goodbye"].each do |msg|
  response = client.send_message(msg)
  puts response
end</programlisting><para>You will get back something like this:</para><programlisting id="I_programlisting2_d1e2142" format="linespecific">Hello from server at Wed Jul 23 16:15:37 -0400 2008
Nice to meet you Greg!
Goodbye from server at Wed Jul 23 16:15:37 -0400 2008</programlisting><para>It would be easy to extend both the client and server to do more
      interesting things that build on this very simple foundation. Feel free
      to take a few minutes to play around with that,<footnote><para>Of course, you might want to look at
          <literal moreinfo="none">GServer</literal> in the standard library for a real
          generic server implementation.</para></footnote> and then we’ll look at one more block trick that’s fairly
      common in Ruby.<indexterm id="I_indexterm2_d1e2153" class="endofrange" startref="ch02_codeblockscallback" significance="normal"/><indexterm id="I_indexterm2_d1e2154" class="endofrange" startref="ch02_callbacksblocks" significance="normal"/></para></sect2><sect2><title>Blocks for Interface Simplification</title><para>Does it feel like the word “server” is written too many times in
      this code?<indexterm id="I_indexterm2_d1e2160" significance="normal"><primary>code blocks</primary><secondary>using for interface simplification</secondary></indexterm></para><programlisting id="I_programlisting2_d1e2165" format="linespecific">server = Server.new

server.handle(/hello/i) { "Hello from server at #{Time.now}" }
server.handle(/goodbye/i) { "Goodbye from server at #{Time.now}" }
server.handle(/name is (\w+)/) { |m| "Nice to meet you #{m[1]}!" }

server.run</programlisting><para>When you see code like this, it might be a sign that you could do
      better. Although there are merits to this somewhat standard approach, we
      can cheat a little bit with blocks (of course) and make things prettier.
      It would be nice to be able to write this instead:</para><programlisting id="I_programlisting2_d1e2169" format="linespecific">Server.run do
  handle(/hello/i) { "Hello from server at #{Time.now}" }
  handle(/goodbye/i) { "Goodbye from server at #{Time.now}" }
  handle(/name is (\w+)/) { |m| "Nice to meet you #{m[1]}!" }
end</programlisting><para>As you may recall from an earlier example, it is possible to
      execute a block within the scope of an instantiated object in Ruby.
      Using this knowledge, we can implement this handy shortcut interface as
      a simple class method:<indexterm id="I_indexterm2_d1e2173" significance="normal"><primary>instance_eval( ) method</primary><secondary>using with &amp;block syntax</secondary></indexterm><indexterm id="I_indexterm2_d1e2178" significance="normal"><primary>&amp;block syntax</primary><secondary>using with instance_eval( )</secondary></indexterm></para><programlisting id="I_programlisting2_d1e2183" format="linespecific">class Server

  # other methods same as before

  def self.run(port=3333,&amp;block)
    server = Server.new(port)
    server.instance_eval(&amp;block)
    server.run
  end

end</programlisting><para>This is all you need to get the new interface running, and rounds
      off our quick exploration of the different ways that you can use blocks
      to improve your API design while simplifying your method
      implementations.<indexterm id="I_indexterm2_d1e2187" significance="normal"><primary>code blocks</primary><secondary>guidelines for using in API design</secondary></indexterm></para><para>Keep the following things in mind when using blocks as part of
      your interface:</para><itemizedlist><listitem><para>If you create a collection class that you need to traverse,
          build on top of <literal role="keep-together" moreinfo="none">Enumerable</literal>
          rather than reinventing the wheel.</para></listitem><listitem><para>If you have shared code that differs only in the middle,
          create a helper method that yields a block in between the
          pre/postprocessing code to avoid duplication of effort.</para></listitem><listitem><para>If you use the <literal moreinfo="none">&amp;block</literal>
          syntax, you can capture the code block provided to a method inside a
          variable. You can then store this and use it later, which is very
          useful for creating dynamic callbacks.</para></listitem><listitem><para>Using a combination of <literal moreinfo="none">&amp;block</literal> and <literal moreinfo="none">instance_eval</literal>, you can execute blocks
          within the context of arbitrary objects, which opens up a lot of
          doors for highly customized interfaces.</para></listitem><listitem><para>The return value of <literal moreinfo="none">yield</literal>
          (and <literal moreinfo="none">block.call</literal>) is the same as
          the return value of the provided block.</para></listitem></itemizedlist><para>Between clever use of code blocks and powerful argument
      processing, Ruby makes designing beautiful interfaces a joy. However, it
      takes a little more than this to really complete the picture. Before we
      wrap things up, let’s take a quick look at some common conventions for
      naming your methods as well as what to do when things go
      wrong.<indexterm id="I_indexterm2_d1e2230" class="endofrange" startref="ch02_codeblocks" significance="normal"/><indexterm id="I_indexterm2_d1e2231" class="endofrange" startref="ch02_APIscodeblocks" significance="normal"/></para></sect2></sect1><sect1 id="I_sect12_d1e2232"><title>Avoiding Surprises</title><para>Though Ruby is a language that embraces the TIMTOWTDI<indexterm class="startofrange" id="ch02_APIssurprises" significance="normal"><primary>APIs, designing</primary><secondary>avoiding surprises</secondary></indexterm><footnote><para>“There Is More Than One Way To Do It.”</para></footnote> concept, it is also one that seeks the “Ruby Way” of doing
    things. In this section are a number of miscellaneous tips to help you
    move your API in that direction.</para><sect2><title>Use attr_reader, attr_writer, and attr_accessor</title><para>In Ruby, there is no direct external access to the internal state
      of objects. This means that it is necessary for you to provide public
      accessors for your internal objects.<indexterm class="startofrange" id="ch02_attr" significance="normal"><primary>attr_reader, attr_writer, and attr_accessor</primary></indexterm><indexterm class="startofrange" id="ch02_APIsaccessors" significance="normal"><primary>APIs, designing</primary><secondary>avoiding surprises</secondary><tertiary>using attr_reader, attr_writer, and
          attr_accessor</tertiary></indexterm></para><para>Technically, the following code does that just fine:</para><programlisting id="I_programlisting2_d1e2263" format="linespecific">class Message

  def initialize(m)
    @message = m
  end
<?dbfo-need height="1in"
?>
  def get_message
    @message
  end

  def set_message(m)
    @message = m
  end

end

&gt;&gt; m = Message.new('foo')
=&gt; #&lt;Message:0x603bf0 @message="foo"&gt;
&gt;&gt; m.get_message
=&gt; "foo"
&gt;&gt; m.set_message('bar')
=&gt; "bar"
&gt;&gt; m.get_message
=&gt; "bar"</programlisting><para>However, this approach is almost never seen in code written by
      practicing Rubyists. Instead, you’ll see the preceding code example
      implemented like this:</para><programlisting id="I_programlisting2_d1e2269" format="linespecific">class Message

  attr_accessor :message

  def initialize(m)
    @message = m
  end

end

&gt;&gt; m = Message.new('foo')
=&gt; #&lt;Message:0x5f3c50 @message="foo"&gt;
&gt;&gt; m.message
=&gt; "foo"
&gt;&gt; m.message = "bar"
=&gt; "bar"
&gt;&gt; m.message
=&gt; "bar"</programlisting><para>Aside from requiring less typing overall, this code is very clear
      and expressive, because it doesn’t include the unnecessary
      <literal moreinfo="none">get</literal> and <literal moreinfo="none">set</literal> verbs. However, you
      might wonder how to do data verification/protection with this
      approach.</para><para>If you need to add some special logic on write, you can still use
      <literal moreinfo="none">attr_reader</literal> to provide the reading
      side of things and then use a custom method to handle the
      writing:</para><programlisting id="I_programlisting2_d1e2284" format="linespecific">class Message
  attr_reader :message

  def message=(m)
    @message = m.dup
  end
end</programlisting><para>On the other hand, if you need to do some handling on read but can
      afford to use the default writer, <literal moreinfo="none">attr_writer</literal> is what you want:</para><programlisting id="I_programlisting2_d1e2291" format="linespecific">class Message
  attr_writer :message

  def message
    @message.encode!("UTF-8")
  end
end</programlisting><para>Of course, if you need both custom readers and writers, there is
      no need for the <literal moreinfo="none">attr_*</literal> helpers.
      However, in this case, remember that unless there is a good reason to
      name things otherwise, use the methods <literal moreinfo="none">something()</literal> and <literal moreinfo="none">something=()</literal> instead of <literal moreinfo="none" role="keep-together">get_something()</literal> and
      <literal moreinfo="none">set_something()</literal>.<indexterm id="I_indexterm2_d1e2312" significance="normal"><primary>something( ) and something=( ) methods</primary></indexterm><indexterm id="I_indexterm2_d1e2315" class="endofrange" startref="ch02_APIsaccessors" significance="normal"/><indexterm id="I_indexterm2_d1e2316" class="endofrange" startref="ch02_attr" significance="normal"/></para></sect2><sect2><title>Understand What method? and method! Mean</title><para>In Ruby, question marks and exclamation points are allowed at the
      end of method names. Although there is no doubt that Matz wants us to be
      able to express ourselves freely, these special characters have
      conventional baggage that comes along with them, and it is useful to
      honor these conventions when developing your own interfaces.<indexterm class="startofrange" id="ch02_methodsquestionexclaim" significance="normal"><primary>methods</primary><secondary>question mark (?) and exclamation point (!) at end of
          names</secondary></indexterm><indexterm class="startofrange" id="ch02_APIsquestionexclaim" significance="normal"><primary>APIs, designing</primary><secondary>avoiding surprises</secondary><tertiary>method? and method!</tertiary></indexterm><indexterm id="I_indexterm2_d1e2334" significance="normal"><primary>method? and method!</primary></indexterm></para><sect3><title>Question marks</title><para>The purpose of the question mark is pretty straightforward. It
        allows us to query our object about things and make use of the
        response in conditionals. In essence, it allows things like
        this:<indexterm id="I_indexterm2_d1e2342" significance="normal"><primary>conditional statements, methods ending in ?</primary></indexterm></para><programlisting id="I_programlisting2_d1e2345" format="linespecific">unless some_string.empty?
  puts some_string.reverse
end</programlisting><para>In practice, the exact way that this sort of method is
        implemented varies, but the <phrase role="keep-together">return</phrase> <phrase role="keep-together">value</phrase> is always some sort of logical
        boolean. If you write a method that looks like <literal moreinfo="none">foo.is_dumb?</literal> that returns <literal moreinfo="none">:no</literal>, most Rubyists will disagree with you.
        If the condition described by the method is not satisfied, be sure
        that it returns either <literal moreinfo="none">false</literal> or
        <literal moreinfo="none">nil</literal>.</para><para>Purists might say that when you use this convention, the result
        should return boolean objects, meaning <literal moreinfo="none">true</literal> and <literal moreinfo="none">false</literal> only. In this case, a hack for
        converting Ruby objects to their boolean values is often used:</para><programlisting id="I_programlisting2_d1e2376" format="linespecific">&gt;&gt; !!(:blah)
=&gt; true
&gt;&gt; !!(false)
=&gt; false
&gt;&gt; !!(nil)
=&gt; false
&gt;&gt; !!(123)
=&gt; true</programlisting><para>This hack is somewhat controversial, but will negate the
        negation of the boolean status of your object, giving you back a
        boolean. So one might write a method like this:</para><programlisting id="I_programlisting2_d1e2380" format="linespecific">def person?
   !! @person
end</programlisting><para>However, there is something to be said for the other side of
        this argument. Sometimes it is useful to return the actual object, as
        in the following case:</para><programlisting id="I_programlisting2_d1e2384" format="linespecific">if user = foo.person?
  user.say_hello
end</programlisting><para>This is ultimately a matter of personal taste, but people on
        both sides of the fence agree that the use of a question mark in a
        Ruby method should return some logically boolean value that can be
        used meaningfully in conditional statements. If that is not the
        purpose you had in mind, consider avoiding the question mark in your
        method names.</para></sect3><sect3><title>Exclamation points</title><para>Most people tend to conceptually grasp the question mark
        convention fairly quickly, but the use of exclamation points is
        sometimes a little less intuitive. However, the convention itself is
        not that complicated and can be quite useful.</para><para>A common misconception is that we use the exclamation point when
        we want to let people know we are modifying the receiving object. This
        is probably due to the fact that, in many cases, this is what the
        exclamation point (also known as a bang) is warning us of. Here are
        just a few examples from Ruby’s built-in classes:</para><programlisting id="I_programlisting2_d1e2395" format="linespecific">&gt;&gt; a = "foo"
=&gt; "foo"
&gt;&gt; a.delete!("f")
=&gt; "oo"
&gt;&gt; a
=&gt; "oo"

&gt;&gt; a = [1,2,3]
=&gt; [1, 2, 3]
&gt;&gt; a.map! { |e| e + 1 }
=&gt; [2, 3, 4]
&gt;&gt; a
=&gt; [2, 3, 4]

&gt;&gt; a = { foo: "bar" }
=&gt; {:foo=&gt;"bar"}
&gt;&gt; a.merge!(baz: "foobar")
=&gt; {:foo=&gt;"bar", :baz=&gt;"foobar"}
&gt;&gt; a
=&gt; {:foo=&gt;"bar", :baz=&gt;"foobar"}</programlisting><para>However, what about <literal moreinfo="none">Hash#update</literal>?</para><programlisting id="I_programlisting2_d1e2402" format="linespecific">&gt;&gt; a = { foo: "bar" }
=&gt; {:foo=&gt;"bar"}
&gt;&gt; a.update(baz: "foobar")
=&gt; {:foo=&gt;"bar", :baz=&gt;"foobar"}
&gt;&gt; a
=&gt; {:foo=&gt;"bar", :baz=&gt;"foobar"}</programlisting><para>This does the same thing as <literal moreinfo="none">Hash#merge!</literal>, but no bang is present. I can
        think of tons of other examples where this is true. <literal moreinfo="none">String#replace</literal> doesn’t have a bang, and
        neither does <literal moreinfo="none">Array#push</literal> or <literal moreinfo="none">Array#pop</literal>. If the convention was really to
        slap an exclamation point at the end of every method that changed
        something about its receiver, we’d have more exclamation points in
        Ruby’s method list than a teenager could use in an IM session.</para><para>Truthfully, the purpose of this convention is to mark a method
        as special. It doesn’t necessarily mean that it will be destructive or
        dangerous, but it means that it will require more attention than its
        alternative. This is why it doesn’t make much sense to have some
        method <literal moreinfo="none">foo!()</literal> without a
        corresponding <literal moreinfo="none">foo()</literal> method that
        does something similar. So essentially, if you have only one way of
        doing something destructive, write this:<indexterm id="I_indexterm2_d1e2426" significance="normal"><primary>destructive operations</primary></indexterm></para><programlisting id="I_programlisting2_d1e2429" format="linespecific">class Message
  def destroy
     #...
  end
end</programlisting><para>instead of this:</para><programlisting id="I_programlisting2_d1e2433" format="linespecific">class Message
  def destroy!
    #...
  end
end</programlisting><para>Following this idea that an exclamation point doesn’t
        necessarily mean that a method is doing a
        <emphasis>destructive</emphasis> operation, we can find more varied
        uses for it. For example, if you look at the way the ActiveRecord
        object-relational mapping (ORM) works, you can see a good example of a
        proper use for this convention.<indexterm id="I_indexterm2_d1e2441" significance="normal"><primary>ActiveRecord, object-relational mapping (ORM)</primary></indexterm><indexterm id="I_indexterm2_d1e2444" significance="normal"><primary>object-relational mapping (ORM), ActiveRecord</primary></indexterm></para><para>Creating a user that doesn’t pass validations does not raise an
        exception, but rather stores issues in an errors array, and allows you
        to check whether a record is valid:</para><programlisting id="I_programlisting2_d1e2449" format="linespecific">&gt;&gt; a = User.create(:login =&gt; "joe")
=&gt; #&lt;User id: nil, login: "joe", ... &gt;
&gt;&gt; a.valid?
=&gt; false</programlisting><para>By calling <literal moreinfo="none">User.create!</literal>, we
        can cause ActiveRecord to raise an error:</para><programlisting id="I_programlisting2_d1e2456" format="linespecific">&gt;&gt; a = User.create!(:login =&gt; "joe")
ActiveRecord::RecordInvalid: Validation failed: Password confirmation can't be
blank, Password can't be blank,
Password is too short (minimum is 7 characters), Password Must include at
least three of the following character types: upper case, lower case, numeric,
non alphanumeric, Email can't be blank, Email is too short (minimum is 3
characters)</programlisting><para>These two methods are functionally equivalent otherwise, but the
        latter has a more severe response, which exactly fits the conditions
        under which this convention is useful. Essentially, when you see a !
        at the end of a Ruby method, think “Pay attention!” rather than “You
        are on your way to destruction!” and you’ll be fine.<indexterm id="I_indexterm2_d1e2460" class="endofrange" startref="ch02_methodsquestionexclaim" significance="normal"/><indexterm id="I_indexterm2_d1e2461" class="endofrange" startref="ch02_APIsquestionexclaim" significance="normal"/></para></sect3></sect2><sect2><title>Make Use of Custom Operators</title><para>Ruby allows you to define custom operators for your classes. This
      is especially easy in Ruby because most operators are actually just
      syntactic sugar for ordinary methods:<indexterm id="I_indexterm2_d1e2467" significance="normal"><primary>APIs, designing</primary><secondary>avoiding surprises</secondary><tertiary>using custom operators</tertiary></indexterm><indexterm id="I_indexterm2_d1e2474" significance="normal"><primary>operators, custom</primary></indexterm></para><programlisting id="I_programlisting2_d1e2477" format="linespecific">&gt;&gt; 1.+(3)
=&gt; 4

&gt;&gt; [1,2,3].&lt;&lt;(4)
=&gt; [1, 2, 3, 4]</programlisting><para>We can thus define our operators as if they were ordinary methods.
      Here’s a quick example of one of the most common operators to implement,
      the append <phrase role="keep-together">operator</phrase>
      (<literal moreinfo="none">&lt;&lt;</literal>):<indexterm id="I_indexterm2_d1e2487" significance="normal"><primary>append operator</primary></indexterm></para><programlisting id="I_programlisting2_d1e2490" format="linespecific">class Inbox

  attr_reader :unread_count

  def initialize
    @messages     = []
    @unread_count = 0
  end

  def &lt;&lt;(msg)
    @unread_count += 1
    @messages &lt;&lt; msg
    return self
  end

end

&gt;&gt; i = Inbox.new
=&gt; #&lt;Inbox:0x603290 @messages=[], @unread_count=0&gt;
&gt;&gt; i &lt;&lt; "foo" &lt;&lt; "bar" &lt;&lt; "baz"
=&gt; #&lt;Inbox:0x603290 @messages=["foo", "bar", "baz"], @unread_count=3&gt;
&gt;&gt; i.unread_count
=&gt; 3</programlisting><para>A good habit to get into is to have your
      <literal moreinfo="none">&lt;&lt;</literal> method return the object itself, so the
      calls can be chained, as just shown.</para><para>Another good operator to know about is the <emphasis>spaceship
      operator</emphasis> (<literal moreinfo="none">&lt;=&gt;</literal>),
      mainly because it allows you to make use of <literal moreinfo="none">Comparable</literal>, which gives you a host of
      comparison methods: <literal moreinfo="none">&lt;</literal>, <literal moreinfo="none">&lt;=</literal>, <literal moreinfo="none">==</literal>,
      <literal moreinfo="none">!=</literal>, <literal moreinfo="none">&gt;=</literal>, <literal moreinfo="none">&gt;</literal>, and <literal moreinfo="none">between?()</literal>.<indexterm id="I_indexterm2_d1e2530" significance="normal"><primary>Comparable module</primary></indexterm><indexterm id="I_indexterm2_d1e2534" significance="normal"><primary>&lt;=&gt; (spaceship) operator</primary></indexterm><indexterm id="I_indexterm2_d1e2537" significance="normal"><primary>spaceship operator (&lt;=&gt;)</primary></indexterm></para><para>The spaceship operator should return <literal moreinfo="none">-1</literal> if the current object is less than the
      object it is being compared to, <literal moreinfo="none">0</literal> if
      it is equal, and <literal moreinfo="none">1</literal> if it is greater.
      Most of Ruby’s core objects that can be meaningfully compared already
      have <literal moreinfo="none">&lt;=&gt;</literal> implemented, so it’s
      often simply a matter of delegating to them, as shown here:</para><programlisting id="I_programlisting2_d1e2554" format="linespecific">class Tree

  include Comparable

  attr_reader :age

  def initialize(age)
    @age = age
  end

  def &lt;=&gt;(other_tree)
    age &lt;=&gt; other_tree.age
  end

end

&gt;&gt; a = Tree.new(2)
=&gt; #&lt;Tree:0x5c9ba8 @age=2&gt;
&gt;&gt; b = Tree.new(3)
=&gt; #&lt;Tree:0x5c7fb0 @age=3&gt;
&gt;&gt; c = Tree.new(3)
=&gt; #&lt;Tree:0x5c63b8 @age=3&gt;

&gt;&gt; a &lt; b
=&gt; true
&gt;&gt; b == c
=&gt; true
&gt;&gt; c &gt; a
=&gt; true
&gt;&gt; c != a
=&gt; true</programlisting><para>You can, of course, override some of the individual operators that
      <literal moreinfo="none">Comparable</literal> provides, but its defaults
      are often exactly what you need.</para><para>Most operators you use in Ruby can be customized within your
      objects. Whenever you find yourself writing <literal moreinfo="none">append()</literal> when you really want <literal moreinfo="none">&lt;&lt;</literal>, or <literal moreinfo="none">add()</literal> when you really want
      <literal moreinfo="none">+</literal>, consider using your own custom operators.</para><para>None of the conventions mentioned here are set laws that need to
      be followed; in fact, you’ll certainly run into situations where it’ll
      make sense to violate some of them from time to time. However, generally
      these practices have become popular because they make your code better,
      and make it easier for someone who has never used your code before to
      get up and running. Here’s a quick recap of some of the tips we’ve
      covered:<indexterm id="I_indexterm2_d1e2578" significance="normal"><primary>APIs, designing</primary><secondary>avoiding surprises</secondary><tertiary>summary of practices</tertiary></indexterm></para><itemizedlist><listitem><para>Use <literal moreinfo="none">attr_reader</literal>, <literal moreinfo="none">attr_writer</literal>, and <literal moreinfo="none">attr_accessor</literal> whenever possible, and avoid
          writing your own accessors unless it is necessary.</para></listitem><listitem><para>Consider ending methods that are designed to be used in
          conditional statements with a question mark.</para></listitem><listitem><para>If you have a method <literal moreinfo="none">foo()</literal>,
          and a similar method that does nearly the same thing but requires
          the user to pay more attention to what’s going on, consider calling
          it <literal moreinfo="none">foo!()</literal>.</para></listitem><listitem><para>Don’t bother creating a method <literal moreinfo="none">foo!()</literal> if there is not already a method
          called <literal moreinfo="none">foo()</literal> that does the same
          thing with less severe consequences.</para></listitem><listitem><para>If it makes sense to do so, define custom operators for your
          objects.<indexterm id="I_indexterm2_d1e2622" class="endofrange" startref="ch02_APIssurprises" significance="normal"/></para></listitem></itemizedlist></sect2></sect1><sect1 id="I_sect12_d1e2623"><title>Conclusions</title><para>The difficulty of designing a solid API for a given problem depends
    largely on the problem itself. However, we’ve seen in this chapter that
    Ruby is pretty much happy to get out of your way and provide you with an
    enormous amount of flexibility so that you can more easily design what you
    had in mind, rather than what Matz thinks you should do.</para><para>When developing your interfaces, be sure to actually use them in
    order to drive them along. In this way, you are forced to eat your own dog
    food, and this ensures that the API ends up satisfying the goal of working
    nicely rather than simply looking nice from a distance. You can gain a lot
    of inspiration by looking at the way in which the core Ruby objects are
    designed, API-wise. The best way to make your code more Rubyish is to make
    it work like core Ruby objects do whenever you can. Of course, like
    anything else, trying to stretch this idea too far can be disastrous. In
    moderation, however, this general approach combined with the technical
    details in this chapter should put you on your way to writing solid Ruby
    libraries in no time, or, failing that, should clean up your existing code
    a bit and make it easier to work with.<indexterm id="I_indexterm2_d1e2630" class="endofrange" startref="ch02_APIdesign" significance="normal"/></para></sect1></chapter><chapter id="ch03"><title>Mastering the Dynamic Toolkit</title><para>If you’ve done even a little bit of Ruby, you probably have a sense of
  the great flexibility and power that it offers as a language. This chapter
  is designed to underscore that point, specifically by showing you what can
  be accomplished when you unleash the power of Ruby onto itself. When you
  hear that everything is an object in Ruby, it’s easy to forget that classes,
  modules, and methods all fall into that category as well. With enough
  imagination, we can think of all sorts of interesting applications that fall
  out of this elegant design.<indexterm id="I_indexterm3_d1e2636" significance="normal"><primary>objects</primary></indexterm></para><para>Take the fact that all of our programmatic constructs can be
  represented as first-order data objects and combine it with the ability to
  modify any of them at runtime. Then mix in the idea that everything from
  defining a new function to calling a method that does not exist can be
  detected and handled by custom code. Top this off with first-rate reflection
  capabilities and you’ll find that Ruby is a perfect foundation for writing
  highly dynamic applications.</para><para>On the surface, these ideas may seem a bit esoteric or academic in
  nature. But when you get down to it, there are a lot of practical uses for
  having such a high degree of flexibility baked into Ruby. Because Ruby’s
  dynamic nature is a huge part of what makes the language what it is, you’ll
  find no shortage of real examples in this chapter. These run the gamut from
  dynamic interface generation to safely modifying preexisting code at
  runtime. But to get your feet wet, we’ll dive in with the same head-first
  approach found in the rest of the chapters of this book. We’re about to look
  at the code behind Jim Weirich’s <literal moreinfo="none">BlankSlate</literal> class, which provides an excellent case
  study of what can be accomplished with the dynamic toolkit that Ruby
  provides for us.<indexterm id="I_indexterm3_d1e2646" significance="normal"><primary>Weirich, Jim</primary></indexterm></para><para>If you feel a bit overwhelmed at first, don’t be discouraged—each
  individual topic will be discussed later on in this chapter in greater
  detail. For now, let’s just try to have fun and see just how powerful Ruby
  really is.<indexterm class="startofrange" id="ch03_BlankSlate" significance="normal"><primary>BlankSlate class</primary></indexterm></para><sect1 id="I_sect13_d1e2654"><title>BlankSlate: A BasicObject on Steroids</title><para>Although Ruby 1.9 has <literal moreinfo="none">BasicObject</literal> as a very
    lightweight object designed to be used for implementing objects with
    dynamic interfaces and other similar tasks, Ruby 1.8 users weren’t so
    lucky. In light of this, <literal moreinfo="none">BlankSlate</literal>
    became a fairly common tool for those who needed an object that didn’t do
    much of anything. One of the practical applications of this somewhat
    abstract object was in implementing the XML generator in the
    <emphasis>builder</emphasis> gem. In case you’ve not seen XML Builder
    before, it is a tool that turns Ruby code like this:<indexterm id="I_indexterm3_d1e2668" significance="normal"><primary>builder gem</primary></indexterm><indexterm id="I_indexterm3_d1e2671" significance="normal"><primary>XML Builder</primary></indexterm><indexterm id="I_indexterm3_d1e2674" significance="normal"><primary>BasicObject objects</primary></indexterm></para><screen format="linespecific">builder = Builder::XmlMarkup.new(:target=&gt;STDOUT, :indent=&gt;2)
builder.person { |b| b.name("Jim"); b.phone("555-1234") }</screen><para>into XML output like this:</para><screen format="linespecific">&lt;person&gt;
  &lt;name&gt;Jim&lt;/name&gt;
  &lt;phone&gt;555-1234&lt;/phone&gt;
&lt;/person&gt;</screen><para>Without going into too much detail, it is obvious from this example
    that <literal moreinfo="none">Builder::XmlMarkup</literal> implements a
    dynamic interface that can turn your method calls into matching XML
    output. But if it had simply inherited from <literal moreinfo="none">Object</literal>, you’d run into certain naming clashes
    wherever a tag had the same name as one of <literal moreinfo="none">Object</literal>’s instance methods.<indexterm id="I_indexterm3_d1e2694" significance="normal"><primary>Builder::XmlMarkup</primary></indexterm></para><para>Builder works by capturing calls to missing methods, which means it
    has trouble doing its magic whenever a method is actually defined. For
    example: if <literal moreinfo="none">XmlMarkup</literal> were just a
    subclass of <literal moreinfo="none">Object</literal>, with no methods
    removed, you wouldn’t be able produce the following XML, due to a naming
    conflict:</para><screen format="linespecific">&lt;class&gt;
  &lt;student&gt;Greg Gibson&lt;/student&gt;
&lt;/class&gt;</screen><para>The underlying issue here is that <literal moreinfo="none">Kernel#class</literal> is already defined for a different
    purpose. Of course, if we instead inherit from an object that has very few
    methods to begin with, this greatly lessens our chance for a clash.</para><para><literal moreinfo="none">BasicObject</literal> certainly fits the bill, as you can
    see with a quick glance at its instance methods via
    <emphasis>irb</emphasis>:<indexterm id="I_indexterm3_d1e2719" significance="normal"><primary>instance_methods( )</primary></indexterm><indexterm id="I_indexterm3_d1e2722" significance="normal"><primary>BasicObject class, instance methods</primary></indexterm></para><screen format="linespecific">&gt;&gt; BasicObject.instance_methods
=&gt; [:==, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__]</screen><para>These methods form the lowest common denominator for Ruby, so
    <literal moreinfo="none">BasicObject</literal> is pretty reasonable in its
    offerings. The key thing to remember is that a <literal moreinfo="none">BasicObject</literal> is fully defined by this limited set
    of features, so you shouldn’t expect anything more than that. Although
    this makes perfect sense in Ruby 1.9’s object hierarchy, it’s somewhat
    interesting to see that <literal moreinfo="none">BlankSlate</literal>
    takes an entirely different approach.<indexterm id="I_indexterm3_d1e2739" significance="normal"><primary>instance_eval( ) method</primary></indexterm><indexterm class="startofrange" id="ch03_reflection" significance="normal"><primary>reflection</primary></indexterm></para><para>On Ruby 1.8, there was no <literal moreinfo="none">BasicObject</literal> class to speak of, so instead of
    starting off with a tiny set of methods, <literal moreinfo="none">BlankSlate</literal> had to do something to get rid of the
    significant baggage that rides along with Ruby’s <literal moreinfo="none">Object</literal> class. This is done in an especially
    clever way, and a quick <emphasis>irb</emphasis> session complete with the
    expected noise that results from <phrase role="keep-together">removing</phrase> potentially important methods shows
    the primary interesting features of <literal moreinfo="none" role="keep-together">BlankSlate</literal>:<indexterm id="I_indexterm3_d1e2766" significance="normal"><primary>BlankSlate class</primary><secondary>interesting features</secondary></indexterm></para><screen format="linespecific">&gt;&gt; class A &lt; BlankSlate; end
=&gt; nil
&gt;&gt; A.new
NoMethodError: undefined method 'inspect' for #&lt;A:0x42ac34&gt;
...
&gt;&gt; A.reveal(:inspect)
=&gt; #&lt;Proc:0x426558@devel/rbp_code/dynamic_toolkit/blankslate.rb:43 (lambda)&gt;
&gt;&gt; A.new
NoMethodError: undefined method 'to_s' for #&lt;A:0x425004&gt;
...
&gt;&gt; A.reveal(:to_s)
=&gt; #&lt;Proc:0x422e30@devel/rbp_code/dynamic_toolkit/blankslate.rb:43 (lambda)&gt;
&gt;&gt; A.new
=&gt; #&lt;A:0x425004&gt;
&gt;&gt; A.new.methods
NoMethodError: undefined method 'methods' for #&lt;A:0x425004&gt;
        from (irb):8
        from /Users/sandal/lib/ruby19_1/bin/irb:12:in '&lt;main&gt;'
&gt;&gt; A.reveal(:methods)
=&gt; #&lt;Proc:0x41ed6c@devel/rbp_code/dynamic_toolkit/blankslate.rb:43 (lambda)&gt;
&gt;&gt; A.new.methods
=&gt; [:inspect, :to_s, :methods, :__id__, :instance_eval, :__send__]</screen><para>After reading through this code, you should be able to get a sense
    of how it works. <literal moreinfo="none">BlankSlate</literal> isn’t
    really a blank slate at all; instead, it’s an object that acts like a
    blank slate by hiding all of its methods until you tell them explicitly to
    reveal themselves. This clever bit of functionality allows <literal moreinfo="none">BlankSlate</literal>’s initial instance methods to be kept
    to the absolute minimum. Everything else can be explicitly revealed later,
    as needed.</para><para><literal moreinfo="none">BlankSlate</literal> does this per
    subclass, so you can have different customized minimal objects for
    different purposes in your system. Predictably, you can also rehide
    functions, <phrase role="keep-together">including</phrase> those that you
    add yourself:<indexterm id="I_indexterm3_d1e2788" significance="normal"><primary>BlankSlate class</primary><secondary>hiding and restoring functionality</secondary></indexterm></para><screen format="linespecific">&gt;&gt; A.new.foo
=&gt; "Hi"
&gt;&gt; A.hide(:foo)
=&gt; A
&gt;&gt; A.new.foo
NoMethodError: undefined method 'foo' for #&lt;A:0x425004&gt;
        from (irb):18
        from /Users/sandal/lib/ruby19_1/bin/irb:12:in '&lt;main&gt;'
&gt;&gt; A.hide(:inspect)
=&gt; A
&gt;&gt; A.new
NoMethodError: undefined method 'inspect' for #&lt;A:0x40a484&gt;
...</screen><para>All in all, although it is a bit more heavyweight than <literal moreinfo="none">BasicObject</literal>, the <literal moreinfo="none">BlankSlate</literal> class may have its uses even on Ruby
    1.9, due to this ability to seamlessly hide and restore functionality on
    the fly. If you were thinking that this sounds like complicated stuff, you
    might be surprised. The core implementation of <literal moreinfo="none">BlankSlate</literal> is relatively <phrase role="keep-together">straightforward</phrase>. Of course, the devil is in
    the details, but the most interesting bits can be understood with a little
    explanation:<indexterm id="I_indexterm3_d1e2809" significance="normal"><primary>undef_method( )</primary></indexterm><indexterm id="I_indexterm3_d1e2812" significance="normal"><primary>define_method( )</primary></indexterm><indexterm id="I_indexterm3_d1e2816" significance="normal"><primary>BlankSlate class</primary><secondary>core implementation</secondary></indexterm></para><screen format="linespecific">class BlankSlate
  class &lt;&lt; self

    # Hide the method named +name+ in the BlankSlate class.  Don't
    # hide +instance_eval+ or any method beginning with "__".
    def hide(name)
      if instance_methods.include?(name) and
        name !~ /^(__|instance_eval)/
        @hidden_methods ||= {}
        @hidden_methods[name] = instance_method(name)
        undef_method name
      end
    end

    def find_hidden_method(name)
      @hidden_methods ||= {}
      @hidden_methods[name] || superclass.find_hidden_method(name)
    end

    # Redefine a previously hidden method so that it may be called on a blank
    # slate object.
    def reveal(name)
      unbound_method = find_hidden_method(name)
      fail "Don't know how to reveal method '#{name}'" unless unbound_method
      define_method(name, unbound_method)
    end
  end

  instance_methods.each { |m| hide(m) }
end</screen><para>As you can see, the class is simply three short class methods,
    followed by the call that causes all of <literal moreinfo="none">BlankSlate</literal>’s instance methods to be hidden.
    Let’s start by taking a closer look at the <literal moreinfo="none">hide()</literal> method.<indexterm id="I_indexterm3_d1e2831" significance="normal"><primary>BlankSlate class</primary><secondary>hide( ) method</secondary></indexterm></para><screen format="linespecific">def hide(name)
  if instance_methods.include?(name) &amp;&amp; name !~ /^(__|instance_eval)/
    @hidden_methods ||= {}
    @hidden_methods[name] = instance_method(name)
    undef_method name
  end
end</screen><para>Here you can see that <literal moreinfo="none">BlankSlate</literal>
    first checks to make sure that the method name passed to <literal moreinfo="none">hide()</literal> exists within the currently visible
    instance methods. Once it checks to make sure the method is not one of the
    special reserved methods, it begins the process of storing and hiding the
    specified method.</para><para>The technique used here is simply to initialize a <literal moreinfo="none">@hidden_methods</literal> hash within the class, and then
    assign the method name as a key to the associated <literal moreinfo="none">UnboundMethod</literal> object. An <literal moreinfo="none">UnboundMethod</literal> can be thought of as roughly
    similar to a <literal moreinfo="none">Proc</literal> object, but rather
    than being truly anonymous, it is later hooked up to an object that knows
    how to make use of the function, which is typically an object of the same
    class. As a trivial example, we can play around with <literal moreinfo="none">String#reverse</literal> to illustrate this
    point:<indexterm id="I_indexterm3_d1e2865" significance="normal"><primary>UnboundMethod objects</primary></indexterm></para><screen format="linespecific">&gt;&gt; a = String.instance_method(:reverse)
=&gt; #&lt;UnboundMethod: String#reverse&gt;
&gt;&gt; a.bind("foo").call
=&gt; "oof"</screen><para>We’ll take a closer look at this a little later, but suffice it to
    say that by grabbing the <literal moreinfo="none">UnboundMethod</literal>
    before removing the method definition, we have a way of restoring the
    behavior in the future.</para><para>I assume you can get the gist of what’s going on with <literal moreinfo="none" role="keep-together">find_hidden_method()</literal> just
    by inspection, so we can jump straight into the most interesting code in
    <literal moreinfo="none" role="keep-together">BlankSlate</literal>, the
    method that actually restores the old functionality:<indexterm id="I_indexterm3_d1e2883" significance="normal"><primary>BlankSlate class</primary><secondary>find_hidden_method( ) helper function</secondary></indexterm></para><screen format="linespecific"># Redefine a previously hidden method so that it may be called on a blank
# slate object.
def reveal(name)
  unbound_method = find_hidden_method(name)
  fail "Don't know how to reveal method '#{name}'" unless unbound_method
  define_method(name, unbound_method)
end</screen><para>Here, the <literal moreinfo="none">find_hidden_method()</literal>
    helper is used to recall an <literal moreinfo="none">UnboundMethod</literal> by name. If
    it doesn’t manage to find a matching name in the <literal moreinfo="none">@hidden_methods</literal> hash, an error is raised.
    However, assuming the lookup went according to plan, we can see that the
    method is redefined to call the newly rebound method. All the original
    arguments are passed on to the restored method call, so you end up with
    the original behavior restored.</para><para>Although we’ve shown the key components of <literal moreinfo="none">BlankSlate</literal> here, we haven’t gone into the full
    details yet. It’s worth mentioning that because <literal moreinfo="none">BlankSlate</literal> inherits from <literal moreinfo="none">Object</literal> and not <literal moreinfo="none">BasicObject</literal>, it has to do some additional magic
    to deal with module inclusion, and it also must handle methods added to
    <literal moreinfo="none">Object</literal> and <literal moreinfo="none">Kernel</literal>. We’ll get to these a little later, in
    <xref linkend="registering_hooks_and_callbacks"/>. For now, let’s just
    quickly review the concepts we’ve touched on.</para><para>In this initial exploration phase, we’ve caught a glimpse of
    <literal moreinfo="none">define_method</literal>, <literal moreinfo="none">instance_methods</literal>, <literal moreinfo="none">instance_method</literal>, <literal moreinfo="none">undef_method</literal>, and <literal moreinfo="none">UnboundMethod</literal>. Or in English, we’ve seen an
    example of how to use reflection to determine the names of the instance
    methods on a class, copy their implementations into objects that could
    then be keyed by name in a hash, undefine them, and later restore them by
    building up a new definition programmatically. You have probably noticed
    that even though these concepts are very high-level, they’re essentially
    ordinary Ruby code, without any sort of magic. The rest of this chapter
    will serve to reinforce that point.<indexterm id="I_indexterm3_d1e2942" class="endofrange" startref="ch03_reflection" significance="normal"><primary>reflection</primary><secondary>determining names of instance methods</secondary></indexterm><indexterm id="I_indexterm3_d1e2947" significance="normal"><primary>define_method( )</primary><seealso>BlankSlate class</seealso></indexterm></para><para>Now that we’ve seen a few of these concepts in action, we’ll slow
    down and discuss what each one of them actually means, while diving even
    deeper into dynamic Ruby territory. In this next example, we’ll look at a
    favorite topic for budding Rubyists. I’m going to share the secrets behind
    building flexible interfaces that can be used for <phrase role="keep-together">domain-specific</phrase> applications. The
    heavy-handed term for this sort of thing is an “<phrase role="keep-together">internal</phrase> domain-specific language,” but we
    don’t need to be so fancy, as it can create misconceptions. The ability to
    build pleasant domain-specific interfaces is a key feature of Ruby, and
    deserves some discussion—no matter what you want to call it.<indexterm id="I_indexterm3_d1e2960" class="endofrange" startref="ch03_BlankSlate" significance="normal"/></para></sect1><sect1 id="I_sect13_d1e2961"><title>Building Flexible Interfaces</title><para>Heads up: you might start to feel a bit of déjà vu in this section.
    What we’ll cover here is basically a recap of what was discussed in <xref linkend="ch02" xrefstyle="chap-num-title"/>, mixed in with a little
    dynamic help here and there. Though each step may seem fairly
    inconsequential, the end result is quite powerful.<indexterm class="startofrange" id="ch03_domainspecificints" significance="normal"><primary>domain-specific interfaces, building flexible</primary></indexterm></para><para>When implementing a flexible domain-specific interface, the idea is
    that we want to strip away as much boilerplate code as possible so that
    every line expresses something meaningful in the context of our domain. We
    also want to build up a vocabulary to work with, and express our intents
    in that vocabulary as much as possible. A domain-specific interface puts
    Ruby in the background: available when you need it, but not as
    in-your-face as ordinary programmatic interfaces tend to be. An easy
    comparison would be to look at the difference between some elementary
    <literal moreinfo="none">Test::Unit</literal> code and its RSpec equivalent.<footnote><para>This example is from the <ulink url="http://rspec.info">RSpec
        home page</ulink>, with minor modifications.</para></footnote></para><para>First, we’ll look at the vanilla <literal moreinfo="none">Test::Unit</literal> code:</para><screen format="linespecific">class NewAccountTest &lt; Test::Unit

  def setup
    @account = Account.new
  end

  def test_must_start_with_a_zero_balance
    assert_equal Money.new(0, :dollars), @account.balance
  end

end</screen><para>To a Rubyist, this code might seem relatively clear,
    straightforward, and expressive. However, its defining characteristic is
    that it looks like any other Ruby code, with all the associated benefits
    and drawbacks. Others prefer a different approach, which you can clearly
    see in this RSpec code:<indexterm id="I_indexterm3_d1e2991" significance="normal"><primary>RSpec code</primary></indexterm></para><screen format="linespecific">describe Account, " when first created" do

  before do
    @account = Account.new
  end
<?dbfo-need height="1in"
?>
  it "should have a balance of $0" do
    @account.balance.should eql(Money.new(0, :dollars))
  end

end</screen><para>When we read RSpec code, it feels like we’re reading specifications
    rather than Ruby code. Many people feel this is a major advantage, because
    it encourages us to express ourselves in a domain-specific context. When
    it comes to testing, this does create some controversy, because although
    the RSpec code is arguably more readable here, the <literal moreinfo="none">Test::Unit</literal> code is certainly less magical. But
    in the interest of avoiding politics, I’ve shown this example to
    illustrate the difference between two styles, not to advocate one over the
    other.</para><para>Even though some particular uses of domain-specific interfaces can
    be a touchy subject, you’ll find many cases where they come in handy. To
    help you get a feel for how they come together, we’ll be looking at some
    problems and their solutions. We’re about to walk through the lifecycle of
    wrapping a nice interface on top of Prawn’s <literal moreinfo="none">Document</literal> class. Don’t worry about the particular
    domain; instead, focus on the techniques we use so that you can make use
    of them in your own projects.</para><sect2><title>Making instance_eval( ) Optional</title><para>In the previous chapter, we covered a common pattern for interface
      simplification, allowing you to turn code like this:<indexterm class="startofrange" id="ch03_instanceeval" significance="normal"><primary>instance_eval( ) method</primary><secondary>making optional</secondary></indexterm><indexterm class="startofrange" id="ch03_domainintsinstanceeval" significance="normal"><primary>domain-specific interfaces, building flexible</primary><secondary>making instance_eval( ) optional</secondary></indexterm></para><screen format="linespecific">pdf = Prawn::Document.new
pdf.text "Hello World"
pdf.render_file "hello.pdf"</screen><para>into something like this:</para><screen format="linespecific">Prawn::Document.generate("hello.pdf") do
  text "Hello World"
end</screen><para>As you’ll recall, this trick is relatively straightforward to
      implement:</para><screen format="linespecific">class Prawn::Document
  def self.generate(file, *args, &amp;block)
    pdf = Prawn::Document.new(*args)
    pdf.instance_eval(&amp;block)
    pdf.render_file(file)
  end
end</screen><para>However, there is a limitation that comes with this sort of
      interface. Because we are evaluating the block in the context of a
      <literal moreinfo="none">Document</literal> instance, we do not have
      access to anything but the local variables of our enclosing scope. This
      means the following code won’t work:</para><screen format="linespecific">class MyBestFriend

  def initialize
    @first_name = "Paul"
    @last_name  = "Mouzas"
  end

  def full_name
    "#{@first_name} #{@last_name}"
  end

  def generate_pdf
    Prawn::Document.generate("friend.pdf") do
      text "My best friend is #{full_name}"
    end
  end

end</screen><para>It’d be a shame to have to revert to building this stuff up
      manually, and a bit messy to rely on storing things in local variables.
      Luckily, there is a middle-of-the-road option: we can optionally yield a
      <literal moreinfo="none">Document</literal> object. Here’s how we’d go
      about doing that:</para><screen format="linespecific">class Prawn::Document
  def self.generate(file, *args, &amp;block)
    pdf = Prawn::Document.new(*args)
    block.arity &lt; 1 ? pdf.instance_eval(&amp;block) : block.call(pdf)
    pdf.render_file(file)
  end
end</screen><para>This new code preserves the old <literal moreinfo="none">instance_eval</literal> behavior, but allows a new
      approach as well. We can now write the following code without
      worry:</para><screen format="linespecific">class MyOtherBestFriend

  def initialize
    @first_name = "Pete"
    @last_name  = "Johansen"
  end

  def full_name
    "#{@first_name} #{@last_name}"
  end

  def generate_pdf
    Prawn::Document.generate("friend.pdf") do |doc|
      doc.text "My best friend is #{full_name}"
    end
  end

end</screen><para>Here, the code is an ordinary closure, and as such, can access the
      instance methods and variables of the enclosing scope. Although we need
      to go back to having an explicit receiver for the PDF calls, our
      <literal moreinfo="none">Document.generate</literal> method can still do
      its necessary setup and teardown for us, salvaging some of its core
      functionality.<indexterm id="I_indexterm3_d1e3060" significance="normal"><primary>closures</primary></indexterm></para><para>The feature that makes this all possible is <literal moreinfo="none">Proc#arity</literal>. This method tells you how many
      arguments, if any, the code block was given. Here’s a few examples as an
      illustration:<indexterm id="I_indexterm3_d1e3068" significance="normal"><primary>Proc#arity method</primary></indexterm></para><screen format="linespecific">&gt;&gt; lambda { |x| x + 1 }.arity
=&gt; 1
&gt;&gt; lambda { |x,y,z| x + y + z }.arity
=&gt; 3
&gt;&gt; lambda { 1 }.arity
=&gt; 0</screen><para>As you can see, because <literal moreinfo="none">Proc</literal>
      objects are just objects themselves, we can do some reflective inquiry
      to find out how many arguments they’re expecting to process. Although
      not strictly related to our task, it’s worth mentioning that you can
      accomplish the same thing with methods as well:</para><screen format="linespecific">&gt;&gt; Comparable.instance_method(:between?).arity
=&gt; 2
&gt;&gt; Fixnum.instance_method(:to_f).arity
=&gt; 0</screen><para>Although our use of an <literal moreinfo="none">arity</literal>
      check was confined to a relatively simple task here, the technique is
      general. Any time you want to conditionally handle something based on
      how many block arguments are present, you can use this general
      approach.</para><para>That having been said, even if you never use this trick for
      anything else, knowing how to selectively <literal moreinfo="none">instance_eval</literal> a block is important. As you’ll
      see through the rest of this section, a key part of developing a
      pleasant domain-specific interface is maintaining flexibility. If you
      limit yourself to an all-or-nothing choice between your sexy shortcuts
      and the bland, low-level API, frustration is inevitable. Of course,
      because Ruby is so dynamic, you should never be forced to make this
      decision.</para><para>We’ll now move on to another key component of flexible interface
      design: the use of <literal moreinfo="none">method_missing</literal> and
      <literal moreinfo="none">send</literal> to dynamically route messages
      within your objects.<indexterm id="I_indexterm3_d1e3098" class="endofrange" startref="ch03_domainintsinstanceeval" significance="normal"/><indexterm id="I_indexterm3_d1e3099" class="endofrange" startref="ch03_instanceeval" significance="normal"/></para></sect2><sect2><title>Handling Messages with method_missing( ) and send( )</title><para>Continuing on a theme, we can look at more Prawn code to see how
      to make things a bit more dynamic. We’ll be looking at elementary
      drawing operations here, but you can substitute your own problem
      mentally. As in other examples, the actual domain does not
      matter.<indexterm class="startofrange" id="ch03_domainintsmessages" significance="normal"><primary>domain-specific interfaces, building flexible</primary><secondary>handling messages with method_missing( ) and send(
          )</secondary></indexterm><indexterm class="startofrange" id="ch03_messages" significance="normal"><primary>messages, handling with method_missing( ) and send(
          )</primary></indexterm></para><para>In Prawn, there are two ordinary ways to generate some shapes and
      then draw them onto the page. The first is the most simple—just drawing
      the paths, and then calling one of <literal moreinfo="none">stroke</literal>, <literal moreinfo="none">fill</literal>, or <literal moreinfo="none">fill_and_stroke</literal>:</para><screen format="linespecific">Prawn::Document.generate("shapes.pdf") do
  fill_color "ff0000"
<?dbfo-need height="1in"
?>
  # Fills a red circle
  circle_at [100,100], :radius =&gt; 25
  fill

  # Strokes a transparent circle with a black border and a line extending
  # from its center point
  circle_at [300,300] :radius =&gt; 50
  line [300,300], [350, 300]
  stroke

  # Fills and strokes a red hexagon with a black border
  polygon [100, 250], [200, 300], [300, 250],
          [300, 150], [200, 100], [100, 150]
  fill_and_stroke
end</screen><para>This isn’t too bad, but for some needs, a block form is better.
      This makes it clearer what paint operation is being used, and may be a
      bit easier to extend:</para><screen format="linespecific">Prawn::Document.generate("shapes.pdf") do
  fill_color "ff0000"

  # Fills a red circle
  fill { circle_at [100,100], :radius =&gt; 25 }

  # Strokes a transparent circle with a black border and a line extending
  # from its center point
  stroke do
    circle_at [300,300] :radius =&gt; 50
    line [300,300], [350, 300]
  end

  fill_and_stroke do
    # Fills and strokes a red hexagon with a black border
    polygon [100, 250], [200, 300], [300, 250],
            [300, 150], [200, 100], [100, 150]
  end

end</screen><para>This may be a bit more readable, especially the middle one, in
      which multiple paths need to be stroked. However, it still feels like
      more work than we’d really want. Wouldn’t things be nicer this
      way?</para><screen format="linespecific">Prawn::Document.generate("shapes.pdf") do
  fill_color "ff0000"

  fill_circle_at [100,100], :radius =&gt; 25

  stroke_circle_at [300,300] :radius =&gt; 50
  stroke_line [300,300], [350, 300]

  fill_and_stroke_polygon [100, 250], [200, 300], [300, 250],
                          [300, 150], [200, 100], [100, 150]
end</screen><para>This has a nice, declarative feel to it. Obviously though, we
      don’t want to define four methods for every graphics drawing operation.
      This is especially true when you think of the nature of what each of
      these would look like. Let’s take <literal moreinfo="none">stroke</literal> for
      example:</para><screen format="linespecific">def stroke_some_method(*args)
  some_method(*args)
  stroke
end</screen><para>Repeat that ad nauseam for every single drawing method, and keep
      up this pattern every time a new one is added? No way! Maybe this sort
      of repetition would be tolerated over in Java-land, but in Ruby, we can
      do better. The answer lies in dynamically interpreting method
      calls.</para><para>When you attempt to call a method that doesn’t exist in Ruby, you
      see an <phrase role="keep-together">exception raised</phrase> by
      default. However, Ruby provides a way to hook into this process and
      <phrase role="keep-together">intercept the call</phrase> before an error
      can be raised. This is done through the method <literal moreinfo="none" role="keep-together">method_missing</literal>.<indexterm id="I_indexterm3_d1e3157" significance="normal"><primary>method_missing( ) method</primary></indexterm></para><para>To give a very brief introduction to how it works, let’s take a
      quick spin in <emphasis>irb</emphasis>:</para><screen format="linespecific">&gt;&gt; def method_missing(name, *args, &amp;block)
&gt;&gt;   puts "You tried to call #{name} with #{args.inspect}"
&gt;&gt;   puts "Epic Fail!"
&gt;&gt; end
=&gt; nil
&gt;&gt; 1.fafsafs
You tried to call fafsafs with []
Epic Fail!
=&gt; nil
&gt;&gt; "kitten".foo("bar", "baz")
You tried to call foo with ["bar", "baz"]
Epic Fail!</screen><para>By including a <literal moreinfo="none">method_missing</literal>
      hook at the top level, all unknown messages get routed through our new
      method and print out our message. As you can see, the name of the
      message as well as the arguments are captured. Of course, this sort of
      global change is typically a very bad idea, and serves only as an
      introduction. But if you’re feeling <phrase role="keep-together">ambitious</phrase>, take a moment to think about
      how this technique could be used to solve the problem we’re working on
      here, before reading on.</para><para>Did you have any luck? If you did attempt this exercise, what you
      would find is that <literal moreinfo="none">method_missing</literal>
      isn’t very useful on its own. Typically, it is used to do part of a job
      and then route the work to another function. The way we do this is by
      making use of <literal moreinfo="none">Kernel#send</literal>, which
      allows us to call a method by just passing a symbol or string, <phrase role="keep-together">followed</phrase> by any arguments:<indexterm id="I_indexterm3_d1e3186" significance="normal"><primary>send( ) method, using with method_missing( )</primary></indexterm></para><screen format="linespecific">&gt;&gt; "foo".send(:reverse)
=&gt; "oof"
&gt;&gt; [1,2,3].send("join", "|")
=&gt; "1|2|3"</screen><para>Does this clue make things a bit clearer? For those who didn’t try
      to build this on their own, or if you attempted it and came up short,
      here’s how to make it all work:</para><screen format="linespecific"># Provides the following shortcuts:
#
#    stroke_some_method(*args) #=&gt; some_method(*args); stroke
#    fill_some_method(*args) #=&gt; some_method(*args); fill
#    fill_and_stroke_some_method(*args) #=&gt; some_method(*args); fill_and_stroke
#
def method_missing(id,*args,&amp;block)
  case(id.to_s)
  when /^fill_and_stroke_(.*)/
    send($1,*args,&amp;block); fill_and_stroke
  when /^stroke_(.*)/
    send($1,*args,&amp;block); stroke
  when /^fill_(.*)/
    send($1,*args,&amp;block); fill
  else
    super
  end
end</screen><para>As the documentation describes, this hook simply extracts the
      paint command out from the method call, and then sends the remainder as
      the function to execute. All arguments (including an optional block) are
      forwarded on to the real method. Then, when it <phrase role="keep-together">returns</phrase>, the specified paint method is
      called.</para><para>It’s important to note that when the patterns do not match,
      <literal moreinfo="none">super</literal> is called. This allows objects
      up the chain to do their own <literal moreinfo="none">method_missing</literal> handling, including the
      default, which raises a <literal moreinfo="none">NoMethodError</literal>. This prevents something like
      <literal moreinfo="none">pdf.the_shiny_kitty</literal> from failing
      silently, as well as the more subtle <literal moreinfo="none">pdf.fill_circle</literal>.<indexterm id="I_indexterm3_d1e3218" significance="normal"><primary>super( ) method</primary><secondary>using with method_missing</secondary></indexterm><indexterm id="I_indexterm3_d1e3223" significance="normal"><primary>NoMethodError</primary></indexterm></para><para>Although this is just a single example, it should spark your
      imagination for all the possibilities. But it also hints at the sort of
      looseness that comes with this <phrase role="keep-together">approach.
      Prawn will</phrase> happily accept <literal moreinfo="none">pdf.fill_and_stroke_start_new_page</literal> or even
      <literal moreinfo="none">pdf.stroke_stroke_stroke_line</literal> without
      complaining. Any time you use the <literal moreinfo="none" role="keep-together">method_missing</literal> hook, these are the
      trade-offs you must be willing to accept. Of course, by making your
      hooks more robust, you can get a bit more control, but that starts to
      defeat the purpose if you take it too far.</para><para>The best approach is to use <literal moreinfo="none">method_missing</literal> responsibly and with
      moderation. Be sure to avoid accidental silent failures by calling
      <literal moreinfo="none">super</literal> for any case you do not handle, and don’t
      bother using it if you want things to be ironclad. In cases where there
      is a relatively small set of methods you want to generate dynamically, a
      solution using <literal moreinfo="none">define_method</literal> might be
      preferred. That having been said, when used as a shortcut alternative to
      a less pleasant interface, <literal moreinfo="none">method_missing</literal> can be quite helpful,
      especially in cases where the messages you’ll need to accept are truly
      dynamic.</para><para>The techniques described so far combined with some of the methods
      shown in the previous chapter will get you far in building a
      domain-specific interface. We’re about to move on to other dynamic Ruby
      topics, but before we do that, we’ll cover one more cheap trick that
      leads to clean and flexible interfaces.<indexterm id="I_indexterm3_d1e3257" class="endofrange" startref="ch03_domainintsmessages" significance="normal"/><indexterm id="I_indexterm3_d1e3258" class="endofrange" startref="ch03_messages" significance="normal"/></para></sect2><sect2><title>Dual-Purpose Accessors</title><para>One thing you will notice when working with code that has an
      <literal moreinfo="none">instance_eval</literal>-based interface is that
      using ordinary setters can be ugly. Because you need to disambiguate
      between local variables and method calls, stuff like this can really
      cramp your style:<indexterm id="I_indexterm3_d1e3268" significance="normal"><primary>attribute writers in instance_eval-based
          interfaces</primary></indexterm><indexterm id="I_indexterm3_d1e3271" significance="normal"><primary>instance_eval( ) method</primary><secondary>interfaces based on, attribute writers and</secondary></indexterm><indexterm id="I_indexterm3_d1e3276" significance="normal"><primary>domain-specific interfaces, building flexible</primary><secondary>dual-purpose accessors</secondary></indexterm></para><screen format="linespecific">Prawn::Document.generate("accessors.txt") do

  self.font_size = 10
  text "The font size is now #{font_size}"

end</screen><para>It’s possible to make this look much nicer, as you can see:</para><screen format="linespecific">Prawn::Document.generate("accessors.txt") do

  font_size 10
  text "The font size is now #{font_size}"

end</screen><para>The concept here isn’t a new one; we covered it in the previous
      chapter. We can use Ruby’s default argument syntax to determine whether
      we’re supposed to be getting or setting the attribute:</para><screen format="linespecific">class Prawn::Document

  def font_size(size = nil)
    return @font_size unless size
    @font_size = size
  end

  alias_method :font_size=, :font_size

end</screen><para>As I said before, this is a relatively cheap trick with not much
      that is special to it. But the first time you forget to do it and find
      yourself typing <literal moreinfo="none">self.foo = bar</literal> in
      what is supposed to be a domain-specific interface, you’ll be sure to
      remember this technique.</para><para>One thing to note is that you shouldn’t break the normal behavior
      of setters from the outside. We use <literal moreinfo="none">alias_method</literal> here instead of <literal moreinfo="none">attr_writer</literal> to ensure down the line that there
      won’t be any difference between the following two lines of code:</para><screen format="linespecific">pdf.font_size = 16
pdf.font_size(16)</screen><para>Though not essential, this is a nice way to avoid potential
      headaches at a very low cost, so it’s a good habit to get into when
      using this technique.</para><para>When we combine all the tactics we’ve gone over so far, we’ve got
      all the essential components for building flexible domain-specific
      interfaces. Before we move on to the next topic, let’s review the main
      points to remember about flexible interface design:<indexterm id="I_indexterm3_d1e3311" significance="normal"><primary>domain-specific interfaces, building flexible</primary><secondary>guidelines for design</secondary></indexterm></para><itemizedlist><listitem><para>As mentioned in the previous chapter, using <literal moreinfo="none">instance_eval</literal> is a good base for writing a
          domain-specific interface, but has some limitations.</para></listitem><listitem><para>You can use a <literal moreinfo="none">Proc#arity</literal>
          check to provide the user with a choice between <literal moreinfo="none">instance_eval</literal> and yielding an
          object.</para></listitem><listitem><para>If you want to provide shortcuts for certain sequences of
          method calls, or dynamic generation of methods, you can use <literal moreinfo="none">method_missing</literal> along with <literal moreinfo="none">send()</literal>.</para></listitem><listitem><para>When using <literal moreinfo="none">method_missing</literal>,
          be sure to use <literal moreinfo="none">super()</literal> to pass
          unhandled calls up the chain so they can be handled properly by
          other code, or eventually raise a <literal role="keep-together" moreinfo="none">NoMethodError</literal>.</para></listitem><listitem><para>Normal attribute writers don’t work well in <literal moreinfo="none">instance_eval</literal>-based interfaces. Offer a
          dual-purpose reader/writer method, and then alias a writer to it,
          and both external and internal calls will be clear.</para></listitem></itemizedlist><para>With these tips in mind, let’s move on to another topic. It’s time
      to shift gears from per-class dynamic behavior to individual
      objects.<indexterm id="I_indexterm3_d1e3361" class="endofrange" startref="ch03_domainspecificints" significance="normal"/></para></sect2></sect1><sect1 id="I_sect13_d1e3362"><title>Implementing Per-Object Behavior</title><para>An interesting aspect of Ruby is that not only can objects have
    per-class method definitions, but they can also have per-object behaviors.
    What this means is that each and every object carries around its own
    unique identity, and that the class definition is simply the blueprint for
    the beginning of an object’s lifecycle.<indexterm class="startofrange" id="ch03_objectsperobject" significance="normal"><primary>objects</primary><secondary>implementing per-object behavior</secondary></indexterm></para><para>Let’s start with a simple <emphasis>irb</emphasis> session to
    clearly illustrate this concept:</para><screen format="linespecific">&gt;&gt; a = [1,2,3]
=&gt; [1, 2, 3]
&gt;&gt; def a.secret
&gt;&gt;   "Only this object knows the secrets of the world"
&gt;&gt; end
=&gt; nil
&gt;&gt; a.secret
=&gt; "Only this object knows the secrets of the world"
&gt;&gt; [1,2,3,4,5].secret
NoMethodError: undefined method 'secret' for [1, 2, 3, 4, 5]:Array
        from (irb):17
        from :0
&gt;&gt; [1,2,3].secret
NoMethodError: undefined method 'secret' for [1, 2, 3]:Array
        from (irb):18
        from :0</screen><para>Here, using a familiar method definition syntax, we add a special
    method called <literal moreinfo="none">secret</literal> to the array we’ve
    assigned to <literal moreinfo="none">a</literal>. The remaining examples
    show that only <literal moreinfo="none">a</literal> gets this new method
    definition. If the last one surprised you a bit, remember that most
    objects in Ruby are not immediate values, so two arrays set to <literal moreinfo="none">[1,2,3]</literal> are not the same object, even if they
    contain the same data. More concisely:</para><screen format="linespecific">&gt;&gt; [1,2,3].object_id
=&gt; 122210
&gt;&gt; a.object_id
=&gt; 159300</screen><para>So when we talk about each object having its own behavior, we mean
    exactly that here. You may be wondering at this point what uses there
    might be for such a feature. An interesting abstract example might be to
    note that class methods are actually just per-object behavior on an
    instance of the class <literal moreinfo="none">Class</literal>, but I
    think it’d be more productive to give you a concrete example to sink your
    teeth into.</para><para>We’re going to take a look at how to build a simple stubbing system
    for use in testing. In the testing chapter, I recommended
    <emphasis>flexmock</emphasis> for this purpose, and I still do, but going
    through the process of building a tiny stubbing framework will show a good
    use case for our current topic.<indexterm class="startofrange" id="ch03_testingstubbingsystem" significance="normal"><primary>testing</primary><secondary>simple stubbing system for</secondary></indexterm><indexterm class="startofrange" id="ch03_stubbingsystem" significance="normal"><primary>stubbing system, building for testing</primary></indexterm></para><para>Our goal is to create a system that will generate canned responses
    to certain method calls, without modifying their original classes. This is
    an important feature, because we don’t want our stubbed method calls to
    have a global effect during testing. Our target interface will be
    something like this:</para><screen format="linespecific">user = User.new
Stubber.stubs(:logged_in?, :for =&gt; user, :returns =&gt; true)
user.logged_in? #=&gt; true</screen><para>We’ll start with a very crude approach in <emphasis>irb</emphasis>
    to get a feel for the problem:</para><screen format="linespecific">&gt;&gt; class User; end
=&gt; nil
&gt;&gt; user = User.new
=&gt; #&lt;User:0x636b4&gt;
&gt;&gt; def user.logged_in?
&gt;&gt;   true
&gt;&gt; end
=&gt; nil
&gt;&gt; user.logged_in?
=&gt; true
&gt;&gt; another_user = User.new
=&gt; #&lt;User:0x598d0&gt;
&gt;&gt; another_user.logged_in?
NoMethodError: undefined method 'logged_in?' for #&lt;User:0x598d0&gt;
        from (irb):40
        from :0</screen><para>This is essentially the behavior we want to capture: per-object
    customization that doesn’t affect the class definition generally. Of
    course, to do this dynamically takes a little more work than the manual
    version. Our first hurdle is that the technique used in the earlier
    <literal moreinfo="none">BlankSlate</literal> example doesn’t work out of
    the box here:<indexterm id="I_indexterm3_d1e3430" significance="normal"><primary>objects</primary><secondary>per-object customization not affecting class
        definition</secondary></indexterm></para><screen format="linespecific">&gt;&gt; user.define_method(:logged_in?) { true }
NoMethodError: undefined method 'define_method' for #&lt;User:0x40ed90&gt;
        from (irb):17
        from /Users/sandal/lib/ruby19_1/bin/irb:12:in '&lt;main&gt;'</screen><para>As it turns out, each object hides its individual space for method
    definitions (called a singleton class) from plain view. However, we can
    reveal it by using a special syntax:<indexterm id="I_indexterm3_d1e3439" significance="normal"><primary>singleton class</primary></indexterm></para><screen format="linespecific">&gt;&gt; singleton = class &lt;&lt; user; self; end
=&gt; #&lt;Class:#&lt;User:0x40ed90&gt;&gt;</screen><para>My earlier clues about class methods being per-object behavior on an
    instance of <literal moreinfo="none">Class</literal> should come to mind
    here. We often use this syntax when we need to define a few class
    methods:</para><screen format="linespecific">class A
  class &lt;&lt; self
    def foo
      "hi"
    end

    def bar
      "bar"
    end
  end
end</screen><para>The possible new thing here is that <literal moreinfo="none">self</literal> can be replaced by any old object. So when
    you see <literal moreinfo="none">class &lt;&lt; user; self; end</literal>,
    what’s really going on is we’re just asking our object to give us back its
    singleton class. Once we have that in hand, we can define methods on it.
    Well, almost:<indexterm id="I_indexterm3_d1e3459" significance="normal"><primary>class &lt;&lt; obj; notation</primary></indexterm></para><screen format="linespecific">&gt;&gt; singleton.define_method(:logged_in?) { true }
NoMethodError: private method 'define_method' called for #&lt;Class:#&lt;User:0x40ed90&gt;&gt;
        from (irb):19
        from /Users/sandal/lib/ruby19_1/bin/irb:12:in '&lt;main&gt;'</screen><para>Because what we’re doing is not exactly business as usual, Ruby is
    throwing some red flags up reminding us to make sure we know what we’re
    doing. But because we do, we can use <literal moreinfo="none">send</literal> to bypass the access controls:</para><screen format="linespecific">&gt;&gt; singleton.send(:define_method, :logged_in?) { true }
=&gt; #&lt;Proc:0x3fc1f4@(irb):20 (lambda)&gt;
&gt;&gt; user.logged_in?
=&gt; true
&gt;&gt; User.new.logged_in?
NoMethodError: undefined method 'logged_in?' for #&lt;User:0x3f62f4&gt;
        from (irb):22
        from /Users/sandal/lib/ruby19_1/bin/irb:12:in '&lt;main&gt;'</screen><para>Perfect! Now our dynamic approach matches our manual one, and we can
    proceed to building a <literal moreinfo="none">Stubber</literal> module.
    We’ll be a bit flexible and assume that any stubbed method can take any
    number of arguments, rather than assuming a certain amount or none at all.
    Beyond that, the definition is just a compilation of what we’ve done so
    far:</para><screen format="linespecific">module Stubber
  extend self

  def stubs(method, options={})
    singleton(options[:for]).send(:define_method, method) do |*a|
      options[:returns]
    end
  end


  def singleton(obj)
    class &lt;&lt; obj; self; end
  end
end</screen><para>With this simple implementation, we’re in business, doing everything
    we set out for in the beginning:</para><screen format="linespecific">&gt;&gt; user = User.new
=&gt; #&lt;User:0x445bec&gt;
&gt;&gt; Stubber.stubs(:logged_in?, :for =&gt; user, :returns =&gt; true)
=&gt; #&lt;Proc:0x43faa8@(irb):28 (lambda)&gt;
&gt;&gt; user.logged_in?
=&gt; true
&gt;&gt; User.new.logged_in?
NoMethodError: undefined method 'logged_in?' for #&lt;User:0x439fe0&gt;
        from (irb):40
        from /Users/sandal/lib/ruby19_1/bin/irb:12:in '&lt;main&gt;'</screen><para>Beyond what we’ve already discussed, another important thing to
    remember is that the block passed to <literal moreinfo="none">define_method()</literal> is a closure, which allows us to
    access the local variables of the enclosing scope. This is why we can pass
    the return value as a parameter to <literal moreinfo="none">Stubber.stubs()</literal> and have it returned from our
    dynamically defined method.<indexterm id="I_indexterm3_d1e3491" significance="normal"><primary>closures</primary></indexterm><indexterm id="I_indexterm3_d1e3494" significance="normal"><primary>define_method( )</primary><secondary>closure block passed to</secondary></indexterm></para><para>This is a general feature of <literal moreinfo="none">define_method</literal>, and is not restricted to
    singleton objects. Here’s a quick demonstration to emphasize this
    point:</para><screen format="linespecific">class Statistics
  def self.stat(attribute, value)
    define_method(attribute) { value }
  end

  stat :foo, :bar
  stat :baz, :quux
end

stats = Statistics.new
stats.foo #=&gt; :bar
stats.baz #=&gt; :quux</screen><para>Be sure to remember this about <literal moreinfo="none">define_method</literal>. It is pretty much the only clean
    way to dynamically define a method with a custom return value.</para><para>Returning to the core topic, we see that <literal moreinfo="none">Stubber</literal>’s main trick is that it makes use of
    customized behaviors for individual objects. However, to do this, we need
    to <phrase role="keep-together">temporarily</phrase> jump into the scope
    of the special space reserved for this purpose in our object, so that we
    can pull back a reference to it. This is what the whole <literal moreinfo="none">class &lt;&lt; obj; self; end</literal> is about. Once we
    have this object, we can dynamically define methods on it using <literal moreinfo="none">define_method()</literal> as we would in a class
    definition, but we need to access it via <literal moreinfo="none">send()</literal> because this method is made private on
    singleton classes. Once we do this, we take advantage of the fact that
    <literal moreinfo="none">define_method()</literal>’s block argument is a
    closure with access to the enclosing <literal moreinfo="none">scope</literal>’s local
    variables. We set the return value this way, and complete our task of
    per-object stubbing.<indexterm id="I_indexterm3_d1e3535" significance="normal"><primary>class &lt;&lt; obj; notation</primary></indexterm><indexterm id="I_indexterm3_d1e3538" class="endofrange" startref="ch03_testingstubbingsystem" significance="normal"/></para><para>Although this is only a single example, it demonstrates a number of
    key concepts about per-object behavior in Ruby:<indexterm id="I_indexterm3_d1e3541" significance="normal"><primary>objects</primary><secondary>implementing per-object behavior</secondary><tertiary>key concepts</tertiary></indexterm></para><itemizedlist><listitem><para>Using per-object behavior usually makes the most sense when you
        don’t want to define something at the per-class level.</para></listitem><listitem><para>Objects in Ruby may have individually customized behaviors that
        can replace, supplement, or amend the functionality provided by their
        class definitions.</para></listitem><listitem><para>Per-object behavior (known as singleton methods), can be
        implemented by gaining access to the singleton class of an object
        using the <literal moreinfo="none">class &lt;&lt; obj</literal>
        notation.</para></listitem><listitem><para><literal moreinfo="none">define_method</literal> is made private
        on singleton classes, so <literal moreinfo="none">send()</literal> is
        needed to utilize it.</para></listitem><listitem><para>When implementing nondynamic per-object behavior, the familiar
        <literal moreinfo="none">def obj.some_method</literal> syntax may be
        used.</para></listitem></itemizedlist><para>All that we’ve discussed so far about per-object behavior is sort of
    a special case of a more general topic. Ruby’s open class system allows us
    to amend and modify the behavior of pretty much everything we can imagine,
    in a number of ways. This is one of the fairly unique aspects of Ruby, so
    there is a whole lot we can discuss here. We’ll start with an anecdote and
    then move into some more focused details.<indexterm id="I_indexterm3_d1e3578" class="endofrange" startref="ch03_stubbingsystem" significance="normal"/><indexterm id="I_indexterm3_d1e3579" class="endofrange" startref="ch03_objectsperobject" significance="normal"/></para></sect1><sect1 id="I_sect13_d1e3580"><title>Extending and Modifying Preexisting Code</title><para>When I introduce Ruby to new students, my first example is often
    meant to shake them up a little. It is relatively unremarkable, but to
    those who have not worked in languages with an open class system before,
    it can be quite alarming:<indexterm id="I_indexterm3_d1e3585" significance="normal"><primary>classes</primary><secondary>open class system</secondary></indexterm><indexterm class="startofrange" id="ch03_extendingmodifyingcode" significance="normal"><primary>extending and modifying existing code</primary></indexterm></para><screen format="linespecific">class Fixnum

  def +(other)
    42
  end

end</screen><para>The implications typically don’t sink in until I fire up
    <emphasis>irb</emphasis>:</para><screen format="linespecific">&gt;&gt; 2 + 2
=&gt; 42</screen><para>This demonstration is typically followed by a firm “never do this”
    reminder, but I continue to use it because it opens people’s eyes to just
    how different Ruby is from most other languages. The standard response to
    this example is a flurry of questions about how Rubyists manage to make
    heads or tails of things when people can go all willy-nilly with extending
    classes as they see fit. That’s what this section is all about.</para><para>We’re going to talk about two related but somewhat distinct topics
    here. The first is extending Ruby classes with new behaviors by reopening
    classes; the second is actually modifying existing behaviors to fit new
    requirements. What separates the two is primarily the level of
    controversy, and hence the necessary level of care.</para><para>Because adding new functionality is the less dangerous of the two,
    we’ll start with that and go over some of the specifics.</para><sect2><title>Adding New Functionality</title><para>In <xref linkend="ch01" xrefstyle="chap-num-title"/>, I mentioned
      and made use of a small extension to <literal moreinfo="none">Test::Unit</literal> that dynamically defines test
      methods for us. As previously mentioned, we’ve borrowed this
      functionality from the granddaddy of Ruby extensions, ActiveSupport. We
      glossed over the implementation details before, but now that we’re on
      the topic, this serves as a good example of the sorts of things you can
      accomplish by extending preexisting classes. We still don’t need to
      worry about how it works; the focus is on how it extends <literal moreinfo="none">TestCase</literal>:<indexterm class="startofrange" id="ch03_classesextending" significance="normal"><primary>classes</primary><secondary>extending existing Ruby classes</secondary></indexterm><indexterm id="I_indexterm3_d1e3626" significance="normal"><primary>TestCase class</primary><secondary>extending</secondary></indexterm><indexterm class="startofrange" id="ch03_extendincode" significance="normal"><primary>extending and modifying existing code</primary><secondary>adding new functionality</secondary></indexterm></para><screen format="linespecific">module Test::Unit
  class TestCase

    def self.must(name, &amp;block)
      test_name = "test_#{name.gsub(/\s+/,'_')}".to_sym
      defined = instance_method(test_name) rescue false
      raise "#{test_name} is already defined in #{self}" if defined
      if block_given?
        define_method(test_name, &amp;block)
      else
        define_method(test_name) do
          flunk "No implementation provided for #{name}"
        end
      end
    end

  end
end</screen><para>To recap, the purpose of the <literal moreinfo="none">must()</literal> method is to allow you to write your
      test cases a bit more cleanly. Here’s an example from a board game I’ve
      been working on:</para><screen format="linespecific">  class TestStone &lt; Test::Unit::TestCase
    def setup
      @board = Pressman::Board.new
      @stone = Pressman::Stone.new(:black, :board    =&gt; @board,
                                           :position =&gt; [3,3] )
    end

    must "have a color" do
      assert_equal :black, @stone.color
    end

    must "have a default status of active" do
      assert_equal :active, @stone.status
    end

    must "be able to deactivate" do
      @stone.deactivate
      assert_equal :inactive, @stone.status
    end
  end</screen><para>Without this extension, you would need to write the full test
      method names out in the traditional way:</para><screen format="linespecific">  class TestStone &lt; Test::Unit::TestCase
    def setup
      @board = Pressman::Board.new
      @stone = Pressman::Stone.new(:black, :board    =&gt; @board,
                                           :position =&gt; [3,3] )
    end

    def test_must_have_a_color
      assert_equal :black, @stone.color
    end

    def test_must_be_active_by_default
      assert_equal :active, @stone.status
    end

    def test_must_be_able_to_deactivate
      @stone.deactivate
      assert_equal :inactive, @stone.status
    end
  end</screen><para>Although this code might be a bit more conceptually simple, it is
      also a bit less readable and doesn’t have the same shortcuts that
      <literal moreinfo="none">must()</literal> provides. For example, if you
      just write a single line like this:</para><screen format="linespecific">must "do something eventually"</screen><para>The extension will create a failing test for you. For those
      familiar with RSpec, this is similar to the pending test functionality
      you’d find there. Of course, by tweaking <literal moreinfo="none">Test::Unit</literal> a bit for our own needs, we can
      focus on adding only the functionality we’re missing, rather than
      jumping ship and moving to a whole other system. This is a key benefit
      of Ruby’s open class system.</para><para>From what we’ve seen so far, it seems like adding functionality to
      a class definition is as easy as defining a new class. It uses the same
      syntax without any additional overhead. However, that is not to say it
      is without dangers.</para><para>If you can extend predefined objects for your own needs, so can
      everyone else, including any of the libraries you may depend on. Though
      we’ll discuss safe techniques for combining partial definitions a little
      later, the technique shown here of simply opening up a class and
      defining a new method can result in naming clashes.</para><para>Consider two fictional units libraries, one of which converts
      things like <literal moreinfo="none">12.in</literal> and <literal moreinfo="none">15.ft</literal> into meters. We’ll call this
      <filename moreinfo="none">metrics_conversions.rb</filename>:</para><screen format="linespecific">class Numeric
  def in
    self * 0.0254
  end

  def ft
    self.in * 12
  end
end</screen><para>Our other library converts them into PDF points (1/72 of an inch).
      We’ll call this <filename moreinfo="none">pdf_conversions.rb</filename>:</para><screen format="linespecific">class Numeric
  def in
    self * 72
  emd

  def ft
    self.in * 12
  end
end</screen><para>If we load both libraries in, which one gets used? Let’s ask
      <emphasis>irb</emphasis>:</para><screen format="linespecific">&gt;&gt; require "metrics_conversions"
=&gt; true
&gt;&gt; 1.in
=&gt; 0.0254
&gt;&gt; require "pdf_conversions"
=&gt; true
&gt;&gt; 1.in
=&gt; 72</screen><para>As you can see, whatever code is loaded last takes precedence. The
      way we have written it, the old definitions are completely clobbered and
      there is no easy way to recover them.</para><para>Because we’d almost never want two competing units systems loaded
      at the same time, it’d be better to see an error rather than a silent
      failure here. We can do that with the PDF conversion code and see what
      it looks like:</para><?dbfo-need height=”1in”
?><screen format="linespecific">class Numeric

  [:in, :ft].each do |e|
    if instance_methods.include?(e)
      raise "Method '#{e}' exists, PDF Conversions will not override!"
    end
  end

  def in
    self * 72
  end

  def ft
    self.in * 12
  end

end</screen><para>Loaded in on its own, this code runs without issue:</para><screen format="linespecific">&gt;&gt; require "pdf_conversions"
=&gt; true
&gt;&gt; 1.in
=&gt; 72
&gt;&gt; 1.ft
=&gt; 864</screen><para>But when we revisit the original name clash problem, we have a
      much more explicit indicator of this issue:</para><screen format="linespecific">&gt;&gt; require "metrics_conversions"
=&gt; true
&gt;&gt; require "pdf_conversions"
RuntimeError: Method 'in' exists, PDF Conversions will not override!
        ...</screen><para>Of course, if we do not modify
      <filename moreinfo="none">metrics_conversions.rb</filename> as well, it will silently
      override <filename moreinfo="none">pdf_conversions.rb</filename>. The ideal situation is
      for both libraries to use this technique, <phrase role="keep-together">because</phrase> then, regardless of the order in
      which they are required, the incompatibility <phrase role="keep-together">between</phrase> dependencies will be quickly
      spotted.</para><para>It is worth mentioning that it is possible for the library that is
      loaded first to detect the second library’s attempt to override its
      definitions and act upon that, but this is generally considered
      aggressive and also results in fairly convoluted code, so it’s better to
      address your own problems than the problems of others when it comes to
      extending an object’s functionality.</para><para>So far, we’ve been talking about adding new functionality and
      dealing with accidental clashes. However, there are going to be times
      when you intentionally want to modify other code, while preserving some
      of its initial functionality. Ruby provides a number of ways to do that,
      so let’s examine a few of them and weigh their risks and
      benefits.<indexterm id="I_indexterm3_d1e3727" class="endofrange" startref="ch03_extendincode" significance="normal"/><indexterm id="I_indexterm3_d1e3728" class="endofrange" startref="ch03_classesextending" significance="normal"/></para></sect2><?dbfo-need height=”1in”
?><sect2><title>Modification via Aliasing</title><para>We’ve used <literal moreinfo="none">alias_method</literal> before
      for the purpose of making a new name point at an old method. This of
      course is where the feature gets its name: allowing you to create
      aliases for your methods.<indexterm class="startofrange" id="ch03_aliasing" significance="normal"><primary>aliasing</primary><secondary>modification via</secondary></indexterm><indexterm class="startofrange" id="ch03_extendmodviaaliasing" significance="normal"><primary>extending and modifying existing code</primary><secondary>modification via aliasing</secondary></indexterm></para><para>But another interesting aspect of <literal moreinfo="none">alias_method</literal> is that it doesn’t simply create
      a new name for a method—it makes a copy of it. The best way to show what
      this means is through a trivial code example:<indexterm id="I_indexterm3_d1e3753" significance="normal"><primary>aliasing</primary><secondary>alias_method( )</secondary></indexterm></para><screen format="linespecific"># define a method
class Foo
  def bar
    "baz"
  end
end

f = Foo.new
f.bar #=&gt; "baz"


# Set up an alias
class Foo
  alias_method :kittens, :bar
end

f.kittens #=&gt; "baz"

# redefine the original method
class Foo
  def bar
    "Dog"
  end
end

f.bar      #=&gt; "Dog"
f.kittens  #=&gt; "baz"</screen><para>As you can see here, even when we override the original method
      <literal moreinfo="none">bar()</literal>, the alias <literal moreinfo="none" role="keep-together">kittens()</literal> still points at
      the original definition. This turns out to be a tremendously useful
      feature.</para><para>Because I like to keep contrived examples to a minimum, we’re
      going to take a look at a real use of this technique in code that we use
      every day, RubyGems.<indexterm id="I_indexterm3_d1e3770" significance="normal"><primary>RubyGems</primary></indexterm></para><para>When RubyGems is loaded, it provides access to the libraries
      installed through its package manager. However, we typically don’t need
      to load these packages through some alternative interface, we just use
      <literal moreinfo="none">Kernel#require</literal>, as we do when we’re
      loading in our own application files. The reason this is possible is
      because RubyGems patches <literal moreinfo="none">Kernel#require</literal> using the exact technique we’ve
      been talking about here. This is what the code looks like for
      <filename moreinfo="none">custom_require.rb</filename>:<indexterm id="I_indexterm3_d1e3784" significance="normal"><primary>Kernel#require method</primary></indexterm></para><screen format="linespecific">module Kernel

  ##
  # The Kernel#require from before RubyGems was loaded.

  alias_method :gem_original_require, :require

  def require(path) # :doc:
    gem_original_require path
  rescue LoadError =&gt; load_error
    if load_error.message =~ /#{Regexp.escape path}\z/ and
       spec = Gem.searcher.find(path) then
      Gem.activate(spec.name, "= #{spec.version}")
      gem_original_require path
    else
      raise load_error
    end
  end

end</screen><para>This code first makes a copy of the original
      <literal moreinfo="none">require</literal> method, then begins to define its enhanced
      one. It first tries to call the original method to see whether the
      requested file can be loaded that way. If it can, then it is exactly
      equivalent to before RubyGems was loaded, and no further processing is
      needed.</para><para>However, if the original require fails to find the requested
      library, the error it raises is rescued, and then the RubyGems code goes
      to work looking for a matching gem to activate and add to the loadpath.
      If it finds one, it then goes back to the original
      <literal moreinfo="none">require</literal>, which will work this time around because the
      necessary files have been added to the path.</para><para>If the code fails to find a gem that can be loaded, the original
      <literal moreinfo="none">LoadError</literal> is raised. So this means
      that in the end, it reverts to the same failure condition as the
      original <literal moreinfo="none">require</literal> method, making it completely
      invisible to the user.</para><para>This is a great example of responsible modification to a
      preexisting method. This code does not change the signature of the
      original method, nor does it change the possible return values or
      failure states. All it does is add some new intermediate functionality
      that will be transparent to the user if it is not needed.</para><para>However, this concept of copying methods via <literal moreinfo="none">alias_method</literal> might seem a bit foreign to some
      folks. It also has a bit of a limitation, in that you need to keep
      coming up with new aliases, as aliases are subject to collision just the
      same as ordinary methods are.<indexterm id="I_indexterm3_d1e3815" significance="normal"><primary>aliasing</primary><secondary>aliases, collisions in</secondary></indexterm></para><para>For example, although this code works fine:</para><screen format="linespecific">class A

  def count
    "one"
  end

  alias_method :one, :count

  def count
    "#{one} two"
  end

  alias_method :one_and_two, :count

  def count
    "#{one_and_two} three"
  end

end

A.new.count #=&gt; "one two three"</screen><para>if we rewrote it this way, we’d blow the stack:</para><screen format="linespecific">class A

  def count
    "one"
  end

  alias_method :old_count, :count

  def count
    "#{old_count} two"
  end

  alias_method :old_count, :count

  def count
    "#{old_count} three"
  end

end</screen><para>Accidentally introducing infinite recursion by aliasing an old
      method twice to the same name is definitely not fun. Although this
      problem is rarer than you might think, it’s important to know that there
      is a way around it.<indexterm id="I_indexterm3_d1e3830" class="endofrange" startref="ch03_aliasing" significance="normal"/><indexterm id="I_indexterm3_d1e3831" class="endofrange" startref="ch03_extendmodviaaliasing" significance="normal"/></para></sect2><sect2><title>Per-Object Modification</title><para>If we move our modifications from the per-class level to the
      per-object level, we end up with a pretty nice solution that gets rid of
      aliasing entirely, and simply leverages Ruby’s ordinary method
      resolution path. Here’s how we’d do it:<indexterm id="I_indexterm3_d1e3838" significance="normal"><primary>objects</primary><secondary>modifying</secondary></indexterm><indexterm id="I_indexterm3_d1e3843" significance="normal"><primary>extending and modifying existing code</primary><secondary>per-object modification</secondary></indexterm></para><screen format="linespecific">class A
  def count
    "one"
  end
end

module AppendTwo
  def count
    "#{super} two"
  end
end

module AppendThree
  def count
    "#{super} three"
  end
end

a = A.new
a.extend(AppendTwo)
a.extend(AppendThree)
a.count #=&gt; "one two three"</screen><para>Here, we have mixed two modules in an instance of <literal moreinfo="none">A</literal>, each of them relying on a call to <literal moreinfo="none">super()</literal>. Each method redefinition gets to use
      the same name, so we don’t need to worry about naming clashes. Each call
      to <literal moreinfo="none">super</literal> goes one level higher, until it reaches the
      top-level instance method as defined in the class.<indexterm id="I_indexterm3_d1e3861" significance="normal"><primary>super( ) method</primary></indexterm></para><para>Provided that all the code used by your application employs this
      approach instead of aliased method chaining, you end up with two main
      benefits: a pristine original class and no possibility for collisions.
      Because the amended functionality is included at the instance level,
      rather than in the class definition, you don’t risk breaking other
      people’s code as easily, either.</para><para>Note that not every single object can be meaningfully extended
      this way. Any objects that do not allow you to access their singleton
      space cannot take advantage of this technique. This mostly applies to
      things that are immediate values, such as numbers and symbols. But more
      generally, if you cannot use a call to <literal moreinfo="none">new()</literal> to construct your object, chances are
      that you won’t be able to use these tricks. In those cases, you’d need
      to revert to aliasing.<indexterm id="I_indexterm3_d1e3871" significance="normal"><primary>new( ) method, object modification and</primary></indexterm></para><para>Even with this limitation, you can get pretty far with this
      approach. I don’t want to end the section without one more practical
      example, so we’ll look at a fun trick that earlier versions of Ruport
      did to manage a memory consumption issue in
      <literal moreinfo="none">PDF::Writer</literal>.<indexterm id="I_indexterm3_d1e3879" significance="normal"><primary>Ruport</primary><secondary>managing memory consumption issue in
          PDF::Writer</secondary></indexterm><indexterm id="I_indexterm3_d1e3884" significance="normal"><primary>PDF::Writer, managing memory consumption issue</primary></indexterm></para><para>Back before I maintained the Ruby PDF project, it went through a
      couple years of being relatively unsupported. However, when I ran into
      problems with it, Austin Ziegler was often willing to help me find
      workarounds for my own needs, even if he wasn’t able to find the time to
      get them into a maintenance release for
      <literal moreinfo="none">PDF::Writer</literal>.</para><para>One such fix resolved a memory consumption issue by setting up a
      hook for <literal moreinfo="none" role="keep-together">transaction_simple</literal> in <literal moreinfo="none">PDF::Writer</literal>. I won’t go into the details of
      how this works, but here is the module that implements it:<indexterm id="I_indexterm3_d1e3900" significance="normal"><primary>transaction_simple( ), hook in PDF::Writer</primary></indexterm></para><?dbfo-need height=”1in”
?><screen format="linespecific">module PDFWriterMemoryPatch #:nodoc:
  unless self.class.instance_methods.include?("_post_transaction_rewind")
    def _post_transaction_rewind
      @objects.each { |e| e.instance_variable_set(:@parent,self) }
    end
  end
end</screen><para>When people use Ruport, they use <literal moreinfo="none">PDF::Writer</literal>
      indirectly through the object we instantiate for them. Because of this,
      it was easy to use the techniques described in this section. The
      following code should look similar to our earlier abstract
      examples:<indexterm id="I_indexterm3_d1e3912" significance="normal"><primary>extend( ) method</primary><secondary>using in per-object modification</secondary></indexterm></para><screen format="linespecific">class Ruport::Formatter::PDF

  # other implementation details omitted.

  def pdf_writer
    @pdf_writer ||= PDF::Writer.new( :paper       =&gt; paper_size || "LETTER",
                                     :orientation =&gt; paper_orientation || :portrait)
    @pdf_writer.extend(PDFWriterMemoryPatch)
  end
end</screen><para>This code dynamically fixed an issue for Ruport users without
      making a global change that might conflict with other patches. Of
      course, it was no substitute for fixing the issue at its source, which
      eventually did happen, but it was a good stopgap procedure that made our
      users happy. When used appropriately, the power to resolve issues in
      other codebases whether or not you have direct access to the original
      code can really come in handy.</para><para>Here are the key points to remember from this section:<indexterm id="I_indexterm3_d1e3923" significance="normal"><primary>extending and modifying existing code</primary><secondary>summary of key points</secondary></indexterm></para><itemizedlist><listitem><para>All classes in Ruby are open, which means that object
          definitions are never finalized, and new behaviors can be added at
          runtime.</para></listitem><listitem><para>To avoid clashes, conditional statements utilizing reflective
          features such as <literal moreinfo="none">instance_methods</literal>
          and friends can be used to check whether a method is already defined
          before overwriting it.</para></listitem><listitem><para>When intentionally modifying code, <literal moreinfo="none">alias_method</literal> can be used to make a copy of
          the original method to fall back on.</para></listitem><listitem><para>Whenever possible, per-object behavior is preferred. The
          <literal moreinfo="none">extend()</literal> method comes in handy
          for this purpose.</para></listitem></itemizedlist><para>So far, we’ve talked about extending objects others have created,
      as well as handling dynamic calls to objects we’ve created ourselves.
      But we can take this a step further by noticing that <literal moreinfo="none">Class</literal> and <literal moreinfo="none">Module</literal> are objects themselves, and as such,
      can be dynamically generated and molded to our needs.<indexterm id="I_indexterm3_d1e3958" class="endofrange" startref="ch03_extendingmodifyingcode" significance="normal"/></para></sect2></sect1><sect1 id="I_sect13_d1e3959"><title>Building Classes and Modules Programmatically</title><para>When I first started to get into higher-level Ruby, one of the most
    exciting finds was <emphasis>why the lucky stiff</emphasis>’s tiny web
    framework, Camping. This little package was packed with all sorts of wild
    techniques I had never seen before, including a way to write controllers
    to handle URL routing that just seemed out of this world:<indexterm id="I_indexterm3_d1e3967" significance="normal"><primary>URL routing, controllers to handle</primary></indexterm><indexterm id="I_indexterm3_d1e3970" significance="normal"><primary>controllers handling URL routing</primary></indexterm><indexterm id="I_indexterm3_d1e3973" significance="normal"><primary>Camping module</primary></indexterm><indexterm class="startofrange" id="ch03_modulesprogramming" significance="normal"><primary>modules</primary><secondary>building programmatically</secondary></indexterm><indexterm class="startofrange" id="ch03_classesprogramming" significance="normal"><primary>classes</primary><secondary>building programmatically</secondary></indexterm></para><screen format="linespecific">module Camping::Controllers

  class Edit &lt; R '/edit/(\d+)'
     def get(id)
       # ...
     end
  end

end</screen><para>It didn’t even occur to me that such things could be syntactically
    possible in Ruby, but upon seeing how it worked, it all seemed to make
    sense. We’re not going to look at the real implementation here, but I
    can’t resist pulling back the curtain just a little so that you can see
    the basic mechanics of how something like this might work.</para><para>The key secret here is that <literal moreinfo="none">R</literal> is
    actually just a method, <literal moreinfo="none">Camping::Controllers::R()</literal>. This method happens
    to return a class, so that means you can inherit from it. Obviously, there
    are a few more tricks involved, as the class you inherit from would need
    to track its children, but we’ll get to those topics later.</para><para>For now, let’s start with a simple example of how parameterized
    subclassing might work, and then move on to more examples of working with
    anonymous classes and modules in general.<indexterm id="I_indexterm3_d1e4000" significance="normal"><primary>parameterized subclassing</primary></indexterm><indexterm id="I_indexterm3_d1e4003" significance="normal"><primary>subclassing, parameterized</primary></indexterm></para><para>First, we need a method that returns some classes. We’ll call it
    <literal moreinfo="none">Mystery()</literal>:</para><screen format="linespecific">  def Mystery(secret)
    if secret == "chunky bacon"
      Class.new do
        def message
          "You rule!"
        end
      end
    else
      Class.new do
        def message
          "Don't make me cry"
        end
      end
    end
  end</screen><para>Notice here that we call <literal moreinfo="none">Class.new()</literal> with a block that serves as its
    class definition. New anonymous classes are generated on every call, which
    means they’re basically throw-away here. That is, until we make use of
    them via subclassing:<indexterm id="I_indexterm3_d1e4018" significance="normal"><primary>anonymous classes</primary><secondary>generation by calls to Class.new( )</secondary></indexterm><indexterm id="I_indexterm3_d1e4023" significance="normal"><primary>Class.new( ) method</primary></indexterm></para><screen format="linespecific">class Win &lt; Mystery "chunky bacon"

  def who_am_i
    "I am win!"
  end

end

class EpicFail &lt; Mystery "smooth ham"

  def who_am_i
    "I am teh fail"
  end

end</screen><para>Now, when we build up some instances, you can see what all of this
    bought us:</para><screen format="linespecific">a = Win.new
a.message  #=&gt; "You rule!"
a.who_am_i #=&gt; "I am win!"

b = EpicFail.new
b.message  #=&gt; "Don't make me cry"
b.who_am_i #=&gt; "I am teh fail"</screen><para>Even though this example doesn’t really do anything useful on its
    own, the key concepts are still ripe for the picking. We can see that
    <literal moreinfo="none">Mystery()</literal> conditionally chooses which
    class to inherit from. Furthermore, the classes generated by <literal moreinfo="none">Mystery()</literal> are anonymous, meaning they don’t have
    some constant identifier out there somewhere, and that the <phrase role="keep-together">method</phrase> is actually generating class objects,
    not just returning references to preexisting definitions. Finally, we can
    see that the subclasses behave ordinarily, in the sense that you can add
    custom functionality to them as needed.<indexterm id="I_indexterm3_d1e4044" significance="normal"><primary>anonymous classes</primary><secondary>defined</secondary></indexterm></para><para>When you put all of these ideas together, you might already have
    plans for how you could make use of this technique. Then again, it can’t
    hurt to go over some more real-world code.<indexterm id="I_indexterm3_d1e4051" significance="normal"><primary>Fatty, Ruport 2.0</primary></indexterm><indexterm id="I_indexterm3_d1e4054" significance="normal"><primary>Ruport</primary><secondary>abstract formatting system (Fatty), Ruport 2.0</secondary></indexterm></para><para>We’re going to do a quick walk-through of the abstract formatting
    system at the heart of Ruport 2.0, called Fatty.<footnote><para>Format abstraction toolkit-ty. See <ulink url="http://github.com/sandal/fatty"/>.</para></footnote> Despite the name, the implementation is quite slim and
    fairly easy to explain.</para><para>The main thing this library does is cleanly split out
    format-specific code, while handling parameter passing and validations. A
    simple example of using Fatty to just print out a greeting to someone in
    PDF and plain text might look like this:</para><screen format="linespecific">options = { :first_name =&gt; "Chenoa", :last_name  =&gt; "Siegenthaler" }
MyReport.render_file("foo.pdf", options)
puts MyReport.render(:txt, options)</screen><para>We have support for a nonmagical interface, which—even without
    seeing the underlying implementation—shouldn’t surprise anyone:</para><screen format="linespecific">class MyReport &lt; Fatty::Formatter
  module Helpers
    def full_name
      "#{params[:first_name]} #{params[:last_name]}"
    end
  end

  class Txt &lt; Fatty::Format
    include MyReport::Helpers

     def render
      "Hello #{full_name} from plain text"
     end
  end

  # use a custom Fatty::Format subclass for extra features
  class PDF &lt; Prawn::FattyFormat
    include MyReport::Helpers

    def render
      doc.text "Hello #{full_name} from PDF"
      doc.render
    end
  end

  formats.update(:txt =&gt; Txt, :pdf =&gt; PDF)
end</screen><para>This looks almost entirely like ordinary Ruby subclassing and module
    inclusion. The only tricky thing might be the <literal moreinfo="none">formats()</literal> class method, but it just points at a
    hash that links file extensions to the classes that handle them.<indexterm id="I_indexterm3_d1e4080" significance="normal"><primary>Fatty::Formatter class</primary></indexterm><indexterm id="I_indexterm3_d1e4083" significance="normal"><primary>format( ) method</primary></indexterm></para><para>All in all, this doesn’t look too bad. But it turns out that we can
    clean up the interface substantially if we use a bit of dynamic
    creativity. The following code is functionally equivalent to what you’ve
    just seen:</para><screen format="linespecific">class MyReport &lt; Fatty::Formatter
  required_params :first_name, :last_name

  helpers do
    def full_name
      "#{params[:first_name]} #{params[:last_name]}"
    end
  end

  format :txt do
    def render
      "Hello #{full_name} from plain text"
    end
  end
<?dbfo-need height=”1in”
?>
  format :pdf, :base =&gt; Prawn::FattyFormat do
    def render
      doc.text "Hello #{full_name} from PDF"
      doc.render
    end
  end

end</screen><para>Our class definitions have been transformed into a domain-specific
    interface for format abstraction. Aside from having nicer names for things
    and a more pleasant syntax, we have gained some side benefits. We no
    longer need to manually map file extensions to class names: the <literal moreinfo="none">format()</literal> method handles that for us. We also
    don’t need to manually include our helper module; that is taken care of as
    well. As these are the two things that fit well with this topic, let’s
    take a look at how both of them are handled.</para><para>First, we’ll take a look at the <literal moreinfo="none">format()</literal> helper, which is a simple
    one-liner:</para><screen format="linespecific">def format(name, options={}, &amp;block)
  formats[name] = Class.new(options[:base] || Fatty::Format, &amp;block)
end</screen><para>When this class method is called with just a block, it generates an
    anonymous subclass of <literal moreinfo="none">Fatty::Format</literal>,
    and then stores this subclass keyed by extension name in the <literal moreinfo="none" role="keep-together">formats</literal> hash. In most
    cases, this is enough to do the trick. However, sometimes you will want to
    inherit from a base class that implements some additional helpers, as we
    did with <literal role="keep-together" moreinfo="none">Prawn::FattyFormat</literal>. This
    is why <literal moreinfo="none">options[:base]</literal> is checked first.
    This one line of code with its two possible cases covers how the class
    definitions are created and stored.</para><para>We can now turn our eyes to the <literal moreinfo="none">helpers()</literal> method, which is another one-liner.
    This one has two possible uses as well, but we showed only one in our
    example:</para><screen format="linespecific">def helpers(helper_module=nil, &amp;block)
  @helpers = helper_module || Module.new(&amp;block)
end</screen><para>As you can see here, modules can also be built up anonymously using
    a block. This code gives the user a choice between doing that or providing
    the name of a module like this:</para><screen format="linespecific">class MyReport &lt; Fatty::Formatter

  helpers MyHelperModule

  #...
end</screen><para>Of course, the more interesting case is when you use the block form,
    but only marginally so. The real work happens in <literal moreinfo="none">render()</literal>:</para><?dbfo-need height=”1in”
?><screen format="linespecific">def render(format, params={})
  validate(format, params)

  format_obj = formats[format].new  <co id="callout_1" linkends="callout_1"/>
  format_obj.extend(@helpers) if @helpers <co id="callout_2" linkends="callout_2"/>
  format_obj.params = params
  format_obj.validate
  format_obj.render
end</screen><para>I’ve marked the two lines we’re interested in:<indexterm id="I_indexterm3_d1e4145" significance="normal"><primary>anonymous classes</primary><secondary>looking up by extension name</secondary></indexterm></para><calloutlist><callout arearefs="callout_1"><para>This line uses the <literal moreinfo="none">formats</literal> hash to look up
        our anonymous class by extension name.</para></callout><callout arearefs="callout_2"><para>This line mixes in our helper module, whether it’s a reference
        to an explicitly defined module or, as in our example, a block that
        defines the anonymous module’s body.</para></callout></calloutlist><para>The rest of the method is fairly self-explanatory but
    inconsequential. It was the dynamic class/module creation we were
    interested in—the rest is just mundane detail particular to Fatty’s
    implementation.</para><para>With just a few lines of code, we’ve been able to show just how
    powerful Ruby is when you programmatically generate higher-level objects
    such as classes and modules. In this particular example, we’ve used this
    technique for interface cleanup and the associated organizational
    benefits. You may find a lot of other uses, or none at all, depending on
    your work.</para><para>Like with many other concepts in this chapter, we’ve truly been
    cooking with gas here. Let’s go over a few tips to help you avoid getting
    burned, then hit one more short topic before finishing up:<indexterm id="I_indexterm3_d1e4166" significance="normal"><primary>modules</primary><secondary>building programmatically</secondary><tertiary>tips for</tertiary></indexterm><indexterm id="I_indexterm3_d1e4173" significance="normal"><primary>classes</primary><secondary>building programmatically</secondary><tertiary>tips for</tertiary></indexterm></para><itemizedlist><listitem><para>Classes and modules can be instantiated like any other object.
        Both constructors accept a block that can be used to define methods as
        needed.</para></listitem><listitem><para>To construct an anonymous subclass, call <literal moreinfo="none">Class.new(MySuperClass)</literal>.</para></listitem><listitem><para>Parameterized subclassing can be used to add logic to the
        subclassing process, and essentially involves a method returning a
        class object, either anonymous or explicitly defined.<indexterm id="I_indexterm3_d1e4193" class="endofrange" startref="ch03_classesprogramming" significance="normal"/><indexterm id="I_indexterm3_d1e4194" class="endofrange" startref="ch03_modulesprogramming" significance="normal"/></para></listitem></itemizedlist></sect1><sect1 id="registering_hooks_and_callbacks"><title>Registering Hooks and Callbacks</title><para>In the very beginning of the chapter, we looked at the <literal moreinfo="none">BlankSlate</literal> class, and I had mentioned that there
    was some additional work that needed to be done to deal with things such
    as new method definitions on <literal moreinfo="none">Object</literal> or
    module inclusion.<indexterm id="I_indexterm3_d1e4206" significance="normal"><primary>callbacks</primary><seealso>hooks, registering</seealso></indexterm><indexterm class="startofrange" id="ch03_hooks" significance="normal"><primary>hooks, registering</primary></indexterm><indexterm id="I_indexterm3_d1e4214" significance="normal"><primary>BlankSlate class</primary></indexterm></para><para>To recap the situation, <literal moreinfo="none">BlankSlate</literal> is supposed to be a “naked” base
    class we can inherit from that doesn’t reveal any of its methods until we
    tell it to. We have already covered the ins and outs of how
    <literal moreinfo="none">BlankSlate</literal> hides its initial instance methods and how
    it can selectively reveal them. The problem that remains to be solved is
    how to accommodate for changes that happen at runtime.</para><sect2><title>Detecting Newly Added Functionality</title><para>As we’ve seen, due to the open class system, Ruby object
      definitions are never really finalized. As a consequence, if you add a
      method to <literal moreinfo="none">Object</literal>, it becomes available <phrase role="keep-together">immediately</phrase> to every object in the system
      except instances of <literal moreinfo="none">BasicObject</literal>. To
      put words into code, here’s what that means:<indexterm class="startofrange" id="ch03_hooksnewfunc" significance="normal"><primary>hooks, registering</primary><secondary>detecting newly added functionality</secondary></indexterm></para><screen format="linespecific">&gt;&gt; a  = "foo"
=&gt; "foo"
&gt;&gt; b = [1,2,3]
=&gt; [1, 2, 3]
&gt;&gt; class C; end
=&gt; nil
&gt;&gt; c = C.new
=&gt; #&lt;C:0x42a400&gt;
&gt;&gt; class Object
&gt;&gt;   def party
&gt;&gt;     "wooohoo!"
&gt;&gt;   end
&gt;&gt; end
=&gt; nil
&gt;&gt; a.party
=&gt; "wooohoo!"
&gt;&gt; b.party
=&gt; "wooohoo!"
&gt;&gt; c.party
=&gt; "wooohoo!"</screen><para>Now everyone is partying, except <literal moreinfo="none">BlankSlate</literal>. Or more accurately, <literal moreinfo="none">BlankSlate</literal> is being forced to party when it
      doesn’t want to. The solution is to set up a hook that watches for newly
      defined methods and hides them:<indexterm id="I_indexterm3_d1e4254" significance="normal"><primary>BlankSlate class</primary><secondary>hook watching for and hiding newly defined
          methods</secondary></indexterm></para><screen format="linespecific">class Object
  class &lt;&lt; self
    alias_method :blank_slate_method_added, :method_added

    # Detect method additions to Object and remove them in the
    # BlankSlate class.
    def method_added(name)
      result = blank_slate_method_added(name)
      return result if self != Object
      BlankSlate.hide(name)
      result
    end

  end
end</screen><para>This code uses techniques discussed earlier in this chapter to
      modify the behavior of a core Ruby function, <literal moreinfo="none">Object.method_added()</literal>, while remaining
      transparent for the ordinary use cases. Classes inherited from
      <literal moreinfo="none">Object</literal> will not affect <literal moreinfo="none">BlankSlate</literal>, so this code is set to
      short-circuit in those cases. However, if <literal moreinfo="none">self</literal> happens to be <literal moreinfo="none">Object</literal>, the code tells <literal moreinfo="none">BlankSlate</literal> to hide it and then returns the
      results of the original <literal moreinfo="none">method_added()</literal> function that has been aliased
      here.<indexterm id="I_indexterm3_d1e4285" significance="normal"><primary>modules</primary><secondary>included in objects at runtime</secondary></indexterm><indexterm id="I_indexterm3_d1e4290" significance="normal"><primary>Kernel module</primary></indexterm><indexterm id="I_indexterm3_d1e4293" significance="normal"><primary>method_added( ) function</primary></indexterm><indexterm id="I_indexterm3_d1e4296" significance="normal"><primary>Object.method_added( ) function</primary></indexterm></para><para>You’d think that would do the trick, but as it turns out, <literal moreinfo="none">Object</literal> includes the module <literal moreinfo="none" role="keep-together">Kernel</literal>. This means we
      need to track changes over there too, using nearly the same <phrase role="keep-together">approach</phrase>:</para><screen format="linespecific">module Kernel
  class &lt;&lt; self
    alias_method :blank_slate_method_added, :method_added

    # Detect method additions to Kernel and remove them in the
    # BlankSlate class.
    def method_added(name)
      result = blank_slate_method_added(name)
      return result if self != Kernel
      BlankSlate.hide(name)
      result
    end
  end
end</screen><para>There isn’t much new here, so it’s safe to say that if you
      understood how this worked on <literal moreinfo="none">Object</literal>,
      you can assume this is just more of the same stuff. However, it does
      give a hint about another problem: inclusion of modules into
      <literal moreinfo="none">Object</literal> at runtime.<indexterm id="I_indexterm3_d1e4320" significance="normal"><primary>Object class, inclusion of modules at runtime</primary></indexterm></para><para>First, another quick illustration of the issue:</para><screen format="linespecific">&gt;&gt; module A
&gt;&gt;   def foo
&gt;&gt;     "bar"
&gt;&gt;   end
&gt;&gt; end
=&gt; nil
&gt;&gt; a = Object.new
=&gt; #&lt;Object:0x428ca4&gt;
&gt;&gt; a.extend(A)
=&gt; #&lt;Object:0x428ca4&gt;
&gt;&gt; a.foo
=&gt; "bar"
&gt;&gt; module A
&gt;&gt;   def kittens
&gt;&gt;     "meow"
&gt;&gt;   end
&gt;&gt; end
=&gt; nil
&gt;&gt; a.kittens
=&gt; "meow"</screen><para>Every module included in an object is like a back door for future
      expansion. When you first fire up Ruby, the only module you need to
      worry about is <literal moreinfo="none">Kernel</literal>, but after
      that, all bets are off. So we end up jumping up one level higher to take
      care of module inclusion dynamically:</para><screen format="linespecific">class Module
  alias blankslate_original_append_features append_features
  def append_features(mod)
    result = blankslate_original_append_features(mod)
    return result if mod != Object
    instance_methods.each do |name|
      BlankSlate.hide(name)
    end
    result
  end
end</screen><para>In this example, <literal moreinfo="none">mod</literal> is the
      class that was modified by a module inclusion. As in the other hooks,
      <literal moreinfo="none">BlankSlate</literal> makes an alias of the
      original, calls it, and simply returns its result if the modified object
      isn’t <literal moreinfo="none">Object</literal> itself. In the case
      where a module is mixed into <literal moreinfo="none">Object</literal>,
      <literal moreinfo="none">BlankSlate</literal> needs to wipe out the instance methods
      added to its own class definition. After this, it returns the result of
      the original <literal moreinfo="none">append_features()</literal>
      call.</para><para>This pretty much describes the key aspects of capturing newly
      added functionality at the top level. You can of course apply these
      hooks to individual classes lower in the chain and make use of them in
      other ways.<indexterm id="I_indexterm3_d1e4358" class="endofrange" startref="ch03_hooksnewfunc" significance="normal"/></para></sect2><sect2><title>Tracking Inheritance</title><para>When you write unit tests via <literal moreinfo="none">Test::Unit</literal>, you typically just subclass
      <literal moreinfo="none">Test::Unit::TestCase</literal>, which figures
      out how to find your tests for you. Though we won’t look at the details
      for how that is actually implemented, we can take a naive shot at it on
      our own using the <literal moreinfo="none">Class#inherited</literal>
      hook.<indexterm class="startofrange" id="ch03_inheritancetrack" significance="normal"><primary>inheritance</primary><secondary>tracking</secondary></indexterm><indexterm class="startofrange" id="ch03_hookstrackinheritance" significance="normal"><primary>hooks, registering</primary><secondary>tracking inheritance</secondary></indexterm><indexterm id="I_indexterm3_d1e4383" significance="normal"><primary>Class#inherited hook</primary></indexterm><indexterm id="I_indexterm3_d1e4386" significance="normal"><primary>TestCase class</primary><secondary>Class#inherited hook</secondary></indexterm></para><para>We’re going to implement the code to make this example
      functional:</para><screen format="linespecific">class SimpleTest &lt; SimpleTestHarness

  def setup
    puts "Setting up @string"
    @string = "Foo"
  end

  def test_string_must_be_foo
    answer = (@string == "Foo" ? "yes" : "no")
    puts "@string == 'Foo': " &lt;&lt; answer
  end

  def test_string_must_be_bar
    answer = (@string == "bar" ? "yes" : "no")
    puts "@string == 'bar': " &lt;&lt; answer
  end

end

class AnotherTest &lt; SimpleTestHarness
<?dbfo-need height=”1in”
?>
  def test_another_lame_example
    puts "This got called, isn't that good enough?"
  end

  def helper_method
    puts "But you'll never see this"
  end

  def a_test_method
    puts "Or this"
  end

end

SimpleTestHarness.run</screen><para>We must first identify each subclass as a test case, and store it
      in an array until <literal moreinfo="none" role="keep-together">SimpleTestHarness.run</literal> is called. Like
      <literal moreinfo="none">Test::Unit</literal> and other common Ruby
      testing frameworks, we’ll wipe the slate clean by reinstantiating our
      tests for each test method, running a <literal moreinfo="none">setup</literal> method if it exists. We will follow the
      <literal moreinfo="none">Test::Unit</literal> convention and run only
      the methods whose names begin with <literal moreinfo="none">test_</literal>. We haven’t implemented any assertions
      or anything like that, because it’s not really the point of this
      exercise.<indexterm id="I_indexterm3_d1e4415" significance="normal"><primary>subclasses, detecting and tracking inheritance</primary></indexterm></para><para>The task can easily be broken down into two parts: detecting the
      subclasses, and later manipulating them. The first part is where we use
      the <literal moreinfo="none">inherited</literal> hook, as you can
      see:</para><screen format="linespecific">class SimpleTestHarness

  class &lt;&lt; self

    def inherited(base)
      tests &lt;&lt; base
    end

    def tests
      @tests ||= []
    end

  end

end</screen><para>Surprisingly enough, that was relatively painless. Each time a new
      subclass is derived from <literal moreinfo="none">SimpleTestHarness</literal>, the <literal moreinfo="none">inherited()</literal> hook is called, passing in the
      subclass as <literal moreinfo="none">base</literal>. If we just store
      these in an array at class level, that’s all we need for writing a test
      runner. Adding in <literal moreinfo="none">SimpleTestHarness.run</literal>, our full class looks
      like this:</para><screen format="linespecific">class SimpleTestHarness
  class &lt;&lt; self

    def inherited(base)
      tests &lt;&lt; base
    end

    def tests
      @tests ||= []
    end

    def run
      tests.each do |t|
        t.instance_methods.grep(/^test_/).each do |m|
          test_case = t.new
          test_case.setup if test_case.respond_to?(:setup)
          test_case.send(m)
        end
      end
    end
  end

end</screen><para>This code walks over each class in the <literal moreinfo="none">tests</literal>
      array, and then filters out the names of the instance methods that begin
      with <literal moreinfo="none">test_</literal>. For each of these
      methods, it creates a new instance of the test case, calls
      <literal moreinfo="none">setup</literal> if it exists, and then uses
      <literal moreinfo="none">send</literal> to dynamically invoke the individual test. With
      this class definition in place, the original set of tests for which we
      were trying to implement this functionality can actually run, resulting
      in the following output:</para><screen format="linespecific">Setting up @string
@string == 'Foo': yes
Setting up @string
@string == 'bar': no
This got called, isn't that good enough?</screen><para>Pretty cool, huh? These hooks essentially provide an event system,
      giving you a way to handle changes to Ruby in a dynamic way. If you’ve
      ever had to do GUI programming or anything else that involved dynamic
      callbacks, you already grasp the core ideas behind this concept. The
      only difference is that rather than capturing a button press, you’re
      capturing an inheritance event or an added method. When used
      appropriately, this can be a very powerful technique.</para><para>We’re about to wrap things up here, but before we do, it’s worth
      showing the equivalent of what we just did, but for modules. There
      happens to be a fairly standard Ruby idiom that takes advantage of that
      hook, so it’s one you shouldn’t skip over.<indexterm id="I_indexterm3_d1e4462" class="endofrange" startref="ch03_inheritancetrack" significance="normal"/><indexterm id="I_indexterm3_d1e4463" class="endofrange" startref="ch03_hookstrackinheritance" significance="normal"/></para></sect2><sect2><title>Tracking Mixins</title><para>You probably already know that if you use <literal moreinfo="none">include</literal> to mix a module into a class, the
      methods become available at the instance level, and that if you use
      <literal moreinfo="none">extend</literal>, they become available at the
      class level. However, an issue comes up when you want to provide both
      class and instance methods from a single module.<indexterm id="I_indexterm3_d1e4475" significance="normal"><primary>include( ) method</primary></indexterm><indexterm id="I_indexterm3_d1e4478" significance="normal"><primary>extend( ) method</primary></indexterm><indexterm class="startofrange" id="ch03_hooksmixins" significance="normal"><primary>hooks, registering</primary><secondary>tracking mixins</secondary></indexterm><indexterm class="startofrange" id="ch03_modulesmixin" significance="normal"><primary>modules</primary><secondary>tracking mixins</secondary></indexterm></para><para>A naive workaround might look like this:</para><screen format="linespecific">module MyFeatures

  module ClassMethods
    def say_hello
      "Hello"
    end

    def say_goodbye
      "Goodbye"
    end
  end

  def say_hello
    "Hello from #{self}!"
  end

  def say_goodbye
    "Goodbye from #{self}"
  end
end


class A
  include MyFeatures
  extend MyFeatures::ClassMethods
end</screen><para>If we test this out in <emphasis>irb</emphasis>, we see that it
      does work:</para><screen format="linespecific">?&gt; A.say_hello
=&gt; "Hello"
&gt;&gt; obj = A.new
=&gt; #&lt;A:0x1ee628&gt;
&gt;&gt; obj.say_hello
=&gt; "Hello from #&lt;A:0x1ee628&gt;!"
&gt;&gt; obj.say_goodbye
=&gt; "Goodbye from #&lt;A:0x1ee628&gt;"
&gt;&gt; A.say_goodbye
=&gt; "Goodbye"</screen><para>Having to manually do the <literal moreinfo="none">extend</literal> call seems a bit ugly, though. It’s not
      terrible when we are writing it ourselves, but it would be a little
      weird to do this any time you used a third-party module. Of course,
      that’s where a nice little hook comes in handy. The following code is
      functionally equivalent to our previous example:</para><screen format="linespecific">module MyFeatures

  module ClassMethods
    def say_hello
      "Hello"
    end
    
    def say_goodbye
      "Goodbye"
    end
  end
    
  def self.included(base)
    base.extend(ClassMethods)
  end

  def say_hello
    "Hello from #{self}!"
  end

  def say_goodbye
    "Goodbye from #{self}"
  end

end # MyFeatures

class A
  include MyFeatures
end</screen><para>Here, we were able to get rid of the manual <literal moreinfo="none">extend</literal> call and automate it through the
      <literal moreinfo="none">included</literal> hook. This hook gets called
      every time the module is included into a class, and passes the class
      object as the <literal moreinfo="none">base</literal> object. From here,
      we simply call <literal moreinfo="none">extend</literal> as before; it
      is just now wrapped up in the hook rather than manually specified in the
      class definition. Although this may seem like a small change, having a
      single entry point to the module’s features is a major win, as it keeps
      implementation details off the mind as much as possible when simply
      including the module.</para><para>Although we could dig up more and more hooks provided by Ruby,
      we’ve already covered most of the ones that are used fairly often. There
      are certainly plenty that we didn’t cover, and you might want to read
      over the core Ruby documentation a bit to discover some of the more
      obscure ones if you’re either curious or have an uncommon need.</para><para>For the hooks we did cover, here are some things to
      remember:</para><itemizedlist><listitem><para>If you are making changes to any hooks at the top level, be
          sure to safely modify them via aliasing, so as not to globally break
          their behavior.</para></listitem><listitem><para>Hooks can be implemented on a particular class or module, and
          will catch everything below them.</para></listitem><listitem><para>Most hooks either capture a class, a module, or a name of a
          method and are executed after an event takes place. This means that
          it’s not really possible to intercept an event before it happens,
          but it is usually possible to undo one once it is.</para></listitem></itemizedlist><para>And with that, we can wrap up this intense chapter with some
      closing notes and a final challenge to the adventurous.<indexterm id="I_indexterm3_d1e4540" class="endofrange" startref="ch03_hooksmixins" significance="normal"/><indexterm id="I_indexterm3_d1e4541" class="endofrange" startref="ch03_modulesmixin" significance="normal"/><indexterm id="I_indexterm3_d1e4542" class="endofrange" startref="ch03_hooks" significance="normal"/></para></sect2></sect1><sect1 id="I_sect13_d1e4544"><title>Conclusions</title><para>I found myself getting physically tired writing this chapter. If you
    feel that way after reading it, I don’t really blame you. People will tell
    you again and again that this sort of coding is extremely hard or fueled
    by some sort of magic. Others will tell you it’s the bee’s knees and that
    you should use it all the time, everywhere, whenever you can. Neither
    statement is true.</para><para>The truth of the matter is that taken individually, each of Ruby’s
    dynamic features is relatively straightforward, and can be a valuable tool
    if used properly. But looking at all of this stuff and trying to use it as
    much as possible in your code would be absolutely overwhelming.</para><para>My general rule of thumb is to ignore all of these advanced Ruby
    features until my code illustrates a need for them. If I write several
    method calls that appear to do almost the same thing with a different
    name, I might be able to leverage <literal moreinfo="none">method_missing</literal>. If I <phrase role="keep-together">want to endow</phrase> certain objects with some
    handy shortcuts, but leave the option of <phrase role="keep-together">instantiating</phrase> a simple, unadorned core
    object, I might look into mixing in some singleton methods using <literal moreinfo="none">extend</literal>. By the end of the day, in a large or
    complicated application, I may end up using a large subset of the
    techniques discussed here. But if I started out by thinking about what
    dynamic features my code needed rather than what <phrase role="keep-together">requirements</phrase> it must satisfy, development
    would come to a confusing, grinding halt.</para><para>So here’s my advice about making use of the information in this
    chapter: just make a mental note of what you’ve learned here, and then
    wait until some code jumps out at you and seems to be begging to be
    cleaned up using one of the techniques shown here. If it works out well,
    you’ve probably made a good decision. If it seems like more trouble than
    it’s worth, bail out and wait for the next bit of code to alert you again.
    Keep repeating this process and you’ll find a good balance for how dynamic
    your code really needs to be.</para><para>Because this chapter is focused on a series of topics that are sort
    of a rite of passage as far as Ruby development goes, I’d like to end with
    a bit of code that might challenge your understanding a bit.</para><para>What follows is a simplistic approximation of Camping’s routing
    magic. It is meant to help you learn, but is left without comments so that
    you can figure it out on your own. It does not introduce any new concepts
    beyond what was discussed in this chapter, so if you can figure out how it
    works, you can be sure that you have a fairly solid grasp of what we’ve
    been talking about here.<indexterm id="I_indexterm3_d1e4574" significance="normal"><primary>Camping module</primary><secondary>approximation of routing magic</secondary></indexterm></para><para>Enjoy!</para><?dbfo-need height=”2in”
?><screen format="linespecific">module NaiveCampingRoutes

  extend self

  def R(url)
    route_lookup = routes

    klass = Class.new
    meta  = class &lt;&lt; klass; self; end
    meta.send(:define_method, :inherited) do |base|
      raise "Already defined" if route_lookup[url]
      route_lookup[url] = base
    end
    klass
  end

  def routes
    @routes ||= {}
  end

  def process(url, params={})
    routes[url].new.get(params)
  end
end

module NaiveCampingRoutes
  class Hello &lt; R '/hello'
    def get(params)
      puts "hello #{params[:name]}"
    end
  end

  class Goodbye &lt; R '/goodbye'
    def get(params)
      puts "goodbye #{params[:name]}"
    end
  end
end

NaiveCampingRoutes.process('/hello', :name =&gt; "greg")
NaiveCampingRoutes.process('/goodbye', :name =&gt; "joe")</screen></sect1></chapter><chapter id="I_chapter4_d1e4584"><title>Text Processing and File Management</title><para>Ruby fills a lot of the same roles that languages such as Perl and
  Python do. Because of this, you can expect to find first-rate support for
  text processing and file management. Whether it’s parsing a text file with
  some regular expressions or building some *nix-style filter applications,
  Ruby can help make life easier.<indexterm class="startofrange" id="ch04_textprocessing" significance="normal"><primary>text processing</primary></indexterm></para><para>However, much of Ruby’s I/O facilities are tersely documented at best.
  It is also relatively hard to find good resources that show you general
  strategies for attacking common text-processing tasks. This chapter aims to
  expose you to some good tricks that you can use to simplify your
  text-processing needs as well as sharpen your skills when it comes to
  interacting with and managing files on your system.</para><para>As in other chapters, we’ll start off by looking at some real open
  source code—this time, a simple parser for an Adobe Font Metrics (AFM) file.
  This example will expose you to text processing in its setting. We’ll then
  follow up with a number of detailed sections that look at different
  practices that will help you master basic I/O skills. Armed with these
  techniques, you’ll be able to take on all sorts of text-processing and
  file-<phrase role="keep-together">management</phrase> tasks with
  ease.<indexterm class="startofrange" id="ch04_AFMparser" significance="normal"><primary>Adobe Font Metrics file, parser for</primary></indexterm><indexterm class="startofrange" id="ch04_parserAFM" significance="normal"><primary>parsers</primary><secondary>parser for Adobe Font Metrics file</secondary></indexterm></para><sect1 id="I_sect14_d1e4607"><title>Line-Based File Processing with State Tracking</title><para>Processing a text document line by line does not mean that we’re
    limited to extracting content in a uniform way, treating each line
    identically. Some files have more structure than that, but can still
    benefit from being processed linearly. We’re now going to look over a
    small parser that illustrates this general idea by selecting different
    ways to extract our data based on what section of a file we are
    in.<indexterm class="startofrange" id="ch04_statetrack" significance="normal"><primary>state</primary><secondary>tracking in line-by-line text processing</secondary></indexterm><indexterm class="startofrange" id="ch04_textprocAFMparser" significance="normal"><primary>text processing</primary><secondary>line-based file processing with state tracking</secondary></indexterm></para><para>The code in this section was written by James Edward Gray II as part
    of Prawn’s AFM support. Though the example itself is domain-specific, we
    won’t get hung up in the particular details of this parser. Instead, we’ll
    be taking a look at the general approach for how to build a state-aware
    parser that operates on an efficient line-by-line basis. Along the way,
    you’ll pick up some basic I/O tips and tricks as well as see the <phrase role="keep-together">important</phrase> role that <phrase role="keep-together">regular</phrase> <phrase role="keep-together">expressions</phrase> often play in this sort of
    task.<indexterm id="I_indexterm4_d1e4633" significance="normal"><primary>file management</primary><seealso>text processing</seealso></indexterm><indexterm id="I_indexterm4_d1e4638" significance="normal"><primary>text processing</primary><seealso>file management</seealso></indexterm></para><para>Before we look at the actual parser, we can take a glance at the
    sort of data we’re dealing with. AFM files are essentially font glyph
    measurements and specifications, so they tend to look a bit like a
    configuration file of sorts. Some of these things are simply straight
    key/value pairs, such as:</para><programlisting id="I_programlisting4_d1e4645" format="linespecific">CapHeight 718
XHeight 523
Ascender 718
Descender -207</programlisting><para>Others are organized sets of values within a section, as in the
    following example:</para><screen format="linespecific">StartCharMetrics 315
C 32 ; WX 278 ; N space ; B 0 0 0 0 ;
C 33 ; WX 278 ; N exclam ; B 90 0 187 718 ;
C 34 ; WX 355 ; N quotedbl ; B 70 463 285 718 ;
C 35 ; WX 556 ; N numbersign ; B 28 0 529 688 ;
C 36 ; WX 556 ; N dollar ; B 32 -115 520 775 ;
....
EndCharMetrics</screen><para>Sections can be nested within each other, making things more
    interesting. The data across the file does not fit a uniform format, as
    each section represents a different sort of thing. However, we can come up
    with patterns to parse data in each section that we’re interested in,
    because they are consistent within their sections. We also are interested
    in only a subset of the sections, so we can safely ignore some of them.
    This is the essence of the task we needed to accomplish, but as you may
    have noticed, it’s a fairly abstract pattern that we can reuse. Many
    documents with a simple section-based structure can be worked with using
    the approach shown here.</para><para>The code that follows is essentially a simple finite state machine
    that keeps track of what section the current line appears in. It attempts
    to parse the opening or closing of a section first, and then it uses this
    information to determine a parsing strategy for the current line. We
    simply skip the sections that we’re not interested in parsing.</para><para>We end up with a very straightforward solution. The whole parser is
    reduced to a simple iteration over each line of the file, which manages a
    stack of nested sections, while determining whether and how to parse the
    current line.</para><para>We’ll see the parts in more detail in just a moment, but here is the
    whole AFM parser that extracts all the information we need to properly
    render Adobe fonts in Prawn:</para><programlisting id="I_programlisting4_d1e4660" format="linespecific">def parse_afm(file_name)
  section = []

  File.foreach(file_name) do |line|
    case line
    when /^Start(\w+)/
      section.push $1
      next
    when /^End(\w+)/
      section.pop
      next
    end

    case section
    when ["FontMetrics", "CharMetrics"]
      next unless line =~ /^CH?\s/

      name                  = line[/\bN\s+(\.?\w+)\s*;/, 1]
      @glyph_widths[name]   = line[/\bWX\s+(\d+)\s*;/, 1].to_i
      @bounding_boxes[name] = line[/\bB\s+([^;]+);/, 1].to_s.rstrip
    when ["FontMetrics", "KernData", "KernPairs"]
      next unless line =~ /^KPX\s+(\.?\w+)\s+(\.?\w+)\s+(-?\d+)/
      @kern_pairs[[$1, $2]] = $3.to_i
    when ["FontMetrics", "KernData", "TrackKern"], ["FontMetrics", "Composites"]
      next
    else
      parse_generic_afm_attribute(line)
    end
  end
end</programlisting><para>You could try to understand the particular details if you’d like,
    but it’s also fine to black-box the expressions used here so that you can
    get a sense of the overall structure of the parser. Here’s what the code
    looks like if we do that for all but the patterns that determine the
    section nesting:</para><programlisting id="I_programlisting4_d1e4664" format="linespecific">def parse_afm(file_name)
  section = []

  File.foreach(file_name) do |line|
    case line
    when /^Start(\w+)/
      section.push $1
      next
    when /^End(\w+)/
      section.pop
      next
    end

    case section
    when ["FontMetrics", "CharMetrics"]
      parse_char_metrics(line)
    when ["FontMetrics", "KernData", "KernPairs"]
      parse_kern_pairs(line)
    when ["FontMetrics", "KernData", "TrackKern"], ["FontMetrics", "Composites"]
      next
    else
      parse_generic_afm_attribute(line)
    end
  end
end</programlisting><para>With these simplifications, it’s very clear that we’re looking at an
    ordinary finite state machine that is acting upon the lines of the file.
    It also makes it easier to notice what’s actually going on.</para><para>The first <literal moreinfo="none">case</literal> statement is just a simple way to
    check which section we’re currently looking at, updating the stack as
    necessary as we move in and out of sections:</para><programlisting id="I_programlisting4_d1e4673" format="linespecific">case line
when /^Start(\w+)/
  section.push $1
  next
when /^End(\w+)/
  section.pop
  next
end</programlisting><para>If we find a section beginning or end, we skip to the next line, as
    we know there is nothing else to parse. Otherwise, we know that we have to
    do some real work, which is done in the second <literal moreinfo="none">case</literal>
    statement:</para><programlisting id="I_programlisting4_d1e4680" format="linespecific">case section
when ["FontMetrics", "CharMetrics"]
  next unless line =~ /^CH?\s/

  name                  = line[/\bN\s+(\.?\w+)\s*;/, 1]
  @glyph_widths[name]   = line[/\bWX\s+(\d+)\s*;/, 1].to_i
  @bounding_boxes[name] = line[/\bB\s+([^;]+);/, 1].to_s.rstrip
when ["FontMetrics", "KernData", "KernPairs"]
  next unless line =~ /^KPX\s+(\.?\w+)\s+(\.?\w+)\s+(-?\d+)/
  @kern_pairs[[$1, $2]] = $3.to_i
when ["FontMetrics", "KernData", "TrackKern"], ["FontMetrics", "Composites"]
  next
else
  parse_generic_afm_attribute(line)
end</programlisting><para>Here, we’ve got four different ways to handle our line of text. In
    the first two cases, we process the lines that we need to as we walk
    through the section, extracting the bits of information we need and
    ignoring the information we’re not interested in.</para><para>In the third case, we identify certain sections to skip and simply
    resume processing the next line if we are currently within that
    section.</para><para>Finally, if the other cases fail to match, our last
    <literal moreinfo="none">case</literal> scenario assumes that we’re dealing with a simple
    key/value pair, which is handled by a private helper method in Prawn.
    Because it does not provide anything different to look at than the first
    two sections of this <literal moreinfo="none">case</literal> statement, we can safely
    ignore how it works without missing anything <phrase role="keep-together">important</phrase>.</para><para>However, the interesting thing that you might have noticed is that
    the first case and the second case use two different ways of extracting
    values. The code that processes <literal moreinfo="none" role="keep-together">CharMetrics</literal> uses <literal moreinfo="none">String#[]</literal>, whereas the code handling
    <literal moreinfo="none">KernPairs</literal> uses Perl-style global match variables. The
    reason for this is largely convenience. The following two lines of code
    are equivalent:</para><programlisting id="I_programlisting4_d1e4709" format="linespecific">name = line[/\bN\s+(\.?\w+)\s*;/, 1]
name = line =~ /\bN\s+(\.?\w+)\s*;/ &amp;&amp; $1</programlisting><para>There are still other ways to handle your captured matches (such as
    <literal moreinfo="none">MatchData</literal> via <literal moreinfo="none">String#match</literal>), but we’ll get into those later.
    For now, it’s simply worth knowing that when you’re trying to extract a
    single matched capture, <literal moreinfo="none">String#[]</literal> does
    the job well, but if you need to deal with more than one, you need to use
    another approach. We see this clearly in the second case:</para><programlisting id="I_programlisting4_d1e4722" format="linespecific">next unless line =~ /^KPX\s+(\.?\w+)\s+(\.?\w+)\s+(-?\d+)/
@kern_pairs[[$1, $2]] = $3.to_i</programlisting><para>This code is a bit clever, as the line that assigns the values to
    <literal moreinfo="none">@kern_pairs</literal> gets executed only when
    there is a successful match. When the match fails, it will return <literal moreinfo="none">nil</literal>, causing the parser to skip to the next line
    for processing.</para><para>We could continue studying this example, but we’d then be delving
    into the specifics, and those details aren’t important for remembering
    this simple general pattern.</para><para>When dealing with a structured document that can be processed by
    discrete rules for each section, the general approach is simple and does
    not typically require pulling the entire document into memory or doing
    multiple passes through the data.<indexterm id="I_indexterm4_d1e4736" significance="normal"><primary>text processing</primary><secondary>line-based file processing with state tracking</secondary><tertiary>guidelines for</tertiary></indexterm></para><para>Instead, you can do the following:</para><itemizedlist><listitem><para>Identify the beginning and end markers of sections with a
        pattern.</para></listitem><listitem><para>If sections are nested, maintain a stack that you update before
        further processing of each line.</para></listitem><listitem><para>Break up your extraction code into different cases and select
        the right one based on the current section you are in.</para></listitem><listitem><para>When a line cannot be processed, skip to the next one as soon as
        possible, using the <literal moreinfo="none">next</literal>
        keyword.</para></listitem><listitem><para>Maintain state as you normally would, processing whatever data
        you need.</para></listitem></itemizedlist><para>By following these basic guidelines, you can avoid overthinking your
    problem, while still saving clock cycles and keeping your memory footprint
    low. Although the code here solves a particular problem, it can easily be
    adapted to fit a wide range of basic document processing needs.<indexterm id="I_indexterm4_d1e4766" class="endofrange" startref="ch04_statetrack" significance="normal"/><indexterm id="I_indexterm4_d1e4767" class="endofrange" startref="ch04_textprocAFMparser" significance="normal"/><indexterm id="I_indexterm4_d1e4768" class="endofrange" startref="ch04_AFMparser" significance="normal"/><indexterm id="I_indexterm4_d1e4769" class="endofrange" startref="ch04_parserAFM" significance="normal"/></para><para>This introduction has hopefully provided a taste of what text
    processing in Ruby is all about. The rest of the chapter will provide many
    more tips and tricks, with a greater focus on the particular topics. Feel
    free to jump around to the things that interest you most, but I’m hoping
    all of the sections have something interesting to offer—even to seasoned
    Rubyists.</para></sect1><sect1 id="I_sect14_d1e4772"><title>Regular Expressions</title><para>At the time of writing this chapter, I was spending some time
    watching the Dow Jones Industrial Average, as the world was in the middle
    of a major financial meltdown. If you’re wondering what this has to do
    with Ruby or regular expressions, take a quick look at the following
    code:<indexterm class="startofrange" id="ch04_textprocessingregex" significance="normal"><primary>text processing</primary><secondary>using regular expressions</secondary></indexterm><indexterm class="startofrange" id="ch04_regex" significance="normal"><primary>regular expressions</primary></indexterm></para><programlisting id="I_programlisting4_d1e4785" format="linespecific">require "open-uri"
loop do
  puts( open("http://finance.google.com/finance?cid=983582").read[
  /&lt;span class="\w+" id="ref_983582_c"&gt;([+-]?\d+\.\d+)/m, 1] )
  sleep(30)
end</programlisting><para>In just a couple of lines, I was able to throw together a script
    that would poll Google Finance and pull down the current average price of
    the Dow. This sort of “find a needle in the haystack” extraction is what
    regular expressions are all about.</para><para>Of course, the art of constructing regular expressions is often
    veiled in mystery. Even simple patterns such as this one might make some
    folks feel a bit uneasy:</para><programlisting id="I_programlisting4_d1e4791" format="linespecific">/&lt;span class="\w+" id="ref_983582_c"&gt;([+-]?\d+\.\d+)/m</programlisting><para>This expression is simple by comparison to some other examples we
    can show, but it still makes use of a number of regular expression
    concepts. All in one line, we can see the use of character classes (both
    general and special), escapes, quantifiers, groups, and a switch that
    enables multiline matching.</para><para>Patterns are dense because they are written in a special syntax,
    which acts as a sort of domain language for matching and extracting text.
    The reason that it may be considered daunting is that this language is
    made up of so few special characters:<indexterm id="I_indexterm4_d1e4797" significance="normal"><primary>regular expressions</primary><secondary>special characters in pattern syntax</secondary></indexterm></para><programlisting id="I_programlisting4_d1e4802" format="linespecific">\ [ ] . ^ $ ? * + { } | ( )</programlisting><para>At its heart, regular expressions are nothing more than a facility
    to do find and replace operations. This concept is so familiar that anyone
    who has used a word processor has a strong grasp on it. Using a regex, you
    can easily replace all instances of the word “Mitten” with “Kitten”, just
    like your favorite text editor or word processor can:</para><programlisting id="I_programlisting4_d1e4806" format="linespecific">some_string.gsub(/\bMitten\b/,"Kitten")</programlisting><para>Many programmers get this far and stop. They learn to use regex as
    if it were a necessary evil rather than an essential technique. We can do
    better than that. In this section, <phrase role="keep-together">we’ll
    look</phrase> at a few guidelines for how to write effective patterns that
    do what they’re supposed to without getting too convoluted. I’m assuming
    you’ve done your homework and are at least familiar with regex basics as
    well as Ruby’s pattern syntax. If that’s not the <phrase role="keep-together">case, pick up</phrase> your favorite language
    reference and take a few minutes to review the <phrase role="keep-together">fundamentals</phrase>.</para><para>As long as you can comfortably read the first example in this
    section, you’re ready to move on. If you can convince yourself that
    writing regular expressions is actually much easier than people tend to
    think it is, the tips and tricks to follow shouldn’t cause you to break a
    sweat.</para><sect2><title>Don’t Work Too Hard</title><para>Despite being such a compact format, it’s relatively easy to write
      bloated patterns if you don’t consciously remember to keep things clean
      and tight. We’ll now take a look at a couple sources of extra fat and
      see how to trim them down.<indexterm id="I_indexterm4_d1e4827" significance="normal"><primary>regular expressions</primary><secondary>writing clean, tight patterns</secondary></indexterm></para><para>Alternation is a very powerful regex tool. It allows you to match
      one of a series of potential sequences. For example, if you want to
      match the name “James Gray” but also match “James gray”, “james Gray”,
      and “james gray”, the following code will do the trick:</para><programlisting id="I_programlisting4_d1e4834" format="linespecific">&gt;&gt; ["James Gray", "James gray", "james gray", "james Gray"].all? { |e|
?&gt;   e.match(/James|james Gray|gray/) }
=&gt; true</programlisting><para>However, you don’t need to work so hard. You’re really talking
      about possible alternations of simply two characters, not two full
      words. You could write this far more efficiently using a character
      class:</para><programlisting id="I_programlisting4_d1e4838" format="linespecific">&gt;&gt; ["James Gray", "James gray", "james gray", "james Gray"].all? { |e|
?&gt;   e.match(/[Jj]ames [Gg]ray/) }
=&gt; true</programlisting><para>This makes your pattern clearer and also will result in a much
      better optimization in Ruby’s regex engine. So in addition to looking
      better, this code is actually faster.</para><para>In a similar vein, it is unnecessary to use explicit character
      classes when a shortcut will do. To match a four-digit number, we could
      write:<indexterm id="I_indexterm4_d1e4844" significance="normal"><primary>character classes in regular expressions</primary></indexterm></para><programlisting id="I_programlisting4_d1e4847" format="linespecific">/[0-9][0-9][0-9][0-9]/</programlisting><para>which can of course be cleaned up a bit using repetitions:</para><programlisting id="I_programlisting4_d1e4851" format="linespecific">/[0-9]{4}/</programlisting><para>However, we can do even better by using the special class built in
      for this:</para><programlisting id="I_programlisting4_d1e4856" format="linespecific">/\d{4}/</programlisting><para>It pays to learn what shortcuts are available to you. Here’s a
      quick list for further study, in case you’re not already familiar with
      them:<indexterm id="I_indexterm4_d1e4860" significance="normal"><primary>shortcuts in regular expressions</primary></indexterm></para><programlisting id="I_programlisting4_d1e4863" format="linespecific">. \s \S \w \W \d \D</programlisting><para>Each one of these shortcuts corresponds to a literal character
      class that is more verbose when written out. Using shortcuts increases
      clarity and decreases the chance of bugs creeping in via ill-defined
      patterns. Though it may seem a bit terse at first, you’ll be able to
      sight-read them with ease over time.</para></sect2><sect2><title>Anchors Are Your Friends</title><para>One way to match my name in a string is to write the following
      simple pattern:<indexterm id="I_indexterm4_d1e4872" significance="normal"><primary>anchors in regular expressions</primary></indexterm><indexterm id="I_indexterm4_d1e4875" significance="normal"><primary>regular expressions</primary><secondary>anchors in</secondary></indexterm></para><programlisting id="I_programlisting4_d1e4880" format="linespecific">string =~ /Gregory Brown/</programlisting><para>However, consider the following:</para><programlisting id="I_programlisting4_d1e4884" format="linespecific">&gt;&gt; "matched" if "Mr. Gregory Browne".match(/Gregory Brown/)
=&gt; "matched"</programlisting><para>Oftentimes we mean “match this phrase,” but we write “match this
      sequence of characters.” The solution is to make use of anchors to
      clarify what we mean.</para><para>Sometimes we want to match only if a string starts with a
      phrase:</para><programlisting id="I_programlisting4_d1e4890" format="linespecific">&gt;&gt; phrases = ["Mr. Gregory Browne", "Mr. Gregory Brown is cool",
              "Gregory Brown is cool", "Gregory Brown"]

&gt;&gt; phrases.grep /\AGregory Brown\b/
=&gt; ["Gregory Brown is cool", "Gregory Brown"]</programlisting><para>Other times we want to ensure that the string contains the
      phrase:</para><programlisting id="I_programlisting4_d1e4894" format="linespecific">&gt;&gt; phrases.grep /\bGregory Brown\b/
=&gt; ["Mr. Gregory Brown is cool", "Gregory Brown is cool", "Gregory Brown"]</programlisting><para>And finally, sometimes we want to ensure that the string matches
      an exact phrase:</para><programlisting id="I_programlisting4_d1e4899" format="linespecific">&gt;&gt; phrases.grep /\AGregory Brown\z/
=&gt; ["Gregory Brown"]</programlisting><para>Although I am using English names and phrases here for simplicity,
      this can of course be generalized to encompass any sort of matching
      pattern. You could be verifying that a sequence of numbers fits a
      certain form, or something equally abstract. The key thing to take away
      from this is that when you use anchors, you’re being much more explicit
      about how you expect your pattern to match, which in most cases means
      that you’ll have a better chance of catching problems faster, and an
      easier time remembering what your pattern was supposed to do.</para><para>An interesting thing to note about anchors is that they don’t
      actually match characters. Instead, they match between characters to
      allow you to assert certain expectations about your strings. So when you
      use something like <literal moreinfo="none">\b</literal>, you are
      actually matching between one of <literal moreinfo="none">\w\W</literal>
      , <literal moreinfo="none">\W\w</literal> , <literal moreinfo="none">\A</literal> , <literal moreinfo="none">\z</literal>. In
      English, that means that you’re transitioning from a word character to a
      nonword character, or from a nonword character to a word character, or
      you’re matching the beginning or end of the string. If you review the
      use of <literal moreinfo="none">\b</literal> in the previous examples,
      it should now be very clear how anchors work.</para><para>The full list of available anchors in Ruby is <literal moreinfo="none">\A</literal>, <literal moreinfo="none">\Z</literal>,
      <literal moreinfo="none">\z</literal>, <literal moreinfo="none">^</literal>, <literal moreinfo="none">$</literal>, and
      <literal moreinfo="none">\b</literal>. Each has its own merits, so be
      sure to read up on them.</para></sect2><sect2><title>Use Caution When Working with Quantifiers</title><para>One of the most common antipatterns I picked up when first
      learning regular expressions was to make use of <literal moreinfo="none">.*</literal> everywhere. Though this practice may seem
      innocent, it is similar to my bad habit of using <literal moreinfo="none">rm -Rf</literal> on the command line all the time
      instead of just <literal moreinfo="none">rm</literal>. Both can result
      in catastrophe when used incorrectly.<indexterm id="I_indexterm4_d1e4959" significance="normal"><primary>regular expressions</primary><secondary>caution with quantifiers</secondary></indexterm><indexterm id="I_indexterm4_d1e4964" significance="normal"><primary>quantifiers in regular expressions</primary></indexterm></para><para>But maybe you’re not as crazy as I am. Instead, maybe you’ve been
      writing innocent things like <literal moreinfo="none">/(\d*)Foo/</literal> to match any number of digits
      prepended to the word “Foo”:</para><para>For some cases, this works great:</para><programlisting id="I_programlisting4_d1e4974" format="linespecific">&gt;&gt; "1234Foo"[/(\d*)Foo/,1]
=&gt; "1234"</programlisting><para>But does this surprise you?</para><programlisting id="I_programlisting4_d1e4978" format="linespecific">&gt;&gt; "xFoo"[/(\d*)Foo/,1]
=&gt; ""</programlisting><para>It may not, but then again, it may. It’s relatively common to
      forget that <literal moreinfo="none">*</literal> always matches. At
      first glance, the following code seems fine:</para><programlisting id="I_programlisting4_d1e4985" format="linespecific">if num = string[/(\d*)Foo/,1]
  Integer(num)
end</programlisting><para>However, because the match will capture an empty string in its
      failure case, this code will break. The solution is simple. If you
      really mean “at least one,” use <literal moreinfo="none">+</literal> instead:</para><programlisting id="I_programlisting4_d1e4992" format="linespecific">if num = string[/(\d+)Foo/,1]
  Integer(num)
end</programlisting><para>Though more experienced folks might not easily be trapped by
      something so simple, there are more subtle variants. For example, if we
      intend to match only “Greg” or “Gregory”, the following code doesn’t
      quite work:</para><programlisting id="I_programlisting4_d1e4997" format="linespecific">&gt;&gt; "Gregory"[/Greg(ory)?/]
=&gt; "Gregory"
&gt;&gt; "Greg"[/Greg(ory)?/]
=&gt; "Greg"
&gt;&gt; "Gregor"[/Greg(ory)?/]
=&gt; "Greg"</programlisting><para>Even if the pattern looks close to what we want, we can see the
      results don’t fit. The following modifications remedy the issue:</para><programlisting id="I_programlisting4_d1e5001" format="linespecific">&gt;&gt; "Gregory"[/\bGreg(ory)?\b/]
=&gt; "Gregory"
&gt;&gt; "Greg"[/\bGreg(ory)?\b/]
=&gt; "Greg"
&gt;&gt; "Gregor"[/\bGreg(ory)?\b/]
=&gt; nil</programlisting><para>Notice that the pattern now properly matches Greg or Gregory, but
      no other words. The key thing to take away here is that unbounded
      zero-matching quantifiers are <phrase role="keep-together">tautologies</phrase>. They can never fail to match,
      so you need to be sure to account for that.</para><para>A final gotcha about quantifiers is that they are greedy by
      default. This means they’ll try to consume as much of the string as
      possible before matching. The following is an example of a greedy
      match:<indexterm id="I_indexterm4_d1e5010" significance="normal"><primary>greedy quantifiers</primary></indexterm></para><programlisting id="I_programlisting4_d1e5013" format="linespecific">&gt;&gt; "# x # y # z #"[/#(.*)#/,1]
=&gt; " x # y # z "</programlisting><para>As you can see, this code matches everything between the first and
      last <literal moreinfo="none">#</literal> character. But sometimes, we
      want processing to happen from the left and end as soon as we have a
      match. To do this, append a <literal moreinfo="none">?</literal> to the
      repetition:<indexterm id="I_indexterm4_d1e5023" significance="normal"><primary>nongreedy quantifiers</primary></indexterm></para><programlisting id="I_programlisting4_d1e5026" format="linespecific">&gt;&gt; "# x # y # z #"[/#(.*?)#/,1]
=&gt; " x "</programlisting><para>All quantifiers can be made nongreedy this way. Remembering this
      will save a lot of headaches in the long run.</para><para>Though our treatment of regular expressions has been by no means
      comprehensive, these few basic tips will really carry you a long way.
      The key things to remember are:<indexterm id="I_indexterm4_d1e5032" significance="normal"><primary>regular expressions</primary><secondary>guidelines for</secondary></indexterm></para><itemizedlist><listitem><para>Regular expressions are nothing more than a special language
          for find-and-replace operations, built on simple logical
          constructs.</para></listitem><listitem><para>There are lots of shortcuts built in for common regular
          expression operations, so be sure to make use of special character
          classes and other simplifications when you can.</para></listitem><listitem><para>Anchors provide a way to set up some expectation about where
          in a string you want to look for a match. These help with both
          optimization and pattern <phrase role="keep-together">correctness</phrase>.</para></listitem><listitem><para>Quantifiers such as <literal moreinfo="none">*</literal> and
          <literal moreinfo="none">?</literal> will always match, so they
          should not be used without sufficient boundaries.</para></listitem><listitem><para>Quantifiers are greedy by default, and can be made nongreedy
          via <literal moreinfo="none">?</literal>.</para></listitem></itemizedlist><para>By following these guidelines, you’ll write clearer, more
      accurate, and faster regular expressions. As a result, it’ll be a whole
      lot easier to revisit them when you run into them in your own old code a
      few months down the line.</para><para>A final note on regular expressions is that sometimes we are
      seduced by their power and overlook other solutions that may be more
      robust for certain needs. In both the stock ticker and AFM parsing
      examples, we were working within the realm where regular expressions are
      a quick, easy, and fine way to go.</para><para>However, as documents take on more complex structures, and your
      needs move from extracting some values to attempting to fully parse a
      document, you will probably need to look to other techniques that
      involve full-blown parsers such as Treetop, Ghost Wheel, or Racc. These
      libraries can solve problems that regular expressions can’t solve, and
      if you find yourself with data that’s hard to map a regex to, it’s worth
      looking at these alternative solutions.<indexterm id="I_indexterm4_d1e5072" significance="normal"><primary>parsers</primary></indexterm></para><para>Of course, your mileage will vary based on the problem at hand, so
      don’t be afraid of trying a regex-based solution first before pulling
      out the big guns.<indexterm id="I_indexterm4_d1e5077" class="endofrange" startref="ch04_textprocessingregex" significance="normal"/><indexterm id="I_indexterm4_d1e5078" class="endofrange" startref="ch04_textprocessing" significance="normal"/><indexterm id="I_indexterm4_d1e5079" class="endofrange" startref="ch04_regex" significance="normal"/></para></sect2></sect1><sect1 id="I_sect14_d1e5080"><title>Working with Files</title><para>There are a whole slew of options for doing various file management
    tasks in Ruby. Because of this, it can be difficult to determine what the
    best approach for a given task might be. In this section, we’ll cover two
    key tasks while looking at three of Ruby’s standard libraries.<indexterm id="I_indexterm4_d1e5085" significance="normal"><primary>file management</primary></indexterm></para><para>First, you’ll learn how to use the <filename moreinfo="none">pathname</filename> and
    <filename moreinfo="none">fileutils</filename> libraries to traverse your <phrase role="keep-together">filesystem</phrase> using a clean cross-platform
    approach that rivals the power of popular *nix shells without sacrificing
    compatibility. We’ll then move on to how to use
    <filename moreinfo="none">tempfile</filename> to automate handling of temporary file
    resources within your scripts. These practical tips will help you write
    platform-agnostic Ruby code that’ll work out of the box on more systems,
    while still managing to make your job easier.</para><sect2><title>Using Pathname and FileUtils</title><para>If you are using Ruby to write administrative scripts, it’s nearly
      inevitable that you’ve needed to do some file management along the way.
      It may be quite tempting to drop down into the shell to do things like
      move and rename directories, search for files in a complex directory
      structure, and other common tasks that involve ferrying files around
      from one place to the other. However, Ruby provides some great tools to
      avoid this sort of thing.<indexterm class="startofrange" id="ch04_filesPathnameFileUtils" significance="normal"><primary>file management</primary><secondary>using Pathname and FileUtils</secondary></indexterm></para><para>The <filename moreinfo="none">pathname</filename> and
      <filename moreinfo="none">fileutils</filename> standard libraries provide virtually
      everything you need for file management. The best way to demonstrate
      their capabilities is by example, so we’ll now take a look at some code
      and then break it down piece by piece.<indexterm id="I_indexterm4_d1e5120" significance="normal"><primary>Pathname module</primary></indexterm></para><para>To illustrate <literal moreinfo="none">Pathname</literal>, we can take a look at a
      small tool I’ve built for doing local installations of libraries found
      on GitHub. This script, called <emphasis>mooch</emphasis>, essentially
      looks up and clones a git repository, puts it in a convenient place
      within your project (a <filename moreinfo="none">vendor/</filename> directory), and
      optionally sets up a stub file that will include your vendored packages
      into the loadpath upon requiring it. Sample usage looks something like
      this:<indexterm id="I_indexterm4_d1e5134" significance="normal"><primary>mooch script</primary></indexterm></para><programlisting id="I_programlisting4_d1e5137" format="linespecific">$ mooch init lib/my_project
$ mooch sandal/prawn  0.2.3
$ mooch ruport/ruport 1.6.1</programlisting><para>We can see the following will work without loading
      RubyGems:</para><programlisting id="I_programlisting4_d1e5141" format="linespecific">&gt;&gt; require "lib/my_project/dependencies"
=&gt; true
&gt;&gt; require "prawn"
=&gt; true
&gt;&gt; require "ruport"
=&gt; true
&gt;&gt; Prawn::VERSION
=&gt; "0.2.3"
&gt;&gt; Ruport::VERSION
=&gt; "1.6.1"</programlisting><para>Although this script is pretty useful, that’s not what we’re here
      to talk about. Instead, let’s focus on how this sort of thing is built,
      as it shows a practical example of using <literal moreinfo="none">Pathname</literal> to
      manipulate files and folders. I’ll start by showing you the whole
      script, and then we’ll walk through it part by part:</para><programlisting id="I_programlisting4_d1e5148" format="linespecific">#!/usr/bin/env ruby
require "pathname"

WORKING_DIR = Pathname.getwd
LOADER = %Q{
  require "pathname"

  Pathname.glob("#{WORKING_DIR}/vendor/*/*/") do |dir|
   lib = dir + "lib"
   $LOAD_PATH.push(lib.directory? ? lib : dir)
  end
}

if ARGV[0] == "init"
  lib = Pathname.new(ARGV[1])
  lib.mkpath
  (lib + 'dependencies.rb').open("w") do |file|
    file.write LOADER
  end
else
  vendor = Pathname.new("vendor")
  vendor.mkpath
  Dir.chdir(vendor.realpath)
  system("git clone git://github.com/#{ARGV[0]}.git #{ARGV[0]}")
  if ARGV[1]
    Dir.chdir(ARGV[0])
    system("git checkout #{ARGV[1]}")
  end
end</programlisting><para>As you can see, it’s not a ton of code, even though it does a lot.
      Let’s shine the spotlight on the interesting <literal moreinfo="none">Pathname</literal>
      bits:</para><programlisting id="I_programlisting4_d1e5155" format="linespecific">WORKING_DIR = Pathname.getwd</programlisting><para>Here we are simply assigning the initial working directory to a
      constant. We use this to build up the code for the
      <filename moreinfo="none">dependencies.rb</filename> stub script that can be generated
      via <literal moreinfo="none">mooch init</literal>. Here we’re just doing
      quick-and-dirty code generation, and you can see the full stub as stored
      in <literal moreinfo="none">LOADER</literal>:</para><programlisting id="I_programlisting4_d1e5169" format="linespecific">LOADER = %Q{
  require "pathname"

  Pathname.glob("#{WORKING_DIR}/vendor/*/*/") do |dir|
    lib = dir + "lib"
    $LOAD_PATH.push(lib.directory? ? lib : dir)
  end
}</programlisting><para>This script does something fun. It looks in the working directory
      that <literal moreinfo="none">mooch init</literal> was run in for a folder called
      <filename moreinfo="none">vendor</filename>, and then looks for folders two levels deep
      fitting the GitHub convention of <filename moreinfo="none">username/project</filename>.
      We then use a <literal moreinfo="none">glob</literal> to traverse the directory
      structure, in search of folders to add to the loadpath. The code will
      check to see whether each project has a <filename moreinfo="none">lib</filename> folder
      within it (as is the common Ruby convention), but will add the project
      folder itself to the loadpath if it is not present.</para><para>Here we notice a few of <literal moreinfo="none">Pathname</literal>’s niceties.
      You can see we can construct new paths by just adding new strings to
      them, as shown here:</para><programlisting id="I_programlisting4_d1e5193" format="linespecific">lib = dir + "lib"</programlisting><para>In addition to this, we can check to see whether the path we’ve
      created actually points to a directory on the filesystem, via a simple
      <literal moreinfo="none">Pathname#directory?</literal> call. This makes
      traversal downright easy, as you can see in the preceding code.</para><para>This simple stub may be a bit dense, but once you get the hang of
      <literal moreinfo="none">Pathname</literal>, you can see that it’s quite powerful. Let’s
      look at a couple more tricks, focusing this time on the code that
      actually writes this snippet to file:</para><programlisting id="I_programlisting4_d1e5205" format="linespecific">lib = Pathname.new(ARGV[1])
lib.mkpath
(lib + 'dependencies.rb').open("w") do |file|
  file.write LOADER
end</programlisting><para>Before, the invocation looked like this:</para><programlisting id="I_programlisting4_d1e5209" format="linespecific">$ mooch init lib/my_project</programlisting><para>Here, <literal moreinfo="none">ARGV[1]</literal> is
      <filename moreinfo="none">lib/my_project</filename>. So, in the preceding code, you can
      see we’re building up a relative path to our current working directory
      and then creating a folder structure. A very cool thing about
      <literal moreinfo="none">Pathname</literal> is that it works in a similar way to
      <literal moreinfo="none">mkdir -p</literal> on <phrase role="keep-together">*nix</phrase>, so <literal moreinfo="none" role="keep-together">Pathname#mkpath</literal> will actually create any
      necessary nesting directories as needed, and won’t complain if the
      structure already exists, which are both results that we want
      here.</para><para>Once we build up the directories, we need to create our
      <filename moreinfo="none">dependencies.rb</filename> file and populate it with the
      string in <literal moreinfo="none">LOADER</literal>. We can see here
      that <literal moreinfo="none">Pathname</literal> provides shortcuts that work in a
      similar fashion to <literal moreinfo="none">File.open()</literal>.</para><para>In the code that actually downloads and vendors libraries from
      GitHub, we see the same techniques in use yet again, this time mixed in
      with some shell commands and <literal moreinfo="none">Dir.chdir</literal>. As this doesn’t introduce anything
      new, we can skip over the details.</para><para>Before we move on to discussing temporary files, we’ll take a
      quick look at <literal moreinfo="none">FileUtils</literal>. The purpose
      of this module is to provide a Unix-like interface to file manipulation
      tasks, and a quick look at its method list will show that it does a good
      job of this:<indexterm id="I_indexterm4_d1e5257" significance="normal"><primary>fileutils standard library</primary></indexterm></para><programlisting id="I_programlisting4_d1e5260" format="linespecific">cd(dir, options)
cd(dir, options) {|dir| .... }
pwd()
mkdir(dir, options)
mkdir(list, options)
mkdir_p(dir, options)
mkdir_p(list, options)
rmdir(dir, options)
rmdir(list, options)
ln(old, new, options)
ln(list, destdir, options)
ln_s(old, new, options)
ln_s(list, destdir, options)
ln_sf(src, dest, options)
cp(src, dest, options)
cp(list, dir, options)
cp_r(src, dest, options)
cp_r(list, dir, options)
mv(src, dest, options)
mv(list, dir, options)
rm(list, options)
rm_r(list, options)
rm_rf(list, options)
install(src, dest, mode = &lt;src's&gt;, options)
chmod(mode, list, options)
chmod_R(mode, list, options)
chown(user, group, list, options)
chown_R(user, group, list, options)
touch(list, options)</programlisting><para>You’ll see a bit more of <literal moreinfo="none">FileUtils</literal> later on in the chapter when we talk
      about atomic saves. But before we jump into advanced file management
      techniques, let’s review <phrase role="keep-together">another</phrase>
      important foundational tool: the <filename moreinfo="none">tempfile</filename> standard
      library.<indexterm id="I_indexterm4_d1e5273" class="endofrange" startref="ch04_filesPathnameFileUtils" significance="normal"/></para></sect2></sect1><sect1 id="I_sect14_d1e5274"><title>The tempfile Standard Library</title><para>Producing temporary files is a common need in many applications.
    Whether you need to store something on disk to keep it out of memory until
    it is needed again, or you want to serve up a file but don’t need to keep
    it lurking around after your process has terminated, odds are you’ll run
    into this problem sooner or later.<indexterm class="startofrange" id="ch04_tempfile" significance="normal"><primary>tempfile standard library</primary></indexterm><indexterm class="startofrange" id="ch04_filestempfile" significance="normal"><primary>file management</primary><secondary>using tempfile standard library</secondary></indexterm></para><para>It’s quite tempting to roll our own <literal moreinfo="none">Tempfile</literal>
    support, which might look something like the following code:</para><programlisting id="I_programlisting4_d1e5292" format="linespecific">File.open("/tmp/foo.txt","w") do |file|
  file &lt;&lt; some_data
end

# Then in some later code

File.foreach("/tmp/foo.txt") do |line|
  # do something with data
end

# Then finally
require "fileutils"
FileUtils.rm("/tmp/foo.txt")</programlisting><para>This code works, but it has some drawbacks. The first is that it
    assumes that you’re on a *nix system with a <filename moreinfo="none">/tmp</filename>
    directory. Secondly, we don’t do anything to avoid file collisions, so if
    another application is using <filename moreinfo="none">/tmp/foo.txt</filename>, this will
    overwrite it. Finally, we need to explicitly remove the file, or risk
    leaving a bunch of trash around.</para><para>Luckily, Ruby has a standard library that helps us get around these
    issues. Using it, our example then looks like this:</para><programlisting id="I_programlisting4_d1e5304" format="linespecific">require "tempfile"
temp = Tempfile.new("foo.txt")
temp &lt;&lt; some_data

# then in some later code
temp.rewind
temp.each do |line|
  # do something with data
end

# Then finally
temp.close</programlisting><para>Let’s take a look at what’s going on in a little more detail, to
    really get a sense of what the <filename moreinfo="none">tempfile</filename> library is
    doing for us.</para><sect2><title>Automatic Temporary Directory Handling</title><para>The code looks somewhat similar to our original example, as we’re
      still essentially working with an <literal moreinfo="none">IO</literal> object. However,
      the approach is different. <literal moreinfo="none">Tempfile</literal> opens up a file
      handle for us to a file that is stored in whatever your system’s
      <filename moreinfo="none">tempdir</filename> is. We can inspect this value, and even
      change it if we need to. Here’s what it looks like on two of my
      systems:<indexterm id="I_indexterm4_d1e5325" significance="normal"><primary>directories, temporary</primary></indexterm><indexterm id="I_indexterm4_d1e5328" significance="normal"><primary>tempfile standard library</primary><secondary>automatic handling of temporary directory</secondary></indexterm></para><programlisting id="I_programlisting4_d1e5333" format="linespecific">&gt;&gt; Dir.tmpdir
=&gt; "/var/folders/yH/yHvUeP-oFYamIyTmRPPoKE+++TI/-Tmp-"

&gt;&gt; Dir.tmpdir
=&gt; "/tmp"</programlisting><para>Usually, it’s best to go with whatever this value is, because it
      is where Ruby thinks your temp files should go. However, in the cases
      where we want to control this ourselves, it is simple to do so, as shown
      in the following:</para><programlisting id="I_programlisting4_d1e5337" format="linespecific">temp = Tempfile.new("foo.txt", "path/to/my/tmpdir")</programlisting></sect2><sect2><title>Collision Avoidance</title><para>When you create a temporary file with
      <literal moreinfo="none">Tempfile.new</literal>, you aren’t actually specifying an exact
      filename. Instead, the filename you specify is used as a base name that
      gets a unique identifier appended to it. This prevents one temp file
      from accidentally overwriting another. Here’s a trivial example that
      shows what’s going on under the hood:<indexterm id="I_indexterm4_d1e5347" significance="normal"><primary>tempfile standard library</primary><secondary>name collision avoidance</secondary></indexterm></para><programlisting id="I_programlisting4_d1e5352" format="linespecific">&gt;&gt; a = Tempfile.new("foo.txt")
=&gt; #&lt;File:/tmp/foo.txt.2021.0&gt;
&gt;&gt; b = Tempfile.new("foo.txt")
=&gt; #&lt;File:/tmp/foo.txt.2021.1&gt;
&gt;&gt; a.path
=&gt; "/tmp/foo.txt.2021.0"
&gt;&gt; b.path
=&gt; "/tmp/foo.txt.2021.1"</programlisting><para>Allowing Ruby to handle collision avoidance is generally a good
      thing, especially if you don’t normally care about the exact names of
      your temp files. Of course, we can always rename the file if we need to
      store it somewhere permanently.</para></sect2><sect2><title>Same Old I/O Operations</title><para>Because we’re dealing with an object that delegates most of its
      functionality directly to <literal moreinfo="none">File</literal>, we
      can use normal <literal moreinfo="none">File</literal> methods, as shown
      in our example. For this reason, we can write to our file handle as
      expected:<indexterm id="I_indexterm4_d1e5367" significance="normal"><primary>input and output</primary><secondary>temporary files</secondary></indexterm><indexterm id="I_indexterm4_d1e5372" significance="normal"><primary>tempfile standard library</primary><secondary>I/O operations, using File methods</secondary></indexterm></para><programlisting id="I_programlisting4_d1e5377" format="linespecific">temp &lt;&lt; some_data</programlisting><para>and read from it in a similar fashion:</para><programlisting id="I_programlisting4_d1e5381" format="linespecific"># then in some later code
temp.rewind
temp.each do |line|
  # do something with data
end</programlisting><para>Because we leave the file handle open, we need to rewind it to
      point to the beginning of the file rather than the end. Beyond that, the
      behavior is exactly the same as <literal moreinfo="none">File#each</literal>.</para></sect2><sect2><title>Automatic Unlinking</title><para><literal moreinfo="none">Tempfile</literal> cleans up after itself. There are two
      main ways of unlinking a file; which one is correct depends on your
      needs. Simply closing the file handle is good enough, and it is what we
      use in our example:<indexterm id="I_indexterm4_d1e5396" significance="normal"><primary>tempfile standard library</primary><secondary>automatic file unlinking</secondary></indexterm></para><programlisting id="I_programlisting4_d1e5401" format="linespecific">temp.close</programlisting><para>In this case, Ruby doesn’t remove the temporary file right away.
      Instead, it will keep it around until all references to
      <literal moreinfo="none">temp</literal> have been garbage-collected. For this reason, if
      <phrase role="keep-together">keeping</phrase> lots of open file handles
      around is a problem for you, you can actually close your handles without
      fear of losing your temp file, as long as you keep a reference to it
      handy.</para><para>However, in other situations, you may want to purge the file as
      soon as it has been closed. The change to make this happen is
      trivial:</para><programlisting id="I_programlisting4_d1e5413" format="linespecific">temp.close!</programlisting><?dbfo-need height=”1in”
?><para>Finally, if you need to explicitly delete a file that has already
      been closed, you can just use the following:</para><programlisting id="I_programlisting4_d1e5418" format="linespecific">temp.unlink</programlisting><para>In practice, you don’t need to think about this in most cases.
      Instead, <filename moreinfo="none">tempfile</filename> works as you might expect,
      keeping your files around while you need them and cleaning up after
      itself when it needs to. If you forget to close a temporary file
      explicitly, it’ll be unlinked when the process exits. For these reasons,
      using the <emphasis>tempfile</emphasis> library is often a better choice
      than rolling your own solution.</para><para>There is more to be said about this very cool library, but what
      we’ve already discussed covers most of what you’ll need day to day, so
      now is a fine time to go over what’s been said and move on to the next
      thing.</para><para>We’ve gone over some of the tools Ruby provides for working with
      your filesystem in a platform-agnostic way, and we’re about to get into
      some more advanced strategies for managing, processing, and manipulating
      your files and their contents. However, before we do that, let’s review
      the key points about working with your filesystem and with temp
      files:<indexterm id="I_indexterm4_d1e5433" significance="normal"><primary>file management</primary><secondary>key points of working with filesystem and temp
          files</secondary></indexterm></para><itemizedlist><listitem><para>There are a whole slew of options for file management in Ruby,
          including <literal moreinfo="none" role="keep-together">FileUtils</literal>, <literal moreinfo="none">Dir</literal>, and <literal moreinfo="none">Pathname</literal>, with some overlap between
          them.</para></listitem><listitem><para><literal moreinfo="none">Pathname</literal> provides a
          high-level, modern Ruby interface to managing files and traversing
          your filesystem.</para></listitem><listitem><para><literal moreinfo="none">FileUtils</literal> provides a
          *nix-style API to file management tools, but works just fine on any
          system, making it quite useful for porting shell scripts to
          Ruby.</para></listitem><listitem><para>The <filename moreinfo="none">tempfile</filename> standard library provides a
          convenient IO-like class for dealing with temp files in a
          system-independent way.</para></listitem><listitem><para>The <filename moreinfo="none">tempfile</filename> library also helps make
          things easier through things like name collision avoidance,
          automatic file unlinking, and other niceties.</para></listitem></itemizedlist><para>With these things in mind, we’ll see more of the techniques shown
      in this section later on in the chapter. But if you’re bored with the
      basics, now is the time to look at higher-level strategies for doing
      common I/O tasks.<indexterm id="I_indexterm4_d1e5475" class="endofrange" startref="ch04_tempfile" significance="normal"/><indexterm id="I_indexterm4_d1e5476" class="endofrange" startref="ch04_filestempfile" significance="normal"/></para></sect2></sect1><sect1 id="I_sect14_d1e5477"><title>Text-Processing Strategies</title><para>Ruby makes basic I/O operations dead simple, but this doesn’t mean
    it’s a bad idea to pick up and apply some general approaches to text
    processing. Here we’ll talk about two techniques that most programmers
    doing file processing will want to know about, and you’ll see what they
    look like in Ruby.</para><sect2><title>Advanced Line Processing</title><para>The case study for this chapter showed the most common use of
      <literal moreinfo="none">File.foreach()</literal>, but there is more to
      be said about this approach. This section will highlight a couple of
      tricks worth knowing about when doing line-by-line processing.<indexterm class="startofrange" id="ch04_textlinebyline" significance="normal"><primary>text processing</primary><secondary>line-by-line, advanced techniques</secondary></indexterm></para><sect3><title>Using Enumerator</title><para>The following example shows code that extracts and sums the
        totals found in a file that has entries similar to these:<indexterm id="I_indexterm4_d1e5500" significance="normal"><primary>Enumerator objects</primary><secondary>using in file line-by-line processing</secondary></indexterm><indexterm id="I_indexterm4_d1e5505" significance="normal"><primary>text processing</primary><secondary>line-by-line, advanced techniques</secondary><tertiary>using Enumerator</tertiary></indexterm></para><programlisting id="I_programlisting4_d1e5512" format="linespecific">some
lines
of
text
total: 12

other
lines
of
text
total: 16

more
text
total: 3</programlisting><para>The following code shows how to do this without loading the
        whole file into memory:</para><programlisting id="I_programlisting4_d1e5516" format="linespecific">sum = 0
File.foreach("data.txt") { |line| sum += line[/total: (\d+)/,1].to_f }</programlisting><para>Here, we are using <literal moreinfo="none">File.foreach</literal> as a direct iterator, and
        building up our sum as we go. However, because <literal moreinfo="none">foreach()</literal> returns an <literal moreinfo="none">Enumerator</literal>, we can actually write this in a
        cleaner way without sacrificing efficiency:<indexterm id="I_indexterm4_d1e5529" significance="normal"><primary>File.foreach( ) method</primary></indexterm></para><programlisting id="I_programlisting4_d1e5532" format="linespecific">enum = File.foreach("data.txt")
sum = enum.inject(0) { |s,r| s + r[/total: (\d+)/,1].to_f }</programlisting><para>The primary difference between the two approaches is that when
        you use <literal moreinfo="none" role="keep-together">File.foreach</literal> directly with a block, you
        are simply iterating line by line over the file, whereas <literal moreinfo="none">Enumerator</literal> gives you some more powerful ways
        of processing your data.</para><para>When we work with arrays, we don’t usually write code like
        this:</para><programlisting id="I_programlisting4_d1e5544" format="linespecific">sum = 0
arr.each { |e| sum += e }</programlisting><para>Instead, we typically let Ruby do more of the work for
        us:</para><programlisting id="I_programlisting4_d1e5549" format="linespecific">sum = arr.inject(0) { |s,e| s + e }</programlisting><para>For this reason, we should do the same thing with files. If we
        have an <literal moreinfo="none">Enumerable</literal> method we want
        to use to transform or process a file, we should use the enumerator
        provided by <literal moreinfo="none">File.foreach()</literal> rather
        than try to do our processing within the block. This will allow us to
        leverage the power behind Ruby’s <literal moreinfo="none">Enumerable</literal> module rather than doing the
        heavy lifting ourselves.</para></sect3><sect3><title>Tracking line numbers</title><para>If you’re interested in certain line numbers, there is no need
        to maintain a manual counter. You simply need to create a file handle
        to work with, and then make use of the <literal moreinfo="none">File#lineno</literal> method. To illustrate this, we
        can very easily implement the Unix command
        <literal moreinfo="none">head</literal>:<indexterm id="I_indexterm4_d1e5573" significance="normal"><primary>text processing</primary><secondary>line-by-line, advanced techniques</secondary><tertiary>tracking line numbers</tertiary></indexterm><indexterm id="I_indexterm4_d1e5580" significance="normal"><primary>File#lineno method</primary></indexterm></para><programlisting id="I_programlisting4_d1e5583" format="linespecific">def head(file_name,max_lines = 10)
  File.open(file_name) do |file|
    file.each do |line|
      puts line
      break if file.lineno == max_lines
    end
  end
end</programlisting><para>For a more interesting use case, we can consider a file that is
        formatted in two line pairs, the first line a key, the second a
        value:</para><programlisting id="I_programlisting4_d1e5587" format="linespecific">first name
gregory
last name
brown
email
gregory.t.brown@gmail.com</programlisting><para>Using <literal moreinfo="none">File#lineno</literal>, this is
        trivial to process:</para><programlisting id="I_programlisting4_d1e5594" format="linespecific">keys   = []
values = []

File.open("foo.txt") do |file|
  file.each do |line|
    (file.lineno.odd? ? keys : values) &lt;&lt; line.chomp
  end
end

Hash[*keys.zip(values).flatten]</programlisting><para>The result of this code is a simple hash, as you might
        expect:</para><programlisting id="I_programlisting4_d1e5598" format="linespecific"> { "first name" =&gt; "gregory",
   "last name"  =&gt; "brown",
   "email"      =&gt; "gregory.t.brown@gmail.com" }</programlisting><para>Though there is probably more we can say about iterating over
        files line by line, this should get you well on your way. For now,
        there are other important I/O strategies to investigate, so we’ll keep
        moving.<indexterm id="I_indexterm4_d1e5602" class="endofrange" startref="ch04_textlinebyline" significance="normal"/></para></sect3></sect2><sect2><title>Atomic Saves</title><para>Although many file processing scripts can happily read in one file
      as input and produce another as output, sometimes we want to be able to
      do transformations directly on a single file. This isn’t hard in
      practice, but it’s a little bit less obvious than you might
      think.<indexterm id="I_indexterm4_d1e5608" significance="normal"><primary>saves, atomic</primary></indexterm><indexterm id="I_indexterm4_d1e5611" significance="normal"><primary>file management</primary><secondary>atomic saves</secondary></indexterm></para><para>It is technically possible to rewrite parts of a file using the
      <literal moreinfo="none">"r+"</literal> file mode, but in practice, this
      can be unwieldy in most cases. An alternative approach is to load the
      entire contents of a file into memory, manipulate the string, and then
      overwrite the original file. However, this approach is wasteful, and is
      not the best way to go in most cases.</para><para>As it turns out, there is a simple solution to this problem, and
      that is simply to work around it. Rather than trying to make direct
      changes to a file, or store a string in memory and then write it back
      out to the same file after manipulation, we can instead make use of a
      temporary file and do line-by-line processing as normal. When we finish
      the job, we can rename our temp file so as to replace the original.
      Using this approach, we can easily make a backup of the original file if
      necessary, and also roll back changes upon error.</para><para>Let’s take a quick look at an example that demonstrates this
      general strategy. We’ll build a script that strips comments from Ruby
      files, allowing us to take source code such as this:</para><programlisting id="I_programlisting4_d1e5625" format="linespecific"># The best class ever
# Anywhere in the world
class Foo

  # A useless comment
  def a
     true
  end

  #Another Useless comment
  def b
    false
  end

end</programlisting><para>and turn it into comment-free code such as this:</para><programlisting id="I_programlisting4_d1e5629" format="linespecific">class Foo

  def a
     true
  end

  def b
    false
  end

end</programlisting><para>With the help of Ruby’s <filename moreinfo="none">tempfile</filename> and
      <filename moreinfo="none">fileutils</filename> standard libraries, this task is
      trivial:<indexterm id="I_indexterm4_d1e5639" significance="normal"><primary>fileutils standard library</primary><secondary>using for atomic saves</secondary></indexterm><indexterm id="I_indexterm4_d1e5644" significance="normal"><primary>tempfile standard library</primary><secondary>using for atomic saves</secondary></indexterm></para><programlisting id="I_programlisting4_d1e5649" format="linespecific">require "tempfile"
require "fileutils"
temp = Tempfile.new("working")
File.foreach(ARGV[0]) do |line|
  temp &lt;&lt; line unless line =~ /^\s*#/
end

temp.close
FileUtils.mv(temp.path,ARGV[0])</programlisting><para>We initialize a new <literal moreinfo="none">Tempfile</literal>
      object and then iterate over the file specified on the command line. We
      append each line to the <literal moreinfo="none">Tempfile</literal>, as
      long as it is not a comment line. This is the first part of our
      task:</para><programlisting id="I_programlisting4_d1e5660" format="linespecific">temp = Tempfile.new("working")
File.foreach(ARGV[0]) do |line|
  temp &lt;&lt; line unless line =~ /^\s*#/
end

temp.close</programlisting><para>Once we’ve written our <literal moreinfo="none">Tempfile</literal>
      and closed the file handle, we then use <literal moreinfo="none">FileUtils</literal> to rename it and replace the
      original file we were working on:</para><programlisting id="I_programlisting4_d1e5670" format="linespecific">FileUtils.mv(temp.path,ARGV[0])</programlisting><para>In two steps, we’ve efficiently modified a file without loading it
      entirely into memory or dealing with the complexities of using the
      <literal moreinfo="none">r+</literal> file mode. In many cases, the simple approach
      shown here will be enough.</para><para>Of course, because you are modifying a file in place, a poorly
      coded script could risk destroying your input file. For this reason, you
      might want to make a backup of your file. This can be done trivially
      with <literal moreinfo="none">FileUtils.cp</literal>, as shown in the
      following reworked version of our example:</para><programlisting id="I_programlisting4_d1e5682" format="linespecific">require "tempfile"
require "fileutils"

temp = Tempfile.new("working")
File.foreach(ARGV[0]) do |line|
  temp &lt;&lt; line unless line =~ /^\s*#/
end

temp.close
FileUtils.cp(ARGV[0],"#{ARGV[0]}.bak")
FileUtils.mv(temp.path,ARGV[0])</programlisting><para>This code makes a backup of the original file only if the temp
      file is successfully populated, which prevents it from producing garbage
      during testing.</para><para>Sometimes it will make sense to do backups; other times, it won’t
      be essential. Of course, it’s better to be safe than sorry, so if you’re
      in doubt, just add the extra line of code for a bit more peace of
      mind.</para><para>The two strategies shown in this section will come up in practice
      again and again for those doing frequent text processing. They can even
      be used in combination when needed.</para><para>We’re about to close our discussion on this topic, but before we
      do that, it’s worth mentioning the following reminders:<indexterm id="I_indexterm4_d1e5692" significance="normal"><primary>file management</primary><secondary>atomic saves</secondary><tertiary>guidelines for</tertiary></indexterm><indexterm id="I_indexterm4_d1e5699" significance="normal"><primary>text processing</primary><secondary>line-by-line, advanced techniques</secondary><tertiary>guidelines for</tertiary></indexterm></para><itemizedlist><listitem><para>When doing line-based file processing, <literal moreinfo="none">File.foreach</literal> can be used as an <literal moreinfo="none" role="keep-together">Enumerator</literal>, unlocking
          the power of <literal moreinfo="none">Enumerable</literal>. This
          provides an extremely handy way to search, traverse, and manipulate
          files without sacrificing efficiency.</para></listitem><listitem><para>If you need to keep track of which line of a file you are on
          while you are iterating over it, you can use <literal moreinfo="none">File#lineno</literal> rather than incrementing your
          own counter.</para></listitem><listitem><para>When doing atomic saves, the <filename moreinfo="none">tempfile</filename>
          standard library can be used to avoid unnecessary clutter.</para></listitem><listitem><para>Be sure to test any code that does atomic saves thoroughly, as
          there is real risk of destroying your original source files if
          backups are not made.</para></listitem></itemizedlist></sect2></sect1><sect1 id="I_sect14_d1e5734"><title>Conclusions</title><para>When dealing with text processing and file management in Ruby, there
    are a few things to keep in mind. Most of the pitfalls you can run into
    while doing this sort of work tend to have to do with performance,
    platform dependence, or code that doesn’t clean up after itself.<indexterm id="I_indexterm4_d1e5739" significance="normal"><primary>performance</primary><secondary>text processing and file management</secondary></indexterm></para><para>In this chapter, we talked about a couple of standard libraries that
    can help keep things clean and platform-independent. Though Ruby is a fine
    language to write shell scripts in, there is often no need to resort to
    code that will run only on certain machines when a pure Ruby solution is
    just as clean. For this reason, using libraries such as
    <filename moreinfo="none">tempfile</filename>, <filename moreinfo="none">pathname</filename>, and
    <filename moreinfo="none">fileutils</filename> will go a seriously long way toward keeping
    your code portable and maintainable down the line.</para><para>For issues of performance, you can almost always squeeze out extra
    speed and minimize your memory footprint by processing your data line by
    line rather than slurping everything into a single string. You can also
    much more effectively find a needle in the haystack if you form
    well-crafted regular expressions that don’t make Ruby work too hard. The
    techniques we’ve shown here serve as reminders about common mistakes that
    even seasoned Rubyists tend to make, and provide good ways around
    them.</para><para>Text processing and file management can quickly become complex, but
    with a solid grasp of the fundamental strategies, you can use Ruby as an
    extremely powerful tool that works faster and more effectively than you
    might imagine.</para></sect1></chapter><chapter id="I_chapter5_d1e5759"><title>Functional Programming Techniques</title><para>It doesn’t take much time to realize that Ruby is a deeply
  object-oriented language that openly steals from the best of Smalltalk. But
  Matz is an equal-opportunity thief, and he has snatched features from
  various other languages as well, including Lisp. This means that although
  Ruby has its roots in object-oriented principles, we also have some of the
  high-level constructs that facilitate functional programming
  techniques.</para><para>Rightfully speaking, Ruby is not a functional programming language.
  Though it is possible to come close with great effort, Ruby simply lacks a
  number of the key aspects of functional languages. Virtually all state in
  Ruby is mutable, and because it is an object-oriented language, we tend to
  focus on state management rather than elimination of state. Ruby lacks tail
  call optimization,<footnote><para>This can be enabled in YARV at compile time, but it is still
      experimental.</para></footnote> making recursion highly inefficient. Beyond these key things,
  there are plenty of other subtleties that purists can discuss at length if
  you let them.</para><para>However, if you let Ruby be Ruby, you can benefit from certain
  functional techniques while still writing object-oriented code. This chapter
  will walk you through several practices that are inspired by functional
  languages and that have practical value for solving problems in Ruby. We’ll
  look at things like lazy evaluation, memoization, infinite lists,
  higher-order procedures, and other stuff that has a nice academic ring to
  it. Along the way, I’ll do my best to show you that this stuff isn’t simply
  abstract and mathematical, but can meaningfully be used in day-to-day
  code.</para><para>Let’s start by taking a look at how we’re already using lazy
  evaluation whether we realize it or not, and then walk through a popular
  Ruby library that can simplify this for us. As in other chapters, we’ll take
  a peek under the hood to see what’s really going on.</para><sect1 id="I_sect15_d1e5774"><title>Laziness Can Be a Virtue (A Look at lazy.rb)</title><para>If you’ve been writing Ruby for any amount of time, you’ve probably
    already written some code that makes use of lazy evaluation. Before we go
    further, let’s look at a couple examples of lazy code that you will likely
    recognize on sight, if not by name.<indexterm class="startofrange" id="ch05_lazyeval" significance="normal"><primary>lazy evaluation</primary></indexterm></para><para>For starters, <literal moreinfo="none">Proc</literal> objects are,
    by definition, lazy:<indexterm id="I_indexterm5_d1e5787" significance="normal"><primary>lazy evaluation</primary><secondary>Proc objects</secondary></indexterm><indexterm id="I_indexterm5_d1e5792" significance="normal"><primary>Proc objects</primary><secondary>lazy evaluation</secondary></indexterm></para><programlisting id="I_programlisting5_d1e5797" format="linespecific">a = lambda { File.read("foo.txt") }</programlisting><para>When you create a <literal moreinfo="none">Proc</literal> object
    using <literal moreinfo="none">lambda</literal>, the code is not actually
    executed until you call the block. Therefore, a <literal moreinfo="none">Proc</literal> is essentially a chunk of code that gets
    executed on demand, rather than in place. So if we actually wanted to read
    the contents of this file, we’d need to do this:</para><programlisting id="I_programlisting5_d1e5810" format="linespecific">b = a.call</programlisting><para>In essence, code is said to be evaluated lazily if it is executed
    only at the time it is actually needed, not at the time it was defined.
    However, this behavior is not necessarily limited to blocks; we can do
    this with populating data for our objects as well. Let’s take a look at a
    simplified model of Prawn’s table cells for a more complete
    example:<indexterm id="I_indexterm5_d1e5814" significance="normal"><primary>lazy evaluation</primary><secondary>Cell objects</secondary></indexterm><indexterm class="startofrange" id="ch05_Cell" significance="normal"><primary>Cell objects</primary></indexterm></para><programlisting id="I_programlisting5_d1e5822" format="linespecific">class Cell

  FONT_HEIGHT = 10
  FONT_WIDTH  = 8

  def initialize(text)
    @text = text
  end

  attr_accessor :text
  attr_writer :width, :height

  def width
    @width ||= calculate_width
  end

  def height
    @height ||= calculate_height
  end

  def to_s
    "Cell(#{width}x#{height})"
  end

  private

  def calculate_height
    @text.lines.count * FONT_HEIGHT
  end

  def calculate_width
    @text.lines.map { |e| e.length }.max * FONT_WIDTH
  end

end</programlisting><para>In this example, <literal moreinfo="none">Cell#width</literal> and
    <literal moreinfo="none">Cell#height</literal> can be calculated based on
    the text in the cell, or they can be manually set. Because we don’t need
    to know the exact dimensions of a cell until we render it, this is a
    perfect case for lazy evaluation. Even though the calculations may not be
    expensive on their own, they add up when dealing with thousands or
    hundreds of thousands of cells. Luckily, it’s easy to avoid any
    unnecessary work.<indexterm id="I_indexterm5_d1e5832" significance="normal"><primary>Cell#height method</primary></indexterm><indexterm id="I_indexterm5_d1e5835" significance="normal"><primary>Cell#width method</primary></indexterm></para><para>By just looking at the core bits of this object, we can get a
    clearer sense of what’s going on:</para><programlisting id="I_programlisting5_d1e5840" format="linespecific">class Cell
  attr_writer :width, :height

  def width
    @width ||= calculate_width
  end

  def height
    @height ||= calculate_height
  end
end</programlisting><para>It should now be plain to see what’s happening. If <literal moreinfo="none">@width</literal> or <literal moreinfo="none">@height</literal> have already been set, their
    calculations are never run. We also can see that these calculations will
    in the worst case be run exactly once, storing the return value as
    needed.</para><para>The idea here is that now we won’t have to worry about calculating
    dimensions of preset <literal moreinfo="none">Cell</literal> objects, and
    that those that calculate their dimensions will not need to repeat that
    calculation each time they are used. I am hoping that readers are familiar
    with this Ruby idiom already, but if you are struggling with it a little
    bit, just stop for a moment and toy with this in <emphasis>irb</emphasis>
    and it should quickly become clear how things work:</para><programlisting id="I_programlisting5_d1e5859" format="linespecific">&gt;&gt; cell = Cell.new("Chunky Bacon\nIs Very\nDelicious")
&gt;&gt; cell.width = 1000
=&gt; 1000
&gt;&gt; cell.to_s
=&gt; "Cell(1000x30)"
&gt;&gt; cell.height = 500
=&gt; 500
&gt;&gt; cell.to_s
=&gt; "Cell(1000x500)"</programlisting><para>Though this process is relatively straightforward, we can probably
    make it better. It’s sort of annoying to have to build special accessors
    for our <literal moreinfo="none">@width</literal> and <literal moreinfo="none">@height</literal> when what we’re ultimately doing is
    setting default values for them, which is normally something we do in our
    constructor. What’s more, our solution feels a little primitive in nature,
    at least aesthetically.</para><para>This is where MenTaLguY’s <emphasis>lazy.rb</emphasis> comes in. It
    provides a method called <literal moreinfo="none">promise()</literal> that
    does exactly what we want, in a much nicer way. The following code can be
    used to replace our original implementation:<indexterm class="startofrange" id="ch05_Mentalguylazyrb" significance="normal"><primary>MenTaLguY, lazy.rb</primary></indexterm><indexterm class="startofrange" id="ch05_lazyrb" significance="normal"><primary>lazy.rb</primary></indexterm><indexterm id="I_indexterm5_d1e5883" significance="normal"><primary>promise( ) method</primary></indexterm></para><?dbfo-need height=”1in”
?><programlisting id="I_programlisting5_d1e5887" format="linespecific">require "lazy"

class Cell

  FONT_HEIGHT = 10
  FONT_WIDTH  = 8

  def initialize(text)
    @text   = text
    @width  = promise { calculate_width }
    @height = promise { calculate_height }
  end

  attr_accessor :text, :width, :height

  def to_s
    "Cell(#{width}x#{height})"
  end

  private

  def calculate_height
    @text.lines.count * FONT_HEIGHT
  end

  def calculate_width
    @text.lines.map { |e| e.length }.max * FONT_WIDTH
  end

end</programlisting><para>Gone are our special accessors, and in their place, we have simple
    <literal moreinfo="none">promise()</literal> calls in our constructor.
    This method returns a simple proxy object that wraps a block of code that
    is designed to be executed later. Once you call any methods on this
    object, it passes them along to whatever your block evaluates to. If this
    is tough to get your head around, again <emphasis>irb</emphasis> is your
    friend:</para><programlisting id="I_programlisting5_d1e5897" format="linespecific">&gt;&gt; a = promise { 1 }
=&gt; #&lt;Lazy::Promise computation=#&lt;Proc:0x3ce218@(irb):2&gt;&gt;
&gt;&gt; a + 3
=&gt; 4
&gt;&gt; a
=&gt; 1</programlisting><para><literal moreinfo="none">Lazy::Promise</literal> objects are very
    cool, but a little bit sneaky. Because they essentially work the same as
    the evaluated object once the block is run once, it’s hard to know that
    you’re actually working with a proxy object. But if we dig deep, we can
    find the truth:<indexterm id="I_indexterm5_d1e5903" significance="normal"><primary>Promise objects</primary></indexterm><indexterm id="I_indexterm5_d1e5906" significance="normal"><primary>Lazy::Promise objects</primary></indexterm></para><programlisting id="I_programlisting5_d1e5909" format="linespecific">&gt;&gt; a.class
=&gt; Fixnum
&gt;&gt; a.__class__
=&gt; Lazy::Promise</programlisting><para>If we try out the same examples we did before with <literal moreinfo="none">Cell</literal>, you’ll see it works as expected:</para><programlisting id="I_programlisting5_d1e5917" format="linespecific">&gt;&gt; cell = Cell.new("Chunky Bacon\nIs Very\nDelicious")
&gt;&gt; cell.width = 1000
=&gt; 1000
&gt;&gt; cell.to_s
=&gt; "Cell(1000x30)"
&gt;&gt; cell.height = 500
=&gt; 500
&gt;&gt; cell.to_s
=&gt; "Cell(1000x500)"</programlisting><para>Seeing that the output is the same, we can be satisfied knowing that
    our <emphasis>lazy.rb</emphasis> solution will do the trick, while making
    our code look a little cleaner. However, we shouldn’t just pass the work
    that <literal moreinfo="none">promise()</literal> is doing off as magic—it
    is worth looking at both for enrichment and because it’s genuinely cool
    code.<indexterm id="I_indexterm5_d1e5927" class="endofrange" startref="ch05_Cell" significance="normal"/></para><para>I’ve gone ahead and simplified the implementation of <literal moreinfo="none">Lazy::Promise</literal> a bit, removing some of the
    secondary features while still preserving the core functionality. We’re
    going to look at the naive implementation, but please use this only for
    studying. The official version from MenTaLguY can handle thread
    synchronization and does much better error handling than what you will see
    here, so that’s what you’ll want if you plan to use
    <emphasis>lazy.rb</emphasis> in real code.<indexterm id="I_indexterm5_d1e5936" significance="normal"><primary>Lazy::Promise objects</primary><secondary>implementing in Ruby 1.9</secondary></indexterm></para><para>That all having been said, here’s how you’d go about implementing a
    basic <literal moreinfo="none">Promise</literal> object on Ruby
    1.9:</para><programlisting id="I_programlisting5_d1e5946" format="linespecific">module NaiveLazy
  class Promise &lt; BasicObject

    def initialize(&amp;computation)
      @computation = computation
    end

    def __result__
      if @computation
        @result       = @computation.call
        @computation  = nil
      end

      @result
    end

    def inspect
      if @computation
        "#&lt;NaiveLazy::Promise computation=#{ @computation.inspect }&gt;"
      else
        @result.inspect
      end
    end

    def respond_to?( message )
      message = message.to_sym
      [:__result__, :inspect].include?(message) ||
        __result__.respond_to? message
    end

    def method_missing(*a, &amp;b)
      __result__.__send__(*a, &amp;b)
    end

  end
end</programlisting><para>Though compact, this might look a little daunting in one big chunk,
    so let’s break it down. First, you’ll notice that <literal moreinfo="none">NaiveLazy::Promise</literal> inherits from <literal moreinfo="none">BasicObject</literal> rather than <literal moreinfo="none">Object</literal>:</para><programlisting id="I_programlisting5_d1e5959" format="linespecific">module NaiveLazy
  class Promise &lt; BasicObject

  end
end</programlisting><para><literal moreinfo="none">BasicObject</literal> omits most of the
    methods you’ll find on <literal moreinfo="none">Object</literal>, making
    it so you don’t need to explicitly remove those methods on your own in
    order to create a proxy object. This in effect gives you a blank slate
    object, which is exactly what we want for our current purposes.</para><para>The proxy itself works through <literal moreinfo="none">method_missing</literal>, handing virtually all messages
    to the result of <literal moreinfo="none">Promise#__result__</literal>:</para><programlisting id="I_programlisting5_d1e5976" format="linespecific">module NaiveLazy
  class Promise &lt; BasicObject
    def method_missing(*a, &amp;b)
      __result__.__send__(*a, &amp;b)
    end
  end
end</programlisting><para>For the uninitiated, this code essentially just allows <literal moreinfo="none">promise.some_function</literal> to be interpreted as
    <literal moreinfo="none">promise.__result__.some_function</literal>, which
    makes sense when we recall how things worked in
    <literal moreinfo="none">Cell</literal>:</para><programlisting id="I_programlisting5_d1e5990" format="linespecific">&gt;&gt; cell.width
=&gt; #&lt;Lazy::Promise computation=#&lt;Proc:...&gt;&gt;
&gt;&gt; cell.width + 10
=&gt; 114</programlisting><para><literal moreinfo="none">Lazy::Promise</literal> knew how to
    evaluate the computation and then pass your message to its result. This
    <literal moreinfo="none">method_missing</literal> trick is how it works
    under the hood. When we go back and look at how <literal moreinfo="none">__result__</literal> is implemented, this becomes even
    more clear:<indexterm id="I_indexterm5_d1e6002" significance="normal"><primary>Lazy::Promise objects</primary><secondary>use of method_missing</secondary></indexterm><indexterm id="I_indexterm5_d1e6007" significance="normal"><primary>method_missing( ) method</primary><secondary>use by Lazy::Promise</secondary></indexterm></para><programlisting id="I_programlisting5_d1e6012" format="linespecific">module NaiveLazy
  class Promise &lt; BasicObject

    def initialize(&amp;computation)
      @computation = computation
    end
<?dbfo-need height=”1in”
?>
    def __result__
      if @computation
        @result       = @computation.call
        @computation  = nil
      end

      @result
    end

    def method_missing(*a, &amp;b)
      __result__.__send__(*a, &amp;b)
    end

  end
end</programlisting><para>When we create a new <literal moreinfo="none">promise</literal>, it stores a code
    block to be executed later. Then, when you call a method on the
    <literal moreinfo="none">promise</literal> object, <literal moreinfo="none">method_missing</literal> runs the <literal moreinfo="none">__result__</literal> method. This method checks to see
    whether there is a <literal moreinfo="none">Proc</literal> object in
    <literal moreinfo="none">@computation</literal> that needs to be
    evaluated. If there is, it stores the return value of that code, and then
    wipes out the <literal moreinfo="none">@computation</literal>. Further
    calls to <literal moreinfo="none">__result__</literal> return this value
    immediately.</para><para>On top of this, we add a couple of methods to make the proxy more
    well behaved, so that you can fully treat an evaluated promise as if it
    were just an ordinary value:</para><programlisting id="I_programlisting5_d1e6045" format="linespecific">module NaiveLazy
  class Promise &lt; BasicObject

    # ...

    def inspect
      if @computation
        "#&lt;NaiveLazy::Promise computation=#{ @computation.inspect }&gt;s"
      else
        @result.inspect
      end
    end

    def respond_to?( message )
      message = message.to_sym
      [:__result__, :inspect].include?(message) or
        __result__.respond_to? message
    end

    # ...
  end
end</programlisting><para>I won’t go into much detail about this code—both of these methods
    essentially just forward everything they can to the evaluated object, and
    are nothing more than <phrase role="keep-together">underplumbing</phrase>.
    However, because these round out the full object, you’ll see them in
    action when we take our new <literal moreinfo="none">NaiveLazy::Promise</literal> for a spin:</para><programlisting id="I_programlisting5_d1e6055" format="linespecific">&gt;&gt; num = NaiveLazy::Promise.new { 3 }
=&gt; #&lt;NaiveLazy::Promise computation=#&lt;Proc:0x3cfd98@(irb):2&gt;
&gt;&gt; num + 100
=&gt; 103
&gt;&gt; num
=&gt; 3
&gt;&gt; num.respond_to?(:times)
=&gt; true
&gt;&gt; num.class
=&gt; Fixnum</programlisting><para>So what we have here is an implementation of a proxy object that
    doesn’t produce an exact value until it absolutely has to. This proxy is
    fully transparent, so even though <literal moreinfo="none">num</literal>
    here is actually a <literal moreinfo="none">NaiveLazy::Promise</literal>
    instance, not a <literal moreinfo="none">Fixnum</literal>, other objects
    in your system won’t know or care. This can be pretty handy when delaying
    your calculations until the last possible moment is important.</para><para>The reason I showed how to implement a <literal moreinfo="none">promise</literal> is
    to give you a sense of what the primitive tools in Ruby are capable of
    doing. We’ve seen blocks used in a lot of different ways throughout Ruby,
    but this particular case might be easy to overlook. Another interesting
    factor here is that although this concept belongs to the functional
    programming paradigm, it is also easy to implement using Ruby’s
    object-oriented principles.</para><para>As we move on to look at other techniques in this chapter, keep this
    general idea in mind. Much will be lost in translation if you try to
    directly convert functional concepts into Ruby, but by playing to Ruby’s
    strengths, you can often preserve the idea without things feeling
    alien.</para><para>We’re about to look at some other things that are handy to have in
    your tool belt, but before we do that, I’ll reiterate some key points
    about lazy evaluation in Ruby:<indexterm id="I_indexterm5_d1e6078" significance="normal"><primary>lazy evaluation</primary><secondary>summary of key points</secondary></indexterm></para><itemizedlist><listitem><para>Lazy evaluation is useful when you have some code that may never
        need to be run, or would best be run as late as possible, especially
        if this code is expensive computationally. If you do not have this
        need, it is better to do without the overhead.</para></listitem><listitem><para>All code blocks in Ruby are lazy, and are not executed until
        explicitly called.</para></listitem><listitem><para>For simple needs, you can build attribute accessors for your
        objects that avoid running a calculation until they are called,
        storing the result in an instance variable once it is executed.</para></listitem><listitem><para>MenTaLguY’s <emphasis>lazy.rb</emphasis> provides a more
        comprehensive solution for lazy evaluation, which can be made to be
        thread-safe and is generally more robust than the naive example shown
        in this chapter.</para></listitem></itemizedlist><para>We’ll now move on to the sticky issue of state maintenance and side
    effects, as this is a key aspect of functional programming that goes a
    little against the grain of traditional Ruby code.<indexterm id="I_indexterm5_d1e6101" class="endofrange" startref="ch05_lazyrb" significance="normal"/><indexterm id="I_indexterm5_d1e6102" class="endofrange" startref="ch05_Mentalguylazyrb" significance="normal"/><indexterm id="I_indexterm5_d1e6103" class="endofrange" startref="ch05_lazyeval" significance="normal"/></para></sect1><sect1 id="I_sect15_d1e6104"><title>Minimizing Mutable State and Reducing Side Effects</title><para>Although Ruby is object-oriented, and therefore relies heavily on
    mutable state, we can write nondestructive code in Ruby. In fact, many of
    our <literal moreinfo="none">Enumerable</literal> methods are inspired by
    this.<indexterm class="startofrange" id="ch05_sideeffects" significance="normal"><primary>side effects</primary><secondary>reducing in Ruby code</secondary></indexterm><indexterm class="startofrange" id="ch05_stateminimizing" significance="normal"><primary>state</primary><secondary>minimizing mutable state and reducing side
        effects</secondary></indexterm><indexterm class="startofrange" id="ch05_mutablestatemin" significance="normal"><primary>mutable state, minimizing, and reducing side
        effects</primary></indexterm></para><para>For a trivial example, we can consider the use case for <literal moreinfo="none">Enumerable#map</literal>. We could write our own naive map
    implementation rather easily:<indexterm id="I_indexterm5_d1e6130" significance="normal"><primary>Enumerable#map method</primary></indexterm></para><programlisting id="I_programlisting5_d1e6133" format="linespecific">def naive_map(array)
  array.each_with_object([]) { |e, arr| arr &lt;&lt; yield(e) }
end</programlisting><para>When we run this code, it has the same results as <literal moreinfo="none">Enumerable#map</literal>, as shown here:</para><programlisting id="I_programlisting5_d1e6140" format="linespecific">&gt;&gt; a = [1,2,3,4]
=&gt; [1, 2, 3, 4]
&gt;&gt; naive_map(a) { |x| x + 1 }
=&gt; [2, 3, 4, 5]
&gt;&gt; a
=&gt; [1, 2, 3, 4]</programlisting><para>As you can see, a new array is produced, rather than modifying the
    original array. In practice, this is how we tend to write side-effect-free
    code in Ruby. We traverse our original data source, and then build up the
    results of a state transformation in a new object. In this way, we don’t
    modify the original object. Because <literal moreinfo="none">naive_map()</literal> doesn’t make changes to anything
    outside of the function, we can say that this code is
    side-effect-free.<indexterm id="I_indexterm5_d1e6147" significance="normal"><primary>mutable state, minimizing, and reducing side
        effects</primary><secondary>code free of side effects</secondary></indexterm></para><para>However, this code still uses mutable state to build up its return
    value. To truly make the code stateless, we’d need to build a new array
    every time we append a value to an array. Notice the difference between
    these two ways of adding a new element to the end of an array:<indexterm id="I_indexterm5_d1e6154" significance="normal"><primary>arrays</primary><secondary>adding elements to end of</secondary></indexterm></para><programlisting id="I_programlisting5_d1e6159" format="linespecific">&gt;&gt; a
=&gt; [1, 2, 3, 4]
&gt;&gt; a = [1,2,3]
=&gt; [1, 2, 3]
&gt;&gt; b = a &lt;&lt; 1
=&gt; [1, 2, 3, 1]
&gt;&gt; a
=&gt; [1, 2, 3, 1]

&gt;&gt; c = a + [2]
=&gt; [1, 2, 3, 1, 2]
&gt;&gt; b
=&gt; [1, 2, 3, 1]
&gt;&gt; a
=&gt; [1, 2, 3, 1]</programlisting><para>It turns out that <literal moreinfo="none">Array#&lt;&lt;</literal>
    modifies its receiver, and <literal moreinfo="none">Array#+</literal> does
    not. With this knowledge, we can rewrite <literal moreinfo="none">naive_map</literal> to be truly stateless:<indexterm id="I_indexterm5_d1e6172" significance="normal"><primary>mutable state, minimizing, and reducing side
        effects</primary><secondary>rewriting naive_map to be stateless</secondary></indexterm></para><programlisting id="I_programlisting5_d1e6177" format="linespecific">def naive_map(array, &amp;block)
  return [] if array.empty?
  [ yield(array[0]) ] + naive_map(array[1..-1], &amp;block)
end</programlisting><para>This code works in a different way, building up the result set by
    calling itself repeatedly, resulting in something like this:</para><programlisting id="I_programlisting5_d1e6182" format="linespecific">[1,2,3,4] =&gt; [2], [2,3,4] =&gt; [2] + [3], [3,4] =&gt; [2] + [3] + [4], [4] =&gt;
   [2] + [3] + [4] + [5] =&gt; [2,3,4,5]</programlisting><para>Depending on your taste for recursion, you may find this solution
    beautiful or scary. In Ruby, recursive solutions may look elegant and have
    appeal from a purist’s perspective, but when it comes to their drawbacks,
    the pragmatists win out. Other languages optimize for this sort of thing,
    but Ruby does not, which is made obvious by this benchmark:<indexterm id="I_indexterm5_d1e6186" significance="normal"><primary>mutable state, minimizing, and reducing side
        effects</primary><secondary>recursive solution</secondary></indexterm><indexterm id="I_indexterm5_d1e6191" significance="normal"><primary>recursion</primary><secondary>drawbacks in Ruby</secondary></indexterm></para><programlisting id="I_programlisting5_d1e6196" format="linespecific">require "benchmark"

def naive_map(array, &amp;block)
  new_array = []
  array.each { |e| new_array &lt;&lt; block.call(e) }
  return new_array
end

def naive_map_recursive(array, &amp;block)
  return [] if array.empty?
  [ yield(array[0]) ] + naive_map_recursive(array[1..-1], &amp;block)
end

N = 100_000

Benchmark.bmbm do |x|
  a = [1,2,3,4,5]

  x.report("naive map") do
    N.times { naive_map(a) { |x| x + 1 } }
  end

  x.report("naive map recursive") do
    N.times { naive_map_recursive(a) { |x| x + 1 } }
  end
end

# Outputs:

sandal:fp $ ruby naive_map_bench.rb
Rehearsal -------------------------------------------------------
naive map             0.370000   0.010000   0.380000 (  0.373221)
naive map recursive   0.530000   0.000000   0.530000 (  0.539722)
---------------------------------------------- total: 0.910000sec

                          user     system      total        real
naive map             0.360000   0.000000   0.360000 (  0.369269)
naive map recursive   0.530000   0.000000   0.530000 (  0.538872)</programlisting><para>Even though our functions are somewhat trivial, we see our recursive
    solution performing significantly slower than the iterative one. The
    reason behind this is the very high cost of method dispatch in Ruby. This
    means that despite the identical complexity between our iterative and
    recursive solutions, the latter can quickly become a performance
    nightmare. If we use a larger dataset, we can see this only exacerbates
    the problem:<indexterm id="I_indexterm5_d1e6200" significance="normal"><primary>recursion</primary><secondary>performance problems with</secondary></indexterm><indexterm id="I_indexterm5_d1e6205" significance="normal"><primary>performance</primary><secondary>recursion and</secondary></indexterm></para><programlisting id="I_programlisting5_d1e6210" format="linespecific">N = 100_000

Benchmark.bmbm do |x|
  a = [1,2,3,4,5] * 20

  x.report("naive map") do
    N.times { naive_map(a) { |x| x + 1 } }
  end

  x.report("naive map recursive") do
    N.times { naive_map_recursive(a) { |x| x + 1 }  }
  end
end

# output

sandal:fp $ ruby naive_map_bench.rb
Rehearsal -------------------------------------------------------
naive map             4.360000   0.020000   4.380000 (  4.393069)
naive map recursive   9.420000   0.030000   9.450000 (  9.498580)
--------------------------------------------- total: 13.830000sec

                          user     system      total        real
naive map             4.350000   0.010000   4.360000 (  4.382038)
naive map recursive   9.420000   0.050000   9.470000 (  9.532602)</programlisting><para>An important thing to remember is that any recursive solution can be
    rewritten iteratively. We can actually build an iterative, stateless,
    naive map without much extra effort:<indexterm id="I_indexterm5_d1e6214" significance="normal"><primary>recursion</primary><secondary>rewriting recursive solutions iteratively</secondary></indexterm><indexterm id="I_indexterm5_d1e6219" significance="normal"><primary>mutable state, minimizing, and reducing side
        effects</primary><secondary>rewriting recursive solution iteratively</secondary></indexterm></para><programlisting id="I_programlisting5_d1e6224" format="linespecific">def naive_map_via_inject(array, &amp;block)
  array.inject([]) { |s,e| [ yield(e) ] + s }
end</programlisting><para><literal moreinfo="none">Enumerable#inject</literal> is a favorite
    feature among Rubyists for accumulation. The way that it works is by
    passing two objects into the block: the base object and the current
    element. After each step through the iteration, the return value of the
    block becomes the new base. Essentially, this code is doing the same thing
    our recursive code did, without the recursion. We can take a quick look at
    the benchmarks now, expecting some improvement by cutting out all those
    expensive recursive method calls:<indexterm id="I_indexterm5_d1e6230" significance="normal"><primary>mutable state, minimizing, and reducing side
        effects</primary><secondary>using Enumerable#inject instead of recursion</secondary></indexterm><indexterm id="I_indexterm5_d1e6235" significance="normal"><primary>recursion</primary><secondary>using Enumerable#inject instead of</secondary></indexterm><indexterm id="I_indexterm5_d1e6240" significance="normal"><primary>Enumerable#inject method</primary></indexterm></para><programlisting id="I_programlisting5_d1e6243" format="linespecific">N = 100_000

Benchmark.bmbm do |x|
  a = [1,2,3,4,5] * 20

  x.report("naive map") do
    N.times { naive_map(a) { |x| x + 1 } }
  end

  x.report("naive map recursive") do
    N.times { naive_map_recursive(a) { |x| x + 1 }  }
  end

  x.report("naive map via inject") do
    N.times { naive_map_via_inject(a) { |x| x + 1 } }
  end
end

# Output

sandal:fp $ ruby naive_map_bench.rb
Rehearsal --------------------------------------------------------
naive map              4.370000   0.030000   4.400000 (  4.458491)
naive map recursive    9.730000   0.090000   9.820000 ( 10.128538)
naive map via inject   7.550000   0.070000   7.620000 (  7.766988)
---------------------------------------------- total: 21.840000sec

                           user     system      total        real
naive map              4.360000   0.020000   4.380000 (  4.413264)
naive map recursive    9.480000   0.050000   9.530000 (  9.553978)
naive map via inject   7.420000   0.050000   7.470000 (  7.509197)</programlisting><para>Do these numbers surprise you? As we expected, our
    <literal moreinfo="none">inject</literal>-based solution is much faster than our recursive
    solution, but why is it so much slower than our dumb brute force and
    ignorance approach?</para><para>The reason behind this is one of the key roadblocks that prevent us
    from writing stateless code in Ruby. In order to solve this problem
    without modifying any objects, we need to create a new object every single
    time an element gets added to the array. As you may have guessed, objects
    are large in Ruby, and constructing them is a slow process. What’s more,
    if we don’t store any of these intermediate values, we risk getting the
    garbage collector churning frequently to kill off our discarded
    objects.</para><para>Avoiding side effects is different than avoiding mutable state
    entirely. That’s the key point to take away from what we just looked at
    here. In Ruby, as long as it makes sense to do so, avoiding side effects
    is a good thing. It reduces the possibility for unexpected bugs much in
    the same way that avoiding the use of global variables does. However,
    avoiding the use of mutable state definitely depends more on your
    individual situation.</para><para>We showed two examples that avoided the use of mutable state, both
    of which might look appealing to people who enjoy functional programming
    style. However, we saw that their performance was abysmal, and because
    something like <literal moreinfo="none">Enumerable#map</literal> tends to
    be used in a tight loop, this is a bad time to trade performance for
    aesthetic value.</para><para>However, in other situations, the trade-off may be tipped more in
    the other direction. If the stateless (possibly recursive) code looks
    better than other solutions, and performance is not a major concern, don’t
    be afraid to write your code in the more elegant way.<indexterm id="I_indexterm5_d1e6262" significance="normal"><primary>mutable state, minimizing, and reducing side
        effects</primary><secondary>guidelines for</secondary></indexterm></para><?dbfo-need height=”1in”
?><para>In general, remember the following things:</para><itemizedlist><listitem><para>The simple way to avoid side effects in Ruby when transforming
        one object to another is to create a new object, and then populate it
        by iterating over your original object performing the necessary state
        transformations.</para></listitem><listitem><para>You can write stateless code in Ruby by creating new objects
        every time you perform an operation, such as <literal moreinfo="none">Array#+</literal>.</para></listitem><listitem><para>Recursive solutions may aid in writing simple stateless
        solutions, but incur a major performance penalty in Ruby.</para></listitem><listitem><para>Creating too many objects can create performance problems as
        well, so it is important to find the right balance, and to remember
        that side effects can be avoided without making things fully
        stateless.</para></listitem></itemizedlist><para>We’ll now move on from how you structure individual functions in
    your code to how you can organize the larger chunks. So let’s take a look
    at what we can learn from modular organization, and how we can mix it in
    with our object-oriented code.<indexterm id="I_indexterm5_d1e6288" class="endofrange" startref="ch05_sideeffects" significance="normal"/><indexterm id="I_indexterm5_d1e6289" class="endofrange" startref="ch05_stateminimizing" significance="normal"/><indexterm id="I_indexterm5_d1e6290" class="endofrange" startref="ch05_mutablestatemin" significance="normal"/></para></sect1><sect1 id="I_sect15_d1e6291"><title>Modular Code Organization</title><para>In many functional languages, it is possible to group together your
    related functions using a module. However, we typically think of something
    different when we think of modules in Ruby:<indexterm id="I_indexterm5_d1e6296" significance="normal"><primary>functions</primary><secondary>groupings of, Ruby modules and</secondary></indexterm><indexterm class="startofrange" id="ch05_modularcode" significance="normal"><primary>modular code organization</primary></indexterm></para><programlisting id="I_programlisting5_d1e6304" format="linespecific">class A

  include Enumerable

  def initialize(arr)
    @arr = arr
  end

  def each
    @arr.each { |e| yield(e) }
  end

end

&gt;&gt; A.new([1,2,3]).map { |x| x + 1 }
=&gt; [2, 3, 4]</programlisting><para>Here, we’ve included the <literal moreinfo="none">Enumerable</literal> module into our class as a mixin.
    This enables shared implementation of functionality between classes, but
    is a different concept than modular code organization in
    general.<indexterm id="I_indexterm5_d1e6311" significance="normal"><primary>modular code organization</primary><secondary>module included into class as mixin</secondary></indexterm><indexterm id="I_indexterm5_d1e6316" significance="normal"><primary>Enumerable module</primary><secondary>included into class as mixin</secondary></indexterm></para><para>What we really want is a collection of functions unified under a
    single namespace. As it turns out, Ruby has that sort of thing, too!
    Although the <literal moreinfo="none">Math</literal> module can be mixed
    into classes similar to the way we’ve used <literal moreinfo="none">Enumerable</literal> here, you can also use it on its
    own:<indexterm id="I_indexterm5_d1e6329" significance="normal"><primary>modular code organization</primary><secondary>collection of functions under single namespace</secondary></indexterm><indexterm id="I_indexterm5_d1e6334" significance="normal"><primary>namespaces</primary><secondary>collection of functions under single namespace</secondary></indexterm><indexterm id="I_indexterm5_d1e6339" significance="normal"><primary>Math module</primary></indexterm><indexterm id="I_indexterm5_d1e6342" significance="normal"><primary>functions</primary><secondary>collection unified under single namespace</secondary></indexterm></para><programlisting id="I_programlisting5_d1e6347" format="linespecific">&gt;&gt; Math.sin(Math::PI / 2)
=&gt; 1.0
&gt;&gt; Math.sqrt(4)
=&gt; 2.0</programlisting><para>So, how’d they do that? One way is to use <literal moreinfo="none">module_function</literal>:<indexterm id="I_indexterm5_d1e6354" significance="normal"><primary>module_function</primary></indexterm></para><programlisting id="I_programlisting5_d1e6357" format="linespecific">module A
  module_function

  def foo
    "This is foo"
  end

  def bar
    "This is bar"
  end
end</programlisting><para>We can now call these functions directly on the module, as you can
    see here:</para><programlisting id="I_programlisting5_d1e6361" format="linespecific">&gt;&gt; A.foo
=&gt; "This is foo"
&gt;&gt; A.bar
=&gt; "This is bar"</programlisting><para>You won’t need anything more for most cases in which you want to
    execute functions on a module. However, this approach does come with some
    limitations, because it does not allow you to use private
    functions:<indexterm id="I_indexterm5_d1e6365" significance="normal"><primary>modular code organization</primary><secondary>executing functions on a module</secondary></indexterm></para><programlisting id="I_programlisting5_d1e6371" format="linespecific">module A
  module_function

  def foo
    "This is foo calling baz: #{baz}"
  end

  def bar
    "This is bar"
  end

  private

  def baz
    "hi there"
  end
end</programlisting><para>Though it seems like our code is fairly intuitive, we’ll quickly run
    into an error once we try to call <literal moreinfo="none">A.foo</literal>:</para><programlisting id="I_programlisting5_d1e6378" format="linespecific">&gt;&gt; A.foo
NameError: undefined local variable or method 'baz' for A:Module
  from (irb):33:in 'foo'
  from (irb):46
  from /Users/sandal/lib/ruby19_1/bin/irb:12:in '&lt;main&gt;'</programlisting><para>For some cases, not being able to access private methods might not
    be a big deal, but for others, this could be a major issue. Luckily, if we
    think laterally, there is an easy workaround.</para><para>Modules in Ruby, although they cannot be instantiated, are in
    essence ordinary objects. Because of this, there is nothing stopping us
    from mixing a module into itself:<indexterm id="I_indexterm5_d1e6384" significance="normal"><primary>modular code organization</primary><secondary>extending a module with itself</secondary></indexterm></para><programlisting id="I_programlisting5_d1e6389" format="linespecific">module A
  extend self

  def foo
    "This is foo calling baz: #{baz}"
  end

  def bar
    "This is bar"
  end

  private

  def baz
    "hi there"
  end
end</programlisting><para>Once we do this, we get the same effect as <literal moreinfo="none">module_function</literal> without the limitations:</para><programlisting id="I_programlisting5_d1e6396" format="linespecific">&gt;&gt; A.foo
=&gt; "This is foo calling baz: hi there"</programlisting><para>We aren’t sacrificing encapsulation here, either. We will still get
    an error if we try to call <literal moreinfo="none">A.baz</literal>
    directly:<indexterm id="I_indexterm5_d1e6403" significance="normal"><primary>encapsulation of code, module mixin capability and</primary></indexterm></para><programlisting id="I_programlisting5_d1e6406" format="linespecific">&gt;&gt; A.baz
NoMethodError: private method 'baz' called for A:Module
  from (irb):65
  from /Users/sandal/lib/ruby19_1/bin/irb:12:in '&lt;main&gt;'</programlisting><para>Using this trick of extending a module with itself provides us with
    a structure that isn’t too different (at least on the surface) from the
    sort of modules you might find in functional programming languages. But
    aside from odd cases such as the <literal moreinfo="none">Math</literal>
    module, you might wonder when this technique would be useful.</para><para>For the most part, classes work fine for encapsulating code in Ruby.
    Traditional inheritance combined with the powerful mixin functionality of
    modules covers most of the bases just fine. However, there are definitely
    cases in which a concept isn’t big enough for a class, but isn’t small
    enough to fit in a single function.<indexterm id="I_indexterm5_d1e6416" significance="normal"><primary>modular code organization</primary><secondary>code encapsulation and classes</secondary></indexterm><indexterm id="I_indexterm5_d1e6421" significance="normal"><primary>classes</primary><secondary>encapsulation of code</secondary></indexterm></para><para>I ran into this issue recently in a Rails app I was working on. I
    was implementing user authentication and needed to first test the database
    via ActiveRecord, and fall back to LDAP when a user didn’t have an account
    set up in the application.</para><para>Without getting into too much detail, the basic structure for my
    authentication routine looked like this:<indexterm id="I_indexterm5_d1e6430" significance="normal"><primary>authentication</primary><secondary>LDAP authentication module</secondary></indexterm></para><programlisting id="I_programlisting5_d1e6435" format="linespecific">class User &lt; ActiveRecord::Base

  # other model code omitted

  def self.authenticate(login, password)
    if u = find_by_login(login)
      u.authenticated?(password) ? u : nil
    else
      ldap_authenticate(login, password)
    end
  end

end</programlisting><para>LDAP authentication was to be implemented in a private class method,
    which seemed like a good idea at first. However, as I continued to work on
    this, I found myself writing a very huge function that represented more
    than a page of code. As I knew there would be no way to keep this whole
    thing in my head easily, I proceeded to break things into more helper
    methods to make things clearer. Unfortunately, this approach didn’t work
    as well as I had hoped.</para><para>By the end of this refactoring, I had racked up all sorts of strange
    routines on <literal moreinfo="none">User</literal>, with names such as
    <literal moreinfo="none">initialize_ldap_conn</literal>, <literal moreinfo="none">retrieve_ldap_user</literal>, and so on. A well-factored
    object should do one thing and do it well, and my <literal moreinfo="none">User</literal> model seemed to know much more about LDAP
    than it should have to. The solution was to break this code off into a
    module, which was only a tiny change to the <literal moreinfo="none">User.authenticate</literal> method:</para><programlisting id="I_programlisting5_d1e6456" format="linespecific">def self.authenticate(login, password)
  if u = find_by_login(login) # need to get the salt
    u.authenticated?(password) ? u : nil
  else
    LDAP.authenticate(login, password)
  end
end</programlisting><para>By substituting the private method call on the <literal moreinfo="none">User</literal> model with a modular function call on
    <literal moreinfo="none">User::LDAP</literal>, I was able to define my
    function and its private helpers in a place that made more sense. The
    module ended up looking something like this:</para><programlisting id="I_programlisting5_d1e6466" format="linespecific">module LDAP

  extend self

  def authenticate(username, password)
    connection = initialize_ldap_connection
    retrieve_ldap_user(username, password, connection)
  rescue Net::LDAP::LdapError =&gt; e
    ActiveRecord::Base.logger.debug "!!! LDAP Error: #{e.message} !!!"
    false
  end

  private
<?dbfo-need height="1in"
?>
  def initialize_ldap_connection
    #...
  end

  def retrieve_ldap_user(username, password, connection)
    #...
  end

end</programlisting><para>This definitely cleaned up the code and made it easier to follow,
    but it had additional benefits as well. It introduced a clear separation
    of concerns that helped make testing much easier. It also left room for
    future expansion and modification without tight <phrase role="keep-together">coupling</phrase>.</para><para>Of course, if we end up needing to do more than simply authenticate
    a user against the LDAP database, this module will need to go. As soon as
    you see the same argument being passed to a bunch of functions, you might
    be running into a situation where some persistence of state wouldn’t hurt.
    You can probably see how we’d spend a lot of time passing around usernames
    and connection objects if this code grew substantially bigger.</para><para>The good news is, if need arises for expansion down the line,
    converting code that has been organized into a module is somewhat trivial.
    Here’s how we’d do it with the LDAP module:</para><programlisting id="I_programlisting5_d1e6480" format="linespecific">class LDAP

  def self.authenticate(username, password)
    user = new(username, password)
    user.authenticate(password)
  rescue Net::LDAP::LdapError =&gt; e
    ActiveRecord::Base.logger.debug "!!! LDAP Error: #{e.message} !!!"
    false
  end

  def initialize(username)
    @connection = initialize_ldap_connection
    @username   = username
  end

  def authenticate(password)
    #...
  end

  private

  def initialize_ldap_connection
    #...
  end

end</programlisting><para>As you can see, the difference is somewhat minimal, and no changes
    need to be made to your user model. Object-oriented purists may even
    prefer this <phrase role="keep-together">approach</phrase> all around, but
    there is a certain appeal to the minimalism of the modular <phrase role="keep-together">approach</phrase> shown earlier.</para><para>Even though this latest iteration moves to a more object-oriented
    approach, there is still modular appeal to it. The ease of creating class
    methods in Ruby contributes highly to that, as it makes it possible for
    this to look like modular code even if it’s building a new instance of the
    LDAP module each time.</para><para>Although it is not advisable to try extra hard to use this technique
    of modular code design in every possible situation, it is a neat
    organizational approach that is worth knowing about. Here are a few things
    to watch for that indicate this technique may be the right way to
    go:<indexterm id="I_indexterm5_d1e6494" significance="normal"><primary>modular code organization</primary><secondary>guidelines for use</secondary></indexterm></para><itemizedlist><listitem><para>You are solving a single, atomic task that involves lots of
        steps that would be better broken out into helper functions.</para></listitem><listitem><para>You are wrapping some functions that don’t rely on much common
        state between them, but are related to a common topic.</para></listitem><listitem><para>The code is very general and can be used standalone
        <emphasis>or</emphasis> the code is very specific but doesn’t relate
        directly to the object that it is meant to be used by.</para></listitem><listitem><para>The problem you are solving is small enough where object
        orientation does more to get in the way than it does to help
        you.</para></listitem></itemizedlist><para>Because modular code organization reduces the amount of objects you
    are creating, it can potentially give you a decent performance boost. This
    offers an incentive to use this approach when it is appropriate.<indexterm id="I_indexterm5_d1e6517" class="endofrange" startref="ch05_modularcode" significance="normal"/></para></sect1><sect1 id="I_sect15_d1e6518"><title>Memoization</title><para>A typical “Hello World” program in functional programming languages
    is a recursive function that computes the Fibonacci sequence. In Ruby, the
    trivial implementation looks like this:<indexterm id="I_indexterm5_d1e6523" significance="normal"><primary>Fibonacci sequence, computing with recursive
        function</primary></indexterm><indexterm class="startofrange" id="ch05_memoization" significance="normal"><primary>memoization</primary></indexterm></para><programlisting id="I_programlisting5_d1e6529" format="linespecific">def fib(n)
  return n if (0..1).include? n
  fib(n-1) + fib(n-2)
end</programlisting><para>However, you’ll feel the pain that is relying on deep recursion in
    Ruby if you compute even modest values of <literal moreinfo="none">n</literal>. On my
    machine, <literal moreinfo="none">fib(30)</literal> computes within a few
    seconds, but I’m too impatient to even give you a time for <literal moreinfo="none">fib(40)</literal>. However, there is a special
    characteristic of functions like this that makes it possible to speed them
    up drastically.</para><para>In mathematics, a function is said to be well defined if it
    consistently maps its input to exactly one output. This is obviously true
    for <literal moreinfo="none">fib(n)</literal>, as <literal moreinfo="none">fib(6)</literal> will always return <literal moreinfo="none">8</literal>, no matter how many times you compute it. This
    sort of function is distinct from one that is not well defined, such as
    the following:<indexterm id="I_indexterm5_d1e6553" significance="normal"><primary>functions</primary><secondary>well-defined</secondary></indexterm></para><programlisting id="I_programlisting5_d1e6558" format="linespecific">def mystery(n)
  n + rand(1000)
end</programlisting><para>If we run this code a few times with the same <literal moreinfo="none">n</literal>,
    we see there isn’t a unique relationship between its input and
    output:</para><programlisting id="I_programlisting5_d1e6565" format="linespecific">&gt;&gt; mystery(6)
=&gt; 928
&gt;&gt; mystery(6)
=&gt; 671
&gt;&gt; mystery(6)
=&gt; 843</programlisting><para>When we have a function like this, there isn’t much we can assume
    about it. However, well-defined functions such as <literal moreinfo="none">fib(n)</literal> can get a massive performance boost
    almost for free. Can you guess how?</para><para>If your mind wandered to tail-call optimization or rewriting the
    function iteratively, you’re thinking too hard. However, the idea of
    reducing the amount of recursive calls is on track. As it stands, this
    code is a bad dream, as <literal moreinfo="none">fib(n)</literal> is
    called five times when <literal moreinfo="none">n</literal>=3 and nine times when
    <literal moreinfo="none">n</literal>=4, with this trend continuing upward as
    <literal moreinfo="none">n</literal> gets larger.<indexterm id="I_indexterm5_d1e6586" significance="normal"><primary>recursion</primary><secondary>reducing with memoization</secondary></indexterm></para><para>The key realization is what I mentioned before: <literal moreinfo="none">fib(6)</literal> is always going to be <literal moreinfo="none">8</literal>, and <literal moreinfo="none">fib(10)</literal> is always going to be <literal moreinfo="none">55</literal>. Because of this, we can store these values
    rather than calculate them repeatedly. Let’s give that a shot and see what
    happens:</para><programlisting id="I_programlisting5_d1e6606" format="linespecific">def fib(n)
  @series[n] ||= fib(n-1) + fib(n-2)
end</programlisting><para>Huzzah! By simply storing our precalculated values in an array, we
    can now calculate much deeper into the sequence:<indexterm id="I_indexterm5_d1e6610" significance="normal"><primary>arrays</primary><secondary>using for caching in memoization</secondary></indexterm></para><programlisting id="I_programlisting5_d1e6615" format="linespecific">&gt;&gt; fib(1000)
=&gt; 4346655768693745643568852767504062580256466051737178040248172908953655541
794905189040387984007925516929592259308032263477520968962323987332247116164
2996440906533187938298969649928516003704476137795166849228875</programlisting><para>What we have done is used a technique called
    <emphasis>memoization</emphasis> to cache the return values of our
    function based on its input. Because we were caching a sequence, it’s
    reasonable to use an array here, but in other cases in which the data is
    more sparse, a hash may be more appropriate. Let’s take a look at some
    real code where that is the case, to help illustrate the point.<indexterm id="I_indexterm5_d1e6622" significance="normal"><primary>caching</primary><secondary>function return values via memoization</secondary></indexterm><indexterm id="I_indexterm5_d1e6627" significance="normal"><primary>functions</primary><secondary>caching return values via memoization</secondary></indexterm><indexterm id="I_indexterm5_d1e6632" significance="normal"><primary>memoization</primary><secondary>defined</secondary></indexterm></para><para>In my PDF generation library Prawn, I provide helper methods that
    convert from HTML colors to an array of RGB values and back again. Though
    they’re nothing particularly exciting, this is what they look like in
    action:</para><programlisting id="I_programlisting5_d1e6639" format="linespecific">&gt;&gt; rgb2hex([100,25,254])
=&gt; "6419fe"

&gt;&gt; hex2rgb("6419fe")
=&gt; [100, 25, 254]</programlisting><para>The implementations of these functions are somewhat simple, and not
    nearly as computationally expensive as our recursive Fibonacci
    implementation:</para><programlisting id="I_programlisting5_d1e6643" format="linespecific">def rgb2hex(rgb)
  rgb.map { |e| "%02x" % e }.join
end

def hex2rgb(hex)
  r,g,b = hex[0..1], hex[2..3], hex[4..5]
  [r,g,b].map { |e| e.to_i(16) }
end</programlisting><para>Although these methods aren’t especially complicated, they represent
    a decent use case for caching via memoization. Colors are likely to be
    reused frequently and, after they have been translated once, will never
    change. Therefore, <literal moreinfo="none">rgb2hex()</literal> and
    <literal moreinfo="none">hex2rgb()</literal> are well-defined functions.</para><para>As it turns out, Ruby’s <literal moreinfo="none">Hash</literal> is a
    truly excellent cache object. Before we get into the specifics, take a
    look at the memoized versions and see if you can figure out for yourself
    what’s going on:<indexterm class="startofrange" id="ch05_memoizationhashes" significance="normal"><primary>memoization</primary><secondary>using Hash objects for caching</secondary></indexterm><indexterm class="endofrange" id="ch05_Hashcaching" significance="normal"><primary>Hash objects, using for caching</primary></indexterm></para><programlisting id="I_programlisting5_d1e6666" format="linespecific">def rgb2hex_manual_cache(rgb)
  @rgb2hex ||= Hash.new do |colors, value|
    colors[value] = value.map { |e| "%02x" % e }.join
  end

  @rgb2hex[rgb]
end

def hex2rgb_manual_cache(hex)
  @hex2rgb ||= Hash.new do |colors, value|
    r,g,b = value[0..1], value[2..3], value[4..5]
    colors[value] = [r,g,b].map { |e| e.to_i(16) }
  end

  @hex2rgb[hex]
end</programlisting><para>Does this example make much sense? If you look at it closely, you
    can see that the core implementation is still the same—we’ve just added
    some extra code to do the caching for us. To do this, we use the block
    form of <literal moreinfo="none">Hash.new</literal>.<indexterm id="I_indexterm5_d1e6674" significance="normal"><primary>Hash.new method</primary></indexterm></para><para>You may have used <literal moreinfo="none">Hash.new</literal> to
    define a default value when an unknown key is used. This trick is a
    relatively simple way to do all sorts of things, including constructing a
    hash of arrays, or creating a hash for counting things:</para><programlisting id="I_programlisting5_d1e6682" format="linespecific">&gt;&gt; a = Hash.new { |h,k| h[k] = [] }
=&gt; {}
&gt;&gt; a[:foo] &lt;&lt; 1
=&gt; [1]
&gt;&gt; a[:foo] &lt;&lt; 2
=&gt; [1, 2]
&gt;&gt; a[:bar]
=&gt; []

&gt;&gt; b = Hash.new { |h,k| h[k] = 0 }
=&gt; {}
&gt;&gt; [:foo, :bar, :foo, :bar, :bar, :bar, :foo].each { |e| b[e] += 1 }
=&gt; [:foo, :bar, :foo, :bar, :bar, :bar, :foo]
&gt;&gt; b
=&gt; {:foo=&gt;3, :bar=&gt;4}</programlisting><para>However, if we can compute our value based on the key to our hash,
    we can do more than simply provide default values. For example, it would
    be easy to create a hash that would multiply any key passed into it by
    2:</para><programlisting id="I_programlisting5_d1e6686" format="linespecific">&gt;&gt; doubler = Hash.new { |h,k| h[k] = k * 2 }
=&gt; {}
&gt;&gt; doubler[2]
=&gt; 4
&gt;&gt; doubler[5]
=&gt; 10
&gt;&gt; doubler[10]
=&gt; 20</programlisting><para>With this in mind, it should be easier to understand the caching in
    our color conversion code upon a second glance:</para><programlisting id="I_programlisting5_d1e6690" format="linespecific">def rgb2hex_manual_cache(rgb)
  @rgb2hex ||= Hash.new do |colors, value|
    colors[value] = value.map { |e| "%02x" % e }.join
  end

  @rgb2hex[rgb]
end

def hex2rgb_manual_cache(hex)
  @hex2rgb ||= Hash.new do |colors, value|
    r,g,b = value[0..1], value[2..3], value[4..5]
    colors[value] = [r,g,b].map { |e| e.to_i(16) }
  end

  @hex2rgb[hex]
end</programlisting><para>Here we can see that the input to the function is being used to
    build up our <literal moreinfo="none">Hash</literal>. We initialize the
    <literal moreinfo="none">Hash</literal> once, and then we simply index
    into it to populate the values. The block is run exactly once per key, and
    then the cached values are returned thereafter. As a result, we have
    greatly sped up our function. Let’s take a look at some benchmarks to see
    how much of a boost we get by writing things this way:</para><programlisting id="I_programlisting5_d1e6700" format="linespecific">require "benchmark"

N = 500_000

Benchmark.bmbm do |x|
<?dbfo-need height="1in"
?>
  x.report("rgb2hex_uncached") do
    N.times { rgb2hex([100,25,50]) }
  end
  x.report("rgb2hex_manual_cache") do
    N.times { rgb2hex_manual_cache([100,25,50]) }
  end

  x.report("hex2rgb_uncached") do
    N.times { hex2rgb("beaded") }
  end
  x.report("hex2rgb_manual_cache") do
    N.times { hex2rgb_manual_cache("beaded") }
  end

end

sandal:fp $ ruby rgb2hex.rb
Rehearsal --------------------------------------------------------
rgb2hex_uncached       3.560000   0.030000   3.590000 (  3.656217)
rgb2hex_manual_cache   1.030000   0.000000   1.030000 (  1.063319)
hex2rgb_uncached       1.220000   0.010000   1.230000 (  1.240591)
hex2rgb_manual_cache   0.280000   0.000000   0.280000 (  0.303417)
----------------------------------------------- total: 6.130000sec

                           user     system      total        real
rgb2hex_uncached       3.570000   0.040000   3.610000 (  3.733938)
rgb2hex_manual_cache   1.040000   0.010000   1.050000 (  1.055863)
hex2rgb_uncached       1.210000   0.010000   1.220000 (  1.248148)
hex2rgb_manual_cache   0.280000   0.000000   0.280000 (  0.284613)</programlisting><para>As you can see, the results are pretty convincing. The cached
    version of the code is several times faster than the uncached one. This
    means that when running under a tight loop, the memoization can really
    make a big difference in these functions, and may be worth the minimal
    noise introduced by adding a <literal moreinfo="none">Hash</literal> into
    the mix.<indexterm id="I_indexterm5_d1e6709" class="endofrange" startref="ch05_Hashcaching" significance="normal"/><indexterm id="I_indexterm5_d1e6710" class="endofrange" startref="ch05_memoizationhashes" significance="normal"/></para><para>You might have noticed that the process for doing memoization isn’t
    really case-<phrase role="keep-together">specific</phrase>. In nearly
    every situation, you’re going to want to create a simple hash that maps
    from the input to the output, and you’ll want to return that value rather
    than recalculate it if it exists. Ruby wouldn’t be Ruby if we couldn’t
    hack our way around repetition like this, and luckily James Gray is one of
    the folks who has done exactly that.<indexterm id="I_indexterm5_d1e6716" significance="normal"><primary>Gray, James Edward, II</primary></indexterm></para><para>James wrote a nice little module called <literal moreinfo="none">Memoizable</literal>, which is designed to abstract the
    task of creating a cache to the point at which you simply mark each
    function that should be memoized similar to the way you mark something
    public or private.<indexterm id="I_indexterm5_d1e6725" significance="normal"><primary>Memoizable module</primary></indexterm></para><para>Let’s take a look at this in action, before digging deeper:</para><programlisting id="I_programlisting5_d1e6730" format="linespecific">include Memoizable

def rgb2hex(rgb)
  rgb.map { |e| "%02x" % e }.join
end

memoize :rgb2hex

def hex2rgb(hex)
  r,g,b = hex[0..1], hex[2..3], hex[4..5]
  [r,g,b].map { |e| e.to_i(16) }
end

memoize :hex2rgb</programlisting><para>That’s really all there is to it. <literal moreinfo="none">Memoizable</literal>
    works by making a copy of your function, renaming it as <literal moreinfo="none">__unmemoized_method_name__</literal>, and then injects its
    automatic caching in place of the original function. That means that when
    we call <literal moreinfo="none">rgb2hex()</literal> or <literal moreinfo="none">hex2rgb()</literal>, we’ll now be hitting the cached
    versions of the functions.<indexterm id="I_indexterm5_d1e6746" significance="normal"><primary>Memoizable module</primary><secondary>performance, manual caching versus</secondary></indexterm><indexterm id="I_indexterm5_d1e6751" significance="normal"><primary>memoization</primary><secondary>performance, caching using Memoizable versus manual
        caching</secondary></indexterm><indexterm id="I_indexterm5_d1e6757" significance="normal"><primary>caching</primary><secondary>Memoizable module approach versus manual
        caching</secondary></indexterm><indexterm id="I_indexterm5_d1e6762" significance="normal"><primary>performance</primary><secondary>using Memoizable module versus manual caching</secondary></indexterm></para><para>This is pretty exciting, as it means that for well-defined
    functions, you can use <literal role="keep-together" moreinfo="none">Memoizable</literal>
    to get a performance boost without even modifying your underlying
    implementation. Let’s take a look at how this approach stacks up
    performance-wise when compared to the manual caching from before:</para><programlisting id="I_programlisting5_d1e6772" format="linespecific">require "benchmark"

N = 500_000

Benchmark.bmbm do |x|

  x.report("rgb2hex (Memoizable)") do
    N.times { rgb2hex([100,25,50]) }
  end
  x.report("rgb2hex_manual_cache") do
    N.times { rgb2hex_manual_cache([100,25,50]) }
  end
  x.report("rgb2hex_uncached") do
    N.times { __unmemoized_rgb2hex__([100,25,50]) }
  end

  x.report("hex2rgb (Memoizable)") do
    N.times { hex2rgb("beaded") }
  end
  x.report("hex2rgb_manual_cache") do
    N.times { hex2rgb_manual_cache("beaded") }
  end
  x.report("hex2rgb_uncached") do
    N.times { __unmemoized_hex2rgb__("beaded") }
  end

end

sandal:fp $ ruby rgb2hex.rb
Rehearsal --------------------------------------------------------
rgb2hex (Memoizable)   1.750000   0.010000   1.760000 (  1.801235)
rgb2hex_manual_cache   1.040000   0.010000   1.050000 (  1.067790)
rgb2hex_uncached       3.580000   0.020000   3.600000 (  3.680780)
hex2rgb (Memoizable)   0.990000   0.010000   1.000000 (  1.021821)
hex2rgb_manual_cache   0.280000   0.000000   0.280000 (  0.287521)
hex2rgb_uncached       1.210000   0.010000   1.220000 (  1.247875)
----------------------------------------------- total: 8.910000sec

                           user     system      total        real
rgb2hex (Memoizable)   1.760000   0.010000   1.770000 (  1.803120)
rgb2hex_manual_cache   1.040000   0.000000   1.040000 (  1.066625)
rgb2hex_uncached       3.600000   0.030000   3.630000 (  3.871221)
hex2rgb (Memoizable)   0.990000   0.010000   1.000000 (  1.017367)
hex2rgb_manual_cache   0.280000   0.000000   0.280000 (  0.283920)
hex2rgb_uncached       1.220000   0.010000   1.230000 (  1.248152)</programlisting><para>Although <literal moreinfo="none">Memoizable</literal> is
    predictably slower than our raw implementation, it is still cooking with
    gas when compared to the uncached versions of our functions. What we are
    seeing here is the overhead of an additional method call per request, so
    as the operation becomes more expensive, the cost of <literal moreinfo="none">Memoizable</literal> actually gets lower. Also, if we look
    at things in terms of work versus payout, <literal moreinfo="none">Memoizable</literal> is the clear winner, due to its
    ability to transparently hook itself into your functions.</para><para>I could stop here and move on to the next topic, but similar to when
    we looked into the belly of <emphasis>lazy.rb</emphasis> earlier in this
    chapter, I can’t resist walking through and explaining some cool code. I
    am hoping that as you read through this book, you will find that things
    that seem magical on the surface have a clear and easy-to-understand
    implementation under the hood, and <literal moreinfo="none">Memoizable</literal> is a perfect example for that.</para><para>Here is the full implementation of the module:<indexterm id="I_indexterm5_d1e6795" significance="normal"><primary>Memoizable module</primary><secondary>full implementation</secondary></indexterm></para><programlisting id="I_programlisting5_d1e6800" format="linespecific">module Memoizable
  def memoize( name, cache = Hash.new )
    original = "__unmemoized_#{name}__"

    ([Class, Module].include?(self.class) ? self : self.class).class_eval do
      alias_method original, name
      private      original
      define_method(name) { |*args| cache[args] ||= send(original, *args) }
    end
  end
end</programlisting><para>We see that the <literal moreinfo="none">memoize()</literal> method
    takes a method name and an optional cache object, which defaults to an
    empty <literal moreinfo="none">Hash</literal> if none is provided. The
    code then does some logic to determine whether you are using the top-level
    object (as we were), or just working in the context of an ordinary object.
    Once it figures that out, what remains is a simple <literal moreinfo="none">class_eval</literal> block, which does what we talked
    about before. The original method is renamed, and then a new method is
    created that caches the return values of the original function based on
    the input arguments. Despite how powerful this code is, we see that it is
    of only marginally higher complexity than our handwritten
    caching.<indexterm id="I_indexterm5_d1e6813" significance="normal"><primary>Memoizable module</primary><secondary>memoize( ) method</secondary></indexterm></para><para>Of course, this doesn’t have a whole lot to do with functional
    programming techniques, except for showing you how you can abstract them
    into reusable constructs. In case this distracted you a bit, here are the
    things to remember about memoization before moving on to the next
    section:<indexterm id="I_indexterm5_d1e6821" significance="normal"><primary>memoization</primary><secondary>summary of important concepts</secondary></indexterm></para><itemizedlist><listitem><para>Functions that are well defined, where a single input
        consistently produces the same output, can be cached through
        memoization.</para></listitem><listitem><para>Memoization often trades CPU time for memory, storing results
        rather than recalculating them. As a result, memoization is best used
        when memory is cheap and CPU time is costly, and not the other way
        around. In some cases, even when the memory consumption is negligible,
        the gains can be substantial. We can see this in the
        <literal moreinfo="none">fib(n)</literal> example, which is transformed from an
        exponential algorithm to a linear one simply by storing the
        intermediate calculations.</para></listitem><listitem><para>When coding your own solution, <literal moreinfo="none">Hash.new</literal>’s
        block form can be a very handy way of putting together a simple
        caching object.</para></listitem><listitem><para>James Gray’s <literal moreinfo="none">Memoizable</literal>
        module makes it trivial to introduce memoization to well-defined
        functions without directly modifying their implementations, but incurs
        a small cost of indirection over an explicit caching strategy.</para></listitem></itemizedlist><para>When dealing with sequences that can be generated from previous
    values, memoization isn’t the only game in town. We’re now going to take a
    look at how to build upon the concept of lazy evaluation to form very
    interesting structures known as infinite lists.<indexterm id="I_indexterm5_d1e6850" class="endofrange" startref="ch05_memoization" significance="normal"/></para></sect1><sect1 id="I_sect15_d1e6851"><title>Infinite Lists</title><para><emphasis>Infinite lists</emphasis> (also known as lazy streams)
    provide a way to represent arbitrary sequences that can be traversed by
    applying a certain function that gets to you the next element for any
    given element in the list. For example, if we start with any even number,
    we can get to the next one in the sequence by simply adding 2 to our
    original element.<indexterm id="I_indexterm5_d1e6858" significance="normal"><primary>lazy streams</primary></indexterm><indexterm class="startofrange" id="ch05_infinitelists" significance="normal"><primary>infinite lists</primary></indexterm></para><para>Before we look at more complicated examples, let’s take a look at
    how we can represent the even sequence of numbers this way, using a simple
    Ruby object:<indexterm id="I_indexterm5_d1e6866" significance="normal"><primary>EvenSeries module</primary></indexterm><indexterm id="I_indexterm5_d1e6869" significance="normal"><primary>infinite lists</primary><secondary>object representing even sequence of numbers</secondary></indexterm></para><programlisting id="I_programlisting5_d1e6874" format="linespecific">module EvenSeries
  class Node
    def initialize(number=0)
      @value = number
      @next  = lambda { Node.new(number + 2) }
    end

    attr_reader :value

    def next
      @next.call
    end
  end
end

e = EvenSeries::Node.new(30)
10.times do
  p e.value
  e = e.next
end</programlisting><para>When we run this code, we get the following output:</para><programlisting id="I_programlisting5_d1e6878" format="linespecific">30
32
34
36
38
40
42
44
46
48</programlisting><para>The implementation should be mostly self-explanatory. An <literal moreinfo="none">EvenSeries::Node</literal> is nothing more than a number
    and a <literal moreinfo="none">Proc</literal> that is designed to add 2 to
    that number and construct a new <literal moreinfo="none">Node</literal>.
    What we end up with is something that looks similar to a linked list, and
    we can clearly see what happens when we take 10 steps forward from 30
    through the even numbers.<indexterm id="I_indexterm5_d1e6891" significance="normal"><primary>EvenSeries::Node</primary></indexterm></para><para>The key innovation is that we’ve turned an external iteration and
    state transformation into an internal one. The benefits of this technique
    will become more clear in later examples, but for now, it’s worth noting
    that this is the key motivation for creating such a construct.</para><para>Although this example shows you the simplest thing that could
    possibly work when it comes to infinite lists, we can benefit from using a
    more generalized, more feature-complete structure for this task. Rather
    than rolling our own, I’m going to walk you through some of the examples
    for James Gray’s <literal moreinfo="none">LazyStream</literal>
    implementation, many of which you may have already seen in his <ulink url="http://blog.grayproductions.net/categories/higherorder_ruby">Higher-Order
    Ruby blog series</ulink>. His focus was on showing how to build an
    infinite list structure; mine will be on how to make use of
    them.<indexterm id="I_indexterm5_d1e6904" significance="normal"><primary>lazy_stream.rb</primary></indexterm><indexterm id="I_indexterm5_d1e6907" significance="normal"><primary>infinite lists</primary><secondary>using lazy_stream.rb to iterate over range of
        numbers</secondary></indexterm><indexterm id="I_indexterm5_d1e6912" significance="normal"><primary>Gray, James Edward, II</primary></indexterm><indexterm id="I_indexterm5_d1e6915" significance="normal"><primary>LazyStream module</primary></indexterm></para><para>The following is a trivial example of using
    <emphasis>lazy_stream.rb</emphasis>, doing simple iteration over a range
    of numbers:</para><programlisting id="I_programlisting5_d1e6923" format="linespecific">require "lazy_stream"

def upto( from, to )
  return if from &gt; to
  lazy_stream(from) { upto(from + 1, to) }
end
upto(3, 6).show  # =&gt; 3 4 5 6

def upfrom( start )
  lazy_stream(start) { upfrom(start + 1) }
end
upfrom(7).show(10)  # =&gt; 7 8 9 10 11 12 13 14 15 16</programlisting><para>As you can see here, <literal moreinfo="none">lazy_stream()</literal> is just creating recursive calls
    that build up new elements that in turn know how to get to their next
    element. What is neat is that as the name suggests, these things are
    evaluated lazily. When we call <literal moreinfo="none">upto(3,
    6)</literal>, a <literal moreinfo="none">Proc</literal> is set up to carry out this task
    for us, but it’s not actually executed until we tell it to show us the
    results. Something similar is happening when we call <literal moreinfo="none">upfrom(7)</literal>. Though this example is fairly basic,
    it gives us a jumping point into <literal moreinfo="none">lazy_stream</literal>. We can make things more interesting
    by introducing classes into the mix:<indexterm id="I_indexterm5_d1e6944" significance="normal"><primary>lazy evaluation</primary><secondary>infinite lists</secondary></indexterm><indexterm id="I_indexterm5_d1e6949" significance="normal"><primary>LazyStream::Node</primary><secondary>creating custom objects</secondary></indexterm><indexterm id="I_indexterm5_d1e6954" significance="normal"><primary>infinite lists</primary><secondary>creating custom LazyStream::Node objects</secondary></indexterm></para><programlisting id="I_programlisting5_d1e6959" format="linespecific">require "lazy_stream"

class Upto &lt; LazyStream::Node
  def initialize( from, to )
    if from &gt; to
      super(nil, &amp;nil)
    else
      super(from) { self.class.new(from + 1, to) }
    end
  end
end
Upto.new(3, 6).show  # =&gt; 3 4 5 6

class Upfrom &lt; LazyStream::Node
  def initialize( from )
    super(from) { self.class.new(from + 1) }
  end
end
Upfrom.new(7).show(10)  # =&gt; 7 8 9 10 11 12 13 14 15 16</programlisting><para>Though this code looks a bit more complex, it is also more flexible.
    What we have done is created our own custom <literal moreinfo="none">LazyStream::Node</literal> objects, which, as you can see,
    accomplish the same thing as we did before but without relying on a
    generic constructor.</para><para><literal moreinfo="none">LazyStream::Node</literal> objects are
    enumerable, and this lets us do all sorts of fun stuff. The following code
    illustrates this by constructing a simple step iterator:<indexterm id="I_indexterm5_d1e6970" significance="normal"><primary>LazyStream::Node</primary><secondary>constructing simple step iterator</secondary></indexterm><indexterm id="I_indexterm5_d1e6975" significance="normal"><primary>infinite lists</primary><secondary>using LazyStream::Node objects to create step
        iterator</secondary></indexterm></para><programlisting id="I_programlisting5_d1e6980" format="linespecific">require "lazy_stream"

class Step &lt; LazyStream::Node
  def initialize( step, start = 1 )
    super(start) { self.class.new(step, start + 1) }

    @step = step
  end

  def next_group( count = 10 )
    limit!(count).map { |i| i * @step }
  end
end

evens = Step.new(2)

puts "The first ten even numbers are:"
puts evens.next_group.join(" ")  # =&gt; 2 4 6 8 10 12 14 16 18 20

# later...

puts
puts "The next ten even numbers are:"
puts evens.next_group.join(" ")  # =&gt; 22 24 26 28 30 32 34 36 38 40

puts
puts "The current index for future calculations is:"
puts evens.current # =&gt; 21</programlisting><para>Here is where the benefit of an internal iterator becomes clear.
    When we work with a <literal moreinfo="none">Step</literal> object once
    it’s been set up, we don’t really care what its underlying function is
    from element to element. However, we can still work with it and pull out
    groups of elements as needed, keeping track of where we are in the list as
    we go along.</para><para>If we wanted to jump up in steps of three instead of two, you can
    see that the code changes are minimal:</para><programlisting id="I_programlisting5_d1e6989" format="linespecific">threes = Step.new(3)

puts "The first ten multiples of 3 are"
puts threes.next_group.join(" ")  # =&gt; 3 6 9 12 15 18 21 24 27 30

# later...

puts
puts "The next ten are:"
puts threes.next_group.join(" ")  # =&gt; 33 36 39 42 45 48 51 54 57 60

puts
puts "The current index for future calculations is:"
puts threes.current # =&gt; 21</programlisting><para>Though this stuff is pretty cool, things get a whole lot more
    interesting when you mix filters and transforms into the mix:<indexterm id="I_indexterm5_d1e6993" significance="normal"><primary>filtering</primary><secondary>using lazy stream</secondary></indexterm><indexterm id="I_indexterm5_d1e6998" significance="normal"><primary>transforms, using lazy stream</primary></indexterm><indexterm id="I_indexterm5_d1e7001" significance="normal"><primary>infinite lists</primary><secondary>using filters and transforms with lazy_stream</secondary></indexterm></para><programlisting id="I_programlisting5_d1e7006" format="linespecific">require "lazy_stream"

def letters( letter )
  lazy_stream(letter) { letters(letter.succ) }
end

letters("a").filter(/[aeiou]/).show(10)           # =&gt; a e i o u aa ab ac ad ae
letters("a").filter { |l| l.size == 2 }.show(3)   # =&gt; aa ab ac

letters("a").transform { |l| l + "..." }.show(3)  # =&gt; a... b... c...</programlisting><para>Here, we’re walking over successive ASCII string values. In the very
    first example, we ask <literal moreinfo="none">lazy_stream</literal> to
    nab us the first 10 values that contain a vowel. In the second example, we
    ask for the first three strings of length two. In the third example, we
    ask to show the first three values with <literal moreinfo="none">...</literal> appended to
    them. In all three cases, <literal moreinfo="none">lazy_stream</literal>
    is happy to provide us with what we’d expect.</para><para>To really get a sense for how nice this is, go ahead and write out a
    solution to these three problems using normal iterators and conditionals.
    Then compare your solution to using <literal moreinfo="none">lazy_stream</literal>. What you will most likely find is
    that because <literal moreinfo="none">lazy_stream</literal> internalizes a
    lot of the logic for us, it is more pleasant to work with and generally
    more expressive.</para><para>Before we move on, I’d like to show one more trick that <literal moreinfo="none">lazy_stream</literal> has up its sleeve, and that is the
    ability to build up an infinite list recursively:<indexterm id="I_indexterm5_d1e7033" significance="normal"><primary>LazyStream::Node</primary><secondary>building infinite list recursively</secondary></indexterm><indexterm id="I_indexterm5_d1e7038" significance="normal"><primary>infinite lists</primary><secondary>building up recursively using lazy_stream</secondary></indexterm></para><programlisting id="I_programlisting5_d1e7043" format="linespecific">require "lazy_stream"

class Powers &lt; LazyStream::Node
  def initialize( of, start = 1 )
    super(start) { self.class.new(of, start * of) }
  end
end

powers_of_two = Powers.new(2)
powers_of_two.show(10)  # =&gt; 1 2 4 8 16 32 64 128 256 512</programlisting><para>We have caught glimpses of this technique in other examples, but
    this one shows clearly how you can build up a list based on its previous
    values. Here we construct the powers of two by repeatedly constructing new
    <literal moreinfo="none">LazyStream::Node</literal> objects with values
    twice as much as their predecessors.</para><para>This turns out to be a simple, expressive way to traverse, filter,
    and transform lists that are linked together by a function that binds one
    element to the next. However, if this stuff is making your head hurt, you
    need to remember just the following things:<indexterm id="I_indexterm5_d1e7052" significance="normal"><primary>filtering</primary><secondary>using lazy stream</secondary></indexterm><indexterm id="I_indexterm5_d1e7057" significance="normal"><primary>infinite lists</primary><secondary>summary of important concepts</secondary></indexterm></para><itemizedlist><listitem><para>Infinite lists essentially consist of nodes that contain a value
        along with a procedure that will transform that value into the next
        element in the sequence.</para></listitem><listitem><para>Infinite lists are lazily evaluated, and thus are sometimes
        called lazy streams.</para></listitem><listitem><para>An infinite list might be an appropriate structure to use when
        you need to iterate over a sequential list in groups at various points
        in time, or if you have a general function that can be tweaked by some
        parameters to fit your needs.</para></listitem><listitem><para>For data that is sparse, memoization might be a better technique
        than using an infinite list.</para></listitem><listitem><para>When you need to do filtering or state transformation on a long
        sequence of elements that have a clear relationship from one to the
        next, a lazy stream might be the best way to go.</para></listitem><listitem><para>JEG2’s <filename moreinfo="none">lazy_stream.rb</filename> provides a
        generalized implementation of infinite lists that is worth taking a
        look at if you have a need for this sort of thing.</para></listitem></itemizedlist><para>If you’re still hanging on this far into the chapter, you’re either
    really enjoying this weird functional stuff, or you’re a very determined
    reader. Either way, you will be happy to know that all of the hard parts
    are over. Before we close the chapter and make some conclusions, let’s
    take a quick look at one of the most simple but fundamentally useful
    things Ruby has borrowed from its functional peers: higher-order
    procedures.<indexterm id="I_indexterm5_d1e7086" class="endofrange" startref="ch05_infinitelists" significance="normal"/></para></sect1><sect1 id="I_sect15_d1e7087"><title>Higher-Order Procedures</title><para>Throughout this whole chapter, we’ve been taking something for
    granted that not all languages can: in Ruby, a <literal moreinfo="none">Proc</literal> is just another object. This means we can
    sling these chunks of code around as if they were any other value, which
    results in a whole lot of powerful functionality.<indexterm class="startofrange" id="ch05_procedureshigher" significance="normal"><primary>procedures, higher-order</primary></indexterm><indexterm id="I_indexterm5_d1e7098" significance="normal"><primary>Proc objects</primary></indexterm></para><para>This feature is so ingrained in Ruby development, and so well
    integrated into the system, that it’s easy to overlook. However, I could
    not in good conscience wrap up a chapter on functional programming
    techniques without at least showing a simple example of higher-order
    procedure.</para><para>A function is said to be a higher-order function if it accepts
    another function as input or returns a function as its output. We see a
    lot of the former in Ruby; basically, we’d see this any time we provide a
    code block to a method. But functions that return functions might be a bit
    less familiar to those who are new to the language.<indexterm id="I_indexterm5_d1e7105" significance="normal"><primary>functions</primary><secondary>higher-order</secondary></indexterm></para><para>Through closures, we can use a function to essentially build up
    customized procedures on the fly. I could show some abstract examples or
    academically exciting functionality such as <literal moreinfo="none">Proc#curry</literal>, but instead, I decided that I wanted
    to show you something I use fairly frequently.<indexterm id="I_indexterm5_d1e7115" significance="normal"><primary>closures</primary><secondary>using functions to build custom procedures on the
        fly</secondary></indexterm></para><para>If you used Rails before Ruby 1.9, you probably were familiar with
    the “innovation” of <literal moreinfo="none">Symbol#to_proc</literal>.
    What some smart folks realized is that Ruby’s <literal moreinfo="none">&amp;block</literal> mechanism actually calls a hook on
    the underlying object, which could be self-defined. Though <literal moreinfo="none">Symbol#to_proc</literal> exists in Ruby 1.9 by default,
    let’s look at what a simple implementation of it would look like in
    Ruby:<indexterm id="I_indexterm5_d1e7131" significance="normal"><primary>to_proc methods</primary></indexterm><indexterm id="I_indexterm5_d1e7134" significance="normal"><primary>Symbol#to_proc</primary></indexterm></para><programlisting id="I_programlisting5_d1e7137" format="linespecific">class Symbol
  def to_proc
    lambda { |x| x.send(self) }
  end
end</programlisting><para>As you probably know, this feature allows for some nice syntactic
    sugar:</para><programlisting id="I_programlisting5_d1e7141" format="linespecific">&gt;&gt; %w[foo bar baz].map(&amp;:capitalize)
=&gt; ["Foo", "Bar", "Baz"]</programlisting><para>The way that it works should be easy to see from the implementation
    shown here, but in essence, what happens is that <literal moreinfo="none">&amp;:capitalize</literal> invokes <literal moreinfo="none">Symbol#to_proc</literal> and then constructs a block like
    this:</para><programlisting id="I_programlisting5_d1e7151" format="linespecific">lambda { |x| x.send(:capitalize) }</programlisting><para>This in turn is then treated as a code block, making it functionally
    identical to the following code:</para><programlisting id="I_programlisting5_d1e7156" format="linespecific">&gt;&gt; %w[foo bar baz].map { |x| x.capitalize }</programlisting><para>Of course, you’ve probably seen a hundred blog posts about this
    feature, so this is not what I’m really trying to show you. What I’d like
    you to know, and eventually take advantage of, is that <literal moreinfo="none">Object#to_proc</literal> is a generic hook. This means
    <literal moreinfo="none" role="keep-together">Symbol#to_proc</literal>
    isn’t special, and we can build our own custom objects that do even cooler
    tricks than it does.<indexterm id="I_indexterm5_d1e7166" significance="normal"><primary>Object#to_proc</primary></indexterm></para><para>The place I use this functionality all the time is in Rails
    applications where I need to build up filter mechanisms that do some of
    the work in SQL, and the rest in Ruby. Though my filter objects typically
    grow to be long, complicated, and nasty, their backbone always lies upon
    something somewhat simple. Here is the general pattern I usually start
    with:<indexterm id="I_indexterm5_d1e7171" significance="normal"><primary>filtering</primary><secondary>Filter objects doing some work in SQL and rest in
        Ruby</secondary></indexterm></para><programlisting id="I_programlisting5_d1e7176" format="linespecific">class Filter
  def initialize
    @constraints = []
  end

  def constraint(&amp;block)
    @constraints &lt;&lt; block
  end

  def to_proc
    lambda { |e| @constraints.all? { |fn| fn.call(e) } }
  end
end</programlisting><para>We can then construct a <literal moreinfo="none">Filter</literal>
    object and assign constraints to it on the fly:</para><programlisting id="I_programlisting5_d1e7183" format="linespecific">filter = Filter.new
filter.constraint { |x| x &gt; 10 }
filter.constraint { |x| x.even? }
filter.constraint { |x| x % 3 == 0 }</programlisting><para>Now, when dealing with an <literal moreinfo="none">Enumerable</literal> object, it
    is easy to filter the data based on our constraints:<indexterm id="I_indexterm5_d1e7190" significance="normal"><primary>Enumerable objects, filtering with</primary></indexterm></para><programlisting id="I_programlisting5_d1e7193" format="linespecific">p (8..24).select(&amp;filter) #=&gt; [12,18,24]</programlisting><para>As we add more constraints, new blocks are generated for us, so
    things work as <phrase role="keep-together">expected</phrase>:</para><programlisting id="I_programlisting5_d1e7200" format="linespecific">filter.constraint { |x| x % 4 == 0 }

p (8..24).select(&amp;filter) #=&gt; [12,24]</programlisting><para>As you can see, <literal moreinfo="none">Symbol#to_proc</literal>
    isn’t the only game in town. Any object that can meaningfully be reduced
    to a function can implement a useful <literal moreinfo="none">to_proc</literal> method.</para><para>Of course, higher-order procedures are not limited to <literal moreinfo="none">to_proc</literal> hacks. There are lots of other good uses
    for functions that return functions, though it is often a relatively rare
    use case, so it’s hard to give you a list of must-have techniques when it
    comes to this topic.</para><para>Because this example was short and sweet, we don’t need to go over
    various guidelines as we have in previous sections. Just keep this trick
    in the back of your mind, and use it to improve the readability and
    flexibility of your code.</para><para>We’ve covered a lot of ground here, so it’s about time to wrap up
    this chapter.<indexterm id="I_indexterm5_d1e7220" class="endofrange" startref="ch05_procedureshigher" significance="normal"/></para></sect1><sect1 id="I_sect15_d1e7222"><title>Conclusions</title><para>Although we covered a number of “functional programming techniques”
    throughout this chapter, it’s fairly plain to see that Ruby isn’t a
    functional programming language. Even if we can force Ruby into being
    pretty much whatever we want it to be, it’s generally not an advisable
    thing to do.</para><para>Nevertheless, we’ve covered some interesting and useful tricks here
    that were inspired by techniques used in other languages. By letting Ruby
    be Ruby and not striving too hard for a direct translation, we end up with
    code that is actually practical and suitable for use in everyday
    applications.</para><para>My general feeling about applying functional programming techniques
    in Ruby is mainly that they can be a true source of elegance and
    simplicity when appropriate. However, judging when it’s the right time to
    bust out some functional goodness rather than going with the more vanilla
    approach can be difficult, even among seasoned developers. It is entirely
    possible to make your code too clever, and this often has real penalties
    in performance or in the ability of other developers to easily learn your
    code.</para><para>Many functional programming techniques result in code that is highly
    readable at the expense of learnability, at least in the context of Ruby.
    If you keep an eye on that balance and make it fit within your working
    environment, you’ll be just fine.</para><para>Even if some of the techniques seen in this chapter cannot be
    readily used in a direct way in many cases, there is a lot to be said for
    thinking differently and looking at your code from another angle.
    Hopefully, this chapter has helped you do that.</para></sect1></chapter><chapter id="I_chapter6_d1e7235"><title>When Things Go Wrong</title><para>Unfortunately, neither this book nor a lifetime of practice can cause
  you to attain Ruby programming perfection. However, a good substitute for
  never making a mistake is knowing how to fix your problems as they arise.
  The purpose of this chapter is to provide you with the necessary tools and
  techniques to prepare you for Ruby search-and-rescue missions.<indexterm class="startofrange" id="ch06_debugging" significance="normal"><primary>debugging</primary></indexterm></para><para>We will start by walking through a simple but real bug-hunting session
  to get a basic outline of how to investigate issues in your Ruby projects.
  We’ll then dive into some more specific tools and techniques for helping
  refine this process. What may surprise you is that we’ll do all of this
  without ever talking about using a debugger. This is mainly because most
  Rubyists can and do get away without the use of a formal debugging tool, via
  various lightweight techniques that we’ll discuss here.</para><para>One skill set you will need in order to make the most out of what
  we’ll discuss here is a decent understanding of how Ruby’s built-in unit
  testing framework works. That means if you haven’t yet read <xref linkend="ch01" xrefstyle="chap-num-title"/>, you may want to go ahead and
  do that now.</para><para>What you will notice about this chapter is that it is much more about
  the process of problem solving in the context of Ruby than it is about
  solving any particular problem. If you keep this goal in mind while reading
  through the examples, you’ll make the most out of what we’ll discuss
  here.</para><para>Now that you know what to expect, let’s start fixing some
  stuff.</para><sect1 id="I_sect16_d1e7253"><title>A Process for Debugging Ruby Code</title><para>Part of becoming masterful at anything is learning from your
    mistakes. Because Ruby programming is no exception, I want to share one of
    my embarrassing moments so that others can benefit from it. If the
    problems with the code that I am about to show are <phrase role="keep-together">immediately</phrase> obvious to you, don’t worry
    about that. Instead, focus on the problem-solving strategies used, as
    that’s what is most important here.<indexterm class="startofrange" id="ch06_debugprocess" significance="normal"><primary>debugging</primary><secondary>process for</secondary></indexterm></para><para>We’re going to look at a simplified version of a real problem I ran
    into in my day-to-day work. One of my Rails gigs involved building a
    system for processing scholarship applications online. After users have
    filled out an application once, whether it was accepted or rejected, they
    are presented with a somewhat different application form upon renewal.
    Although it deviates a bit from our real-world application, here’s some
    simple code that illustrates that process:</para><programlisting id="I_programlisting6_d1e7268" format="linespecific">if gregory.can_renew?
  puts "Start the application renewal process"
else
  puts "Edit a pending application or submit a new one"
end</programlisting><para>At first, I thought the logic for this was simple. As long as all of
    the user’s applications had a status of either accepted or rejected, it
    was safe to say that they could renew their application. The following
    code provides a rough model that implements this <phrase role="keep-together">requirement</phrase>:</para><programlisting id="I_programlisting6_d1e7275" format="linespecific">Application = Struct.new(:state)

class User
  def initialize
    @applications = []
  end

  attr_reader :applications

  def can_renew?
    applications.all? { |e| [:accepted, :rejected].include?(e.state) }
  end
end</programlisting><para>Using this model, we can see that the output of the following code
    is <literal moreinfo="none">Start the </literal><literal role="keep-together" moreinfo="none">application
    renewal process</literal>:</para><programlisting id="I_programlisting6_d1e7284" format="linespecific">gregory = User.new
gregory.applications &lt;&lt; Application.new(:accepted)
gregory.applications &lt;&lt; Application.new(:rejected)

if gregory.can_renew?
  puts "Start the application renewal process"
else
  puts "Edit a pending application or submit a new one"
end</programlisting><para>If we add a pending application into the mix, we see that the other
    case is triggered, outputting <literal moreinfo="none">Edit a pending application or
    submit a new one</literal>:</para><programlisting id="I_programlisting6_d1e7291" format="linespecific">gregory = User.new
gregory.applications &lt;&lt; Application.new(:accepted)
gregory.applications &lt;&lt; Application.new(:rejected)
gregory.applications &lt;&lt; Application.new(:pending)

if gregory.can_renew?
  puts "Start the application renewal process"
else
  puts "Edit a pending application or submit a new one"
end</programlisting><para>So far everything has been going fine, but the next bit of code
    exposes a nasty edge case:</para><programlisting id="I_programlisting6_d1e7296" format="linespecific">gregory = User.new

if gregory.can_renew?
  puts "Start the application renewal process"
else
  puts "Edit a pending application or submit a new one"
end</programlisting><para>I fully expected this to print out <literal moreinfo="none">Edit a pending
    application or submit a new one</literal>, but it managed to print the
    other message instead!</para><para>Popping open <emphasis>irb</emphasis>, I tracked down the root of
    the problem:</para><programlisting id="I_programlisting6_d1e7308" format="linespecific">&gt;&gt; gregory = User.new
=&gt; #&lt;User:0x2618bc @applications=[]&gt;
&gt;&gt; gregory.can_renew?
=&gt; true

&gt;&gt; gregory.applications
=&gt; []
&gt;&gt; gregory.applications.all? { false }
=&gt; true</programlisting><para>Of course, the trouble here was due to an incorrect use of the
    <literal moreinfo="none">Enumerable#all?</literal> method. I had been
    relying on Ruby to do what I meant rather than what I actually asked it to
    do, which is usually a bad idea. For some reason I thought that calling
    <literal moreinfo="none">all?</literal> on an empty array would return
    <literal moreinfo="none">nil</literal> or <literal moreinfo="none">false</literal>, but instead, it returned <literal moreinfo="none">true</literal>. To fix it, I’d need to rethink <literal moreinfo="none">can_renew?</literal> a little bit.<indexterm id="I_indexterm6_d1e7331" significance="normal"><primary>Enumerable#all? method</primary></indexterm></para><para>I could have fixed the issue immediately by adding a special case
    involving <literal moreinfo="none" role="keep-together">applications.empty?</literal>, but I wanted to be
    sure this bug wouldn’t have a chance to crop up again. The easiest way to
    do this was to write some tests, which I probably should have done in the
    first place.<indexterm id="I_indexterm6_d1e7339" significance="normal"><primary>testing</primary><secondary>writing test case in debugging process</secondary></indexterm><indexterm id="I_indexterm6_d1e7344" significance="normal"><primary>debugging</primary><secondary>writing test case</secondary></indexterm></para><para>The following simple test case clearly specified the behavior I
    expected, splitting it up into three cases as we did before:</para><programlisting id="I_programlisting6_d1e7351" format="linespecific">require "test/unit"

class UserTest &lt; Test::Unit::TestCase
  def setup
    @gregory = User.new
  end

  def test_a_new_applicant_cannot_renew
    assert_block("Expected User#can_renew? to be false for a new applicant") do
      not @gregory.can_renew?
    end
  end

  def test_a_user_with_pending_applications_cannot_renew
    @gregory.applications &lt;&lt; app(:accepted) &lt;&lt; app(:pending)

    msg = "Expected User#can_renew? to be false when user has pending applications"
    assert_block(msg) do
      not @gregory.can_renew?
    end
  end

  def test_a_user_with_only_accepted_and_rejected_applications_can_renew
    @gregory.applications &lt;&lt; app(:accepted) &lt;&lt; app(:rejected) &lt;&lt; app(:accepted)
    msg = "Expected User#can_renew? to be true when all applications " + 
          "are accepted or rejected"
    assert_block(msg) { @gregory.can_renew? }
  end

  private

  def app(name)
    Application.new(name)
  end

end</programlisting><para>When we run the tests, we can clearly see the failure that we
    investigated manually a little earlier:</para><programlisting id="I_programlisting6_d1e7355" format="linespecific">  1) Failure:
test_a_new_applicant_cannot_renew(UserTest) [foo.rb:24]:
Expected User#can_renew? to be false for a new applicant

3 tests, 3 assertions, 1 failures, 0 errors</programlisting><para>Now that we’ve successfully captured the essence of the bug, we can
    go about fixing it. As you may suspect, the solution is simple:</para><programlisting id="I_programlisting6_d1e7360" format="linespecific">def can_renew?
  return false if applications.empty?
  applications.all? { |e| [:accepted, :rejected].include?(e.state) }
end</programlisting><para>Running the tests again, we see that everything passes:</para><programlisting id="I_programlisting6_d1e7364" format="linespecific">3 tests, 3 assertions, 0 failures, 0 errors</programlisting><para>If we went back and ran our original examples that print some
    messages to the screen, we’d see that those now work as expected as well.
    We could have used those on their own to test our attempted fix, but by
    writing automated tests, we have a safety net against regressions, which
    may be one of the main benefits of unit tests.</para><para>Though the particular bug we squashed may be a bit boring, what we
    have shown is a repeatable procedure for bug hunting, without ever firing
    up a debugger or combing through logfiles. To recap, here’s the general
    plan for how things should play out:<indexterm id="I_indexterm6_d1e7370" significance="normal"><primary>debugging</primary><secondary>procedure for</secondary></indexterm></para><?dbfo-need height=”1in”
?><orderedlist inheritnum="ignore" continuation="restarts"><listitem><para>First, identify the different scenarios that apply to a given
        feature.</para></listitem><listitem><para>Enumerate over these scenarios to identify which ones are
        affected by defects and which ones work as expected. This can be done
        in many ways, ranging from printing debugging messages on the command
        line to logfile analysis and live application testing. The important
        thing is to identify and isolate the cases affected by the bug.</para></listitem><listitem><para>Hop into <emphasis>irb</emphasis> if possible and take a look at
        what your objects actually look like under the hood. Experiment with
        the failing scenarios in a step-by-step fashion to try to dig down and
        uncover the root cause of problems.</para></listitem><listitem><para>Write tests to reproduce the problems you are having, along with
        what you expect to happen when the issue is resolved.</para></listitem><listitem><para>Implement a fix that passes the tests, and then repeat the
        process until all issues are resolved.</para></listitem></orderedlist><para>Sometimes, it’s possible to condense this process into two steps
    simply by writing a test that reproduces the bug and then introducing a
    fix that passes the tests. However, most of the time the extra legwork
    will pay off, as understanding the root cause of the problem will allow
    you to treat your application’s disease all at once rather than <phrase role="keep-together">addressing</phrase> its symptoms one by one.</para><para>Given this basic outline of how to isolate and resolve issues within
    our code, we can now focus on some specific tools and techniques that will
    help improve the process for us.<indexterm id="I_indexterm6_d1e7402" class="endofrange" startref="ch06_debugprocess" significance="normal"/></para></sect1><sect1 id="I_sect16_d1e7403"><title>Capturing the Essence of a Defect</title><para>Before you can begin to hunt down a bug, you need to be able to
    reproduce it in isolation. The main idea is that if you remove all the
    extraneous code that is unrelated to the issue, it will be easier to see
    what is really going on. As you continue to investigate an issue, you may
    discover that you can reduce the example more and more based on what you
    learn. Because I have a real example handy from one of my projects, we can
    look at this process in action to see how it plays out.<indexterm class="startofrange" id="ch06_debugreduce" significance="normal"><primary>debugging</primary><secondary>producing reduced example of defect</secondary></indexterm></para><para>What follows is some Prawn code that was submitted as a bug report.
    The problem it’s supposed to show is that every text <literal moreinfo="none">span()</literal> resulted in a page break happening, when
    it wasn’t supposed to:</para><programlisting id="I_programlisting6_d1e7418" format="linespecific">Prawn::Document.generate("span.pdf") do

  span(350, :position =&gt; :center) do
    text "Here's some centered text in a 350 point column. " * 100
  end

  text "Here's my sentence."

  bounding_box([50,300], :width =&gt; 400) do
    text "Here's some default bounding box text. " * 10
    span(bounds.width,
      :position =&gt; bounds.absolute_left - margin_box.absolute_left) do
      text "The rain in Spain falls mainly on the plains. " * 300
    end
  end

  text "Here's my second sentence."

end</programlisting><para>Without a strong knowledge of Prawn, this example may already seem
    fairly reduced. After all, the text represents a sort of abstract problem
    definition rather than some code that was ripped out of an application,
    and that is a good start. But upon running this code, I noticed that the
    defect was present whenever a <literal moreinfo="none">span()</literal>
    call was made. This allowed me to reduce the example substantially:</para><programlisting id="I_programlisting6_d1e7425" format="linespecific">Prawn::Document.generate("span.pdf") do

  span(350) do
    text "Here's some text in a 350pt wide column. " * 20
  end

  text "This text should appear on the same page as the spanning text"

end</programlisting><para>Whether or not you have any practical experience in Prawn, the issue
    stands out better in this revised example, simply because there is less
    code to consider. The code is also a bit more self-documenting, which
    makes buggy output harder to miss. Many bug reports can be reduced in a
    similar fashion. Of course, not everything compacts so well, but every
    little bit of simplification helps.</para><para>Most bugs aren’t going to show up in the first place you look.
    Instead, they’ll often be hidden farther down the chain, stashed away in
    some low-level helper method or in some other code that your feature
    depends on. As this is so common, I’ve developed the habit of mentally
    tracing the execution path that my example code follows, in hopes of
    finding some obvious mistake along the way. If I notice anything
    suspicious, I start the next iteration of bug reproduction.</para><para>Using this approach, I found that the problem with <literal moreinfo="none">span()</literal> wasn’t actually in <literal moreinfo="none">span()</literal> at all. Although the details aren’t
    important, it turns out that the core problem was in a lower-level
    function called <literal moreinfo="none">canvas()</literal>, which
    <literal moreinfo="none">span()</literal> relies on. This method was
    incorrectly setting the text cursor on the page to the very bottom of the
    page after executing its block argument. I used the following example to
    confirm this was the case:<indexterm id="I_indexterm6_d1e7445" significance="normal"><primary>debugging</primary><secondary>coding failing test to reproduce problem</secondary></indexterm></para><programlisting id="I_programlisting6_d1e7450" format="linespecific">Prawn::Document.generate("canvas_sets_y_to_0.pdf") do
  canvas { text "Some text at the absolute top left of the page" }

  text "This text should not be after a pagebreak"
end</programlisting><para>When I saw that I was able to reproduce the problem, I went on to
    formally specify what was wrong in the form of tests, feeling reasonably
    confident that this was the root defect.</para><para>Whenever you are hunting for bugs, the practice of reducing your
    area of interest first will help you avoid dead ends and limit the number
    of possible places in which you’ll need to look for problems. Before doing
    any formal investigation, it’s a good idea to check for obvious problems
    so that you can get a sense of where the real source of your defect is.
    Some bugs are harder to catch on sight than others, but there is no need
    to overthink the easy ones.</para><para>If a defect can be reproduced in isolation, you can usually narrow
    it down to a specific deviation from what you expected to happen. We’ll
    now take a look at how to go from an example that reproduces a bug to a
    failing test that fully categorizes it.</para><para>The main benefit of an automated test is that it will explode when
    your code fails to act as expected. It is important to keep in mind that
    even if you have an existing test suite, when you encounter a bug that
    does not cause any failures, you need to update your tests. This helps
    prevent regressions, allowing you to fix a bug once and forget about
    it.<indexterm id="I_indexterm6_d1e7461" significance="normal"><primary>debugging</primary><secondary>converting simplified example to part of automated test
        suite</secondary></indexterm></para><para>Continuing with our example, here is a simple but sufficient test to
    corner the bug:</para><programlisting id="I_programlisting6_d1e7468" format="linespecific">class CanvasTest &lt; Test::Unit::TestCase

  def setup
    @pdf = Prawn::Document.new
  end

  def test_canvas_should_not_reset_y_to_zero
    after_text_position = nil

    @pdf.canvas do
      @pdf.text "Hello World"
      after_text_position = @pdf.y
    end

    assert_equal after_text_position, @pdf.y
  end
end</programlisting><para>Here, we expect the <emphasis>y</emphasis> coordinate after the
    <literal moreinfo="none">canvas</literal> block is executed to be the same
    as it was just after the text was rendered to the page. Running this test
    reproduces the problem we created an example for earlier:</para><programlisting id="I_programlisting6_d1e7478" format="linespecific">  1) Failure:test_canvas_should_not_reset_y_to_zero(CanvasTest) [---]
&lt;778.128&gt; expected but was
&lt;0.0&gt;.</programlisting><para>Here, we have converted our simplified example into something that
    can become a part of our automated test suite. The simpler an example is,
    the easier this is to do. More <phrase role="keep-together">complicated</phrase> examples may need to be broken
    into several chunks, but this <phrase role="keep-together">process</phrase> is straightforward more often than
    not.</para><para>Once we write a test that reproduces our problem, the way we fix it
    is to get our tests passing again. If other tests end up breaking in order
    to get our new test to pass, we know that something is still wrong. If for
    some reason our problem isn’t solved when we get all the tests passing
    again, it means that our reduced example probably didn’t cover the
    entirety of the problem, so we need to go back to the drawing board in
    those cases. Even still, not all is lost. Each test serves as a
    significant reduction of your problem space. Every passing assertion
    eliminates the possibility of that particular issue from being the root of
    your problem. Sooner or later, there won’t be any place left for your bugs
    to hide.</para><para>For those who need a recap, here are the keys to producing a good
    reduced example:</para><itemizedlist><listitem><para>Remove as much extraneous code as possible from your example,
        and the bug will be clearer to see.</para></listitem><listitem><para>Try to make your example self-describing, so that even someone
        unfamiliar with the core issue can see at a glance whether something
        is wrong. This helps others report regressions even if they don’t
        fully understand the internals of your project.</para></listitem><listitem><para>Continue to revise your examples until they reach the root cause
        of the problem. Don’t throw away any of the higher-level examples
        until you verify that fixing a general problem solves the specific
        issue that you ran into as well.</para></listitem><listitem><para>When you understand the root cause of your problem, code up a
        failing test that demonstrates how the code should work. When it
        passes, the bug should be gone. If it fails again, you’ll know there
        has been a regression.<indexterm id="I_indexterm6_d1e7505" class="endofrange" startref="ch06_debugreduce" significance="normal"/></para></listitem></itemizedlist></sect1><sect1 id="I_sect16_d1e7506"><title>Scrutinizing Your Code</title><para>When things aren’t working the way you expect them to, you obviously
    need to find out why. There are certain tricks that can make this task a
    lot easier on you, and you can use them without ever needing to fire up
    the debugger.<indexterm class="startofrange" id="ch06_scrutinizingcode" significance="normal"><primary>scrutinizing code</primary></indexterm><indexterm class="startofrange" id="ch06_debugscrutinize" significance="normal"><primary>debugging</primary><secondary>scrutinizing code</secondary></indexterm></para><sect2><title>Utilizing Reflection</title><para>Many bugs come from using an object in a different way than you’re
      supposed to, or from some internal state deviating from your
      expectations. To be able to detect and fix these bugs, you need to be
      able to get a clear picture of what is going on under the hood in the
      objects you’re working with.<indexterm class="startofrange" id="ch06_scrutinyreflect" significance="normal"><primary>scrutinizing code</primary><secondary>using reflection</secondary></indexterm><indexterm class="startofrange" id="ch06_reflection" significance="normal"><primary>reflection, using to inspect code</primary></indexterm><indexterm id="I_indexterm6_d1e7532" significance="normal"><primary>Object#inspect method</primary></indexterm><indexterm id="I_indexterm6_d1e7535" significance="normal"><primary>Kernel#p method</primary></indexterm></para><para>I’ll assume that you already know that <literal moreinfo="none">Kernel#p</literal> and <literal moreinfo="none">Object#inspect</literal> exist, and how to use them for
      basic needs. However, when left to their default behaviors, using these
      tools to debug complex objects can be too painful to be practical. We
      can take an unadorned <literal moreinfo="none">Prawn::Document</literal>’s <literal moreinfo="none">inspect</literal>
      output for an example:<indexterm id="I_indexterm6_d1e7552" significance="normal"><primary>Prawn::Document#inspect output</primary></indexterm></para><programlisting id="I_programlisting6_d1e7555" format="linespecific">#&lt;Prawn::Document:0x12cf17c @page_content=#&lt;Prawn::Reference:0x12cecf4
@data={:Length=&gt;0}, @gen=0, @identifier=4, @stream="0.000 0.000 0.000 r
g\n0.000 0.000 0.000 RG\nq\n", @compressed=false&gt;, @info=
#&lt;Prawn::Reference:0x12cf0c8  @data={:Creator=&gt;"Prawn", :Producer=&gt;"Prawn"},
@gen=0, @identifier=1, @compressed=false&gt;
, @root=#&lt;Prawn::Reference:0x12cf064 @data={:Type=&gt;:Catalog, :Pages=&gt;
#&lt;Prawn::Reference:0x12cf08c @data={:Count=&gt;1, :Kids=&gt;[#&lt;Prawn::Reference:0x12ceca4
@data={:Contents=&gt;#&lt;Prawn::Reference:0x12cecf4
@data={:Length=&gt;0}, @gen=0, @identifier=4, @stream="0.000 0.000 0.000 rg\n0.000
0.000 0.000 RG\nq\n",

&lt;&lt; ABOUT 50 MORE LINES LIKE THIS &gt;&gt;

#&lt;Prawn::Reference:0x12cf08c @data={:Count=&gt;1, :Kids=&gt;[#&lt;Prawn::Reference:0x12ceca4
...&gt;], :Type=&gt;:Pages}, @gen=0, @identifier=2, @compressed=false&gt;,
:MediaBox=&gt;[0, 0, 612.0, 792.0]}, @gen=0, @identifier=5, @compressed=false&gt;],
@margin_box=#&lt;Prawn::Document::BoundingBox:0x12ced30 @width=540.0,
@y=756.0, @x=36, @parent=#&lt;Prawn::Document:0x12cf17c ...&gt;, @height=720.0&gt;,
@fill_color="000000", @current_page=#&lt;Prawn::Reference:0x12ceca4 @data={:Contents=&gt;
#&lt;Prawn::Reference:0x12cecf4  @data={:Length=&gt;0}, @gen=0, @identifier=4,
@stream="0.000 0.000 0.000 rg\n0.000 0.000 0.000 RG\nq\n",  @compressed=false&gt;,
:Type=&gt;:Page, :Parent=&gt;#&lt;Prawn::Reference:0x12cf08c  @data={:Count=&gt;1,
:Kids=&gt;[#&lt;Prawn::Reference:0x12ceca4 ...&gt;], :Type=&gt;:Pages},
@gen=0, @identifier=2, @compressed=false&gt;,  :MediaBox=&gt;[0, 0, 612.0, 792.0]},
@gen=0, @identifier=5, @compressed=false&gt;, @skip_encoding=nil,
@bounding_box=#&lt;Prawn::Document::BoundingBox:0x12ced30 @width=540.0, @y=756.0, @x=36,
@parent=#&lt;Prawn::Document:0x12cf17c ...&gt;, @height=720.0&gt;, @page_size="LETTER",
@stroke_color="000000" , @text_options={}, @compress=false, @margins={:top=&gt;36,
:left=&gt;36, :bottom=&gt;36, :right=&gt;36}&gt;</programlisting><para>Although this information sure is thorough, it probably won’t help
      us quickly identify what page layout is being used or what the
      dimensions of the margins are. If we aren’t familiar with the internals
      of this object, such verbose output is borderline useless. Of course,
      this doesn’t mean we’re simply out of luck. In situations like this, we
      can infer a lot about an object by using Ruby’s reflective
      capabilities:</para><programlisting id="I_programlisting6_d1e7559" format="linespecific">&gt;&gt; pdf.class
=&gt; Prawn::Document

&gt;&gt; pdf.instance_variables
=&gt; [:@objects, :@info, :@pages, :@root, :@page_size, :@page_layout, :@compress,
:@skip_encoding, :@background, :@font_size, :@text_options, :@margins, :@margin_box,
:@bounding_box, :@page_content, :@current_page, :@fill_color, :@stroke_color, :@y]

&gt;&gt; Prawn::Document.instance_methods(inherited_methods=false).sort
=&gt; [:bounding_box, :bounds, :bounds=, :canvas, :compression_enabled?, :cursor,
:find_font, :font, :font_families, :font_registry, :font_size, :font_size=,
:margin_box, :margin_box=, :margins, :mask, :move_down, :move_up, :pad, :pad_bottom, 
:pad_top, :page_count, :page_layout, :page_size, :render, :render_file, :save_font, 
:set_font, :span, :start_new_page, :text_box, :width_of, :y, :y=]

&gt;&gt; pdf.private_methods(inherited_methods=false)
=&gt; [:init_bounding_box, :initialize, :build_new_page_content, :generate_margin_box]</programlisting><para>Now, even if we haven’t worked with this particular object before,
      we have a sense of what is available, and it makes queries like the ones
      mentioned in the previous paragraph much easier:</para><programlisting id="I_programlisting6_d1e7563" format="linespecific">&gt;&gt; pdf.margins
=&gt; {:left=&gt;36, :right=&gt;36, :top=&gt;36, :bottom=&gt;36}

&gt;&gt; pdf.page_layout
=&gt; :portrait</programlisting><para>If we want to look at some lower-level details, such as the
      contents of some instance variables, we can do so via <literal moreinfo="none">instance_variable_get</literal>:<indexterm id="I_indexterm6_d1e7570" significance="normal"><primary>instance_variable_get( ) function</primary></indexterm></para><programlisting id="I_programlisting6_d1e7573" format="linespecific">&gt;&gt; pdf.instance_variable_get(:@current_page)
=&gt; #&lt;Prawn::Reference:0x4e5750 @identifier=5, @gen=0, @data={:Type=&gt;:Page,
:Parent=&gt;#&lt;Prawn::Reference:0x4e5b60 @identifier=2, @gen=0, @data={:Type=&gt;:Pages,
:Count=&gt;1, :Kids=&gt;[#&lt;Prawn::Reference:0x4e5750 ...&gt;]}, @compressed=false,
@on_encode=nil&gt;, :MediaBox=&gt;[0, 0, 612.0, 792.0], 
:Contents=&gt;#&lt;Prawn::Reference:0x4e57a0 @identifier=4, @gen=0, @data={:Length=&gt;0}, 
@compressed=false, @on_encode=nil, 
@stream="0.000 0.000 0.000 rg\n0.000 0.000 0.000 RG\nq\n"&gt;}, @compressed=false,
@on_encode=nil&gt;</programlisting><para>Using these tricks, we can easily determine whether we’ve
      accidentally got the name of a variable or method wrong. We can also see
      what the underlying structure of our objects are, and repeat this
      process to drill down and investigate potential problems.<indexterm id="I_indexterm6_d1e7577" class="endofrange" startref="ch06_scrutinyreflect" significance="normal"/><indexterm id="I_indexterm6_d1e7578" class="endofrange" startref="ch06_reflection" significance="normal"/></para></sect2><sect2><title>Improving inspect Output</title><para>Of course, the whole situation here would be better if we had
      easier-to-read <literal moreinfo="none">inspect</literal> output. There is actually a
      standard library called <filename moreinfo="none">pp</filename> that improves the
      formatting of <literal moreinfo="none">inspect</literal> while operating in a very
      similar fashion. I wrote a whole section in <xref linkend="appb"/>
      about this library, including some of its advanced capabilities. You
      should definitely read up on what <literal moreinfo="none">pp</literal>
      offers you when you get the chance, but here I’d like to cover some
      alternative approaches that can also come in handy.<indexterm id="I_indexterm6_d1e7599" significance="normal"><primary>scrutinizing code</primary><secondary>improving inspect output</secondary></indexterm><indexterm id="I_indexterm6_d1e7604" significance="normal"><primary>inspect output, improving</primary></indexterm><indexterm id="I_indexterm6_d1e7607" significance="normal"><primary>pp (prettyprint) standard library</primary></indexterm></para><para>As it turns out, the output of <literal moreinfo="none">Kernel#p</literal> can be improved on an
      object-by-object basis. This may be obvious if you have used <literal moreinfo="none">Object#inspect</literal> before, but it is also a
      severely underused feature of Ruby. This feature can be used to turn the
      mess we saw in the previous section into beautiful debugging
      output:<indexterm id="I_indexterm6_d1e7618" significance="normal"><primary>Kernel#p method</primary><secondary>improving output</secondary></indexterm></para><programlisting id="I_programlisting6_d1e7623" format="linespecific">&gt;&gt; pdf = Prawn::Document.new
=&gt; &lt; Prawn::Document:0x27df8a:
      @background: nil
      @compress: false
      @fill_color: "000000"
      @font_size: 12
      @margins: {:left=&gt;36, :right=&gt;36, :top=&gt;36, :bottom=&gt;36}
      @page_layout: :portrait
      @page_size: "LETTER"
      @skip_encoding: nil
      @stroke_color: "000000"
      @text_options: {}
      @y: 756.0

      @bounding_box -&gt; Prawn::Document::BoundingBox:0x27dd64
      @current_page -&gt; Prawn::Reference:0x27dd1e
      @info -&gt; Prawn::Reference:0x27df44
      @margin_box -&gt; Prawn::Document::BoundingBox:0x27dd64
      @objects -&gt; Array:0x27df6c
      @page_content -&gt; Prawn::Reference:0x27dd46
      @pages -&gt; Prawn::Reference:0x27df26
      @root -&gt; Prawn::Reference:0x27df12 &gt;</programlisting><para>I think you’ll agree that this looks substantially easier to
      follow than the default <literal moreinfo="none">inspect</literal> output. To accomplish
      this, I put together a template that allows you to pass in a couple of
      arrays of symbols that point at instance variables:<indexterm id="I_indexterm6_d1e7630" significance="normal"><primary>InspectTemplate module</primary></indexterm></para><programlisting id="I_programlisting6_d1e7633" format="linespecific">module InspectTemplate

  def __inspect_template(objs, refs)
    obj_output = objs.sort.each_with_object("") do |v,out|
       out &lt;&lt; "\n      #{v}: #{instance_variable_get(v).inspect}"
    end

    ref_output = refs.sort.each_with_object("") do |v,out|
      ref = instance_variable_get(v)
      out &lt;&lt; "\n      #{v} -&gt; #{__inspect_object_tag(ref)}"
    end

    "&lt; #{__inspect_object_tag(self)}: #{obj_output}\n#{ref_output} &gt;"
  end

  def __inspect_object_tag(obj)
    "#{obj.class}:0x#{obj.object_id.to_s(16)}"
  end

end</programlisting><para>After mixing this into <literal moreinfo="none">Prawn::Document</literal>, I need only to specify which
      variables I want to display the entire contents of, and which I want to
      just show as references. Then, it is as easy as calling <literal moreinfo="none">__inspect_template</literal> with these values:</para><programlisting id="I_programlisting6_d1e7643" format="linespecific">class Prawn::Document

  include InspectTemplate

  def inspect
    objs = [ :@page_size, :@page_layout, :@margins, :@font_size, :@background,
             :@stroke_color, :@fill_color, :@text_options, :@y, :@compress,
             :@skip_encoding ]
    refs = [ :@objects, :@info, :@pages, :@bounding_box, :@margin_box, 
             :@page_content, :@current_page, :@root]
    __inspect_template(objs,refs)
  end
end</programlisting><para>Once we provide a customized <literal moreinfo="none">inspect</literal> method that returns a string, both
      <literal moreinfo="none">Kernel#p</literal> and <emphasis>irb</emphasis>
      will pick up on it, yielding the nice results shown earlier.</para><para>Although my <literal moreinfo="none">InspectTemplate</literal> can
      easily be reused, it carries the major caveat that you become 100%
      responsible for exposing your variables for debugging output. Anything
      not explicitly passed to <literal moreinfo="none">__inspect_template</literal> will not be rendered.
      However, there is a middle-of-the-road solution that is far more
      automatic.</para><para>The <emphasis>yaml</emphasis> data serialization standard library
      has the nice side effect of producing highly readable representations of
      Ruby objects. Because of this, it actually provides a <literal moreinfo="none" role="keep-together">Kernel#y</literal> method that can
      be used as a stand-in replacement for <literal moreinfo="none">p</literal>. Although this may be a bit strange, if you
      look at it in action, you’ll see that it has some benefits:<indexterm id="I_indexterm6_d1e7675" significance="normal"><primary>Kernel#y method</primary></indexterm><indexterm class="startofrange" id="ch06_serializationYAML" significance="normal"><primary>serialization</primary><secondary>yaml standard library</secondary></indexterm><indexterm class="startofrange" id="ch06_yamllib" significance="normal"><primary>yaml standard library</primary></indexterm></para><programlisting id="I_programlisting6_d1e7687" format="linespecific">&gt;&gt; require "yaml"
=&gt; true

&gt;&gt; y Prawn::Document.new
--- &amp;id007 !ruby/object:Prawn::Document
background:
bounding_box: &amp;id002 !ruby/object:Prawn::Document::BoundingBox
  height: 720.0
  parent: *id007
  width: 540.0
  x: 36
  y: 756.0
compress: false
info: &amp;id003 !ruby/object:Prawn::Reference
  compressed: false
  data:
    :Creator: Prawn
    :Producer: Prawn
  gen: 0
  identifier: 1
  on_encode:
margin_box: *id002
margins:
  :left: 36
  :right: 36
  :top: 36
  :bottom: 36
page_content: *id005
page_layout: :portrait
page_size: LETTER
pages: *id004
root: *id006
skip_encoding:
stroke_color: "000000"
text_options: {}

y: 756.0
=&gt; nil</programlisting><?dbfo-need height=”1in”
?><para>I truncated this file somewhat, but the basic structure shines
      through. You can see that YAML nicely shows nested object relations, and
      generally looks neat and tidy. Interestingly enough, YAML automatically
      truncates repeated object references by referring to them by ID only.
      This turns out to be especially good for tracking down a certain kind of
      Ruby bug:</para><programlisting id="I_programlisting6_d1e7692" format="linespecific">&gt;&gt; a = Array.new(6)
=&gt; [nil, nil, nil, nil, nil, nil]
&gt;&gt; a = Array.new(6,[])
=&gt; [[], [], [], [], [], []]
&gt;&gt; a[0] &lt;&lt; "foo"
=&gt; ["foo"]
&gt;&gt; a
=&gt; [["foo"], ["foo"], ["foo"], ["foo"], ["foo"], ["foo"]]
&gt;&gt; y a
---
- &amp;id001
  - foo
- *id001
- *id001
- *id001
- *id001
- *id001</programlisting><para>Here, it’s easy to see that the six subarrays that make up our
      main array are actually just six references to the same object. And in
      case that wasn’t the goal, we can see the difference when we have six
      distinct objects very clearly in YAML:</para><programlisting id="I_programlisting6_d1e7696" format="linespecific">&gt;&gt; a = Array.new(6) { [] }
=&gt; [[], [], [], [], [], []]
&gt;&gt; a[0] &lt;&lt; "foo"
=&gt; ["foo"]
&gt;&gt; a
=&gt; [["foo"], [], [], [], [], []]
&gt;&gt; y a
---
- - foo
- []

- []

- []

- []

- []</programlisting><para>Although this may not be a problem you run into every day, it’s
      relatively easy to forget to deep-copy a structure from time to time, or
      to accidentally create many copies of a reference to the same object
      when you’re trying to set default values. When that happens, a quick
      call to <literal moreinfo="none">y</literal> will make a long series of
      references to the same object appear very clearly.</para><para>Of course, the YAML output will come in handy when you encounter
      this problem by accident or if it is part of some sort of deeply nested
      structure. If you already know exactly where to look and can easily get
      at it, using pure Ruby works fine as well:</para><programlisting id="I_programlisting6_d1e7705" format="linespecific">&gt;&gt; a = Array.new(6) { [] }
=&gt; [[], [], [], [], [], []]
&gt;&gt; a.map { |e| e.object_id }
=&gt; [3423870, 3423860, 3423850, 3423840, 3423830, 3423820]
&gt;&gt; b = Array.new(6,[])
=&gt; [[], [], [], [], [], []]
&gt;&gt; b.map { |e| e.object_id }
=&gt; [3431570, 3431570, 3431570, 3431570, 3431570, 3431570]</programlisting><para>So far, we’ve been focusing very heavily on how to inspect your
      objects. This is mostly because a great deal of Ruby bugs can be solved
      by simply getting a sense of what objects are being passed around and
      what data they really contain. But this is, of course, not the full
      extent of the problem; we also need to be able to work with code that
      has been set in motion.<indexterm id="I_indexterm6_d1e7709" class="endofrange" startref="ch06_serializationYAML" significance="normal"/><indexterm id="I_indexterm6_d1e7710" class="endofrange" startref="ch06_yamllib" significance="normal"/></para></sect2><sect2><title>Finding Needles in a Haystack</title><para>Sometimes it’s impossible to pull up a defective object easily to
      directly inspect it. Consider, for example, a large dataset that has
      some occasional anomalies in it. If you’re dealing with tens or hundreds
      of thousands of records, an error like this won’t be very helpful after
      your script churns for a while and then goes right off the
      tracks:<indexterm id="I_indexterm6_d1e7716" significance="normal"><primary>scrutinizing code</primary><secondary>finding defects in very large dataset</secondary></indexterm></para><programlisting id="I_programlisting6_d1e7721" format="linespecific">&gt;&gt; @data.map { |e|Integer(e[:amount]) }
ArgumentError: invalid value for Integer: "157,000"
        from (irb):10:in 'Integer'
        from (irb):10
        from (irb):10:in 'inject'
        from (irb):10:in 'each'
        from (irb):10:in 'inject'
        from (irb):10
        from :0</programlisting><para>This error tells you virtually nothing about what has happened,
      except that somewhere in your giant dataset, there is an invalidly
      formatted integer. Let’s explore how to deal with situations like this,
      by creating some data and introducing a few problems into it.<indexterm id="I_indexterm6_d1e7725" significance="normal"><primary>testing</primary><secondary>generating fake data for</secondary></indexterm><indexterm id="I_indexterm6_d1e7730" significance="normal"><primary>faker gem</primary></indexterm></para><para>When it comes to generating fake data for testing, you can’t get
      easier than the <emphasis>faker</emphasis> gem. Here’s a sample of
      creating an array of hash records containing 5,000 names, <phrase role="keep-together">phone numbers</phrase>, and payments:</para><programlisting id="I_programlisting6_d1e7741" format="linespecific">&gt;&gt; data = 5000.times.map do
?&gt;   { name: Faker::Name.name, phone_number: Faker::PhoneNumber.phone_number,
?&gt;     payment: rand(10000).to_s }
&gt;&gt; end

&gt;&gt; data.length
=&gt; 5000
&gt;&gt; data[0..2]
=&gt; [{:name=&gt;"Joshuah Wyman", :phone_number=&gt;"393-258-6420", :payment=&gt;"6347"},
    {:name=&gt;"Kraig Jacobi", :phone_number=&gt;"779-295-0532", :payment=&gt;"9186"},
    {:name=&gt;"Jevon Harris", :phone_number=&gt;"985.169.0519", :payment=&gt;"213"}]</programlisting><para>Now, we can randomly corrupt a handful of records, to give us a
      basis for this example. Keep in mind that the purpose of this
      demonstration is to show how to respond to unanticipated problems,
      rather than a known issue with your data.</para><programlisting id="I_programlisting6_d1e7745" format="linespecific">5.times { data[rand(data.length)][:payment] &lt;&lt; ".25" }</programlisting><para>Now if we ask a simple question such as which records have an
      amount over 1,000, we get our familiar and useless error:</para><programlisting id="I_programlisting6_d1e7749" format="linespecific">&gt;&gt; data.select { |e| Integer(e[:payment]) &gt; 1000 }
ArgumentError: invalid value for Integer: "1991.25"</programlisting><para>At this point, we’d like to get some more information about where
      this problem is actually located in our data, and what the individual
      record looks like. Because we presumably have no idea how many of these
      records there are, we might start by rescuing a single failure and then
      reraising the error after printing some of this data to the screen.
      We’ll use a <literal moreinfo="none">begin...rescue</literal> construct
      here as well as <literal moreinfo="none">Enumerable#with_index</literal>:<indexterm id="I_indexterm6_d1e7759" significance="normal"><primary>errors, reraising</primary></indexterm><indexterm id="I_indexterm6_d1e7762" significance="normal"><primary>rescuing a failure and reraising an error</primary></indexterm><indexterm id="I_indexterm6_d1e7765" significance="normal"><primary>begin…rescue construct</primary></indexterm><indexterm id="I_indexterm6_d1e7768" significance="normal"><primary>Enumerable#with_index</primary></indexterm></para><programlisting id="I_programlisting6_d1e7772" format="linespecific">&gt;&gt; data.select.with_index do |e,i|
?&gt;   begin
?&gt;     Integer(e[:payment]) &gt; 1000
&gt;&gt;   rescue ArgumentError
&gt;&gt;      p [e,i]
&gt;&gt;      raise
&gt;&gt;   end
&gt;&gt; end
[{:name=&gt;"Mr. Clotilde Baumbach", :phone_number=&gt;"(608)779-7942", 
:payment=&gt;"1991.25"}, 91]
ArgumentError: invalid value for Integer: "1991.25"
        from (irb):67:in 'Integer'
        from (irb):67:in 'block in irb_binding'
        from (irb):65:in 'select'
        from (irb):65:in 'with_index'
        from (irb):65
        from /Users/sandal/lib/ruby19_1/bin/irb:12:in '&lt;main&gt;'</programlisting><para>So now we’ve pinpointed where the problem is coming from, and we
      know what the actual record looks like. Aside from the payment being a
      string representation of a <literal moreinfo="none">Float</literal>
      instead of an <literal moreinfo="none">Integer</literal>, it’s not
      immediately clear that there is anything else wrong with this record. If
      we drop the line that reraises the error, we can get a full report of
      records with this issue:</para><programlisting id="I_programlisting6_d1e7782" format="linespecific">&gt;&gt; data.select.with_index do |e,i|
?&gt;   begin
?&gt;      Integer(e[:payment]) &gt; 1000
&gt;&gt;   rescue ArgumentError
&gt;&gt;      p [e,i]
&gt;&gt;   end
&gt;&gt; end; nil
[{:name=&gt;"Mr. Clotilde Baumbach", :phone_number=&gt;"(608)779-7942", 
:payment=&gt;"1991.25"}, 91]
[{:name=&gt;"Oceane Cormier", :phone_number=&gt;"658.016.1612", :payment=&gt;"7361.25"}, 766]
[{:name=&gt;"Imogene Bergnaum", :phone_number=&gt;"(573)402-6508", 
:payment=&gt;"1073.25"}, 1368]
[{:name=&gt;"Jeramy Prohaska", :phone_number=&gt;"928.266.5508 x97173", 
:payment=&gt;"6109.25"}, 2398]
[{:name=&gt;"Betty Gerhold", :phone_number=&gt;"250-149-3161", :payment=&gt;"8668.25"}, 2399]
=&gt; nil</programlisting><para>As you can see, this change recovered all the rows with this
      issue. Based on this information, we could probably make a decision
      about what to do to fix the issue. But because we’re just interested in
      the process here, the actual solution doesn’t matter that much. Instead,
      the real point to remember is that when faced with an opaque error after
      iterating across a large dataset, you can go back and temporarily rework
      things to allow you to analyze the problematic data records.</para><para>You’ll see variants on this theme later on in the chapter, but for
      now, let’s recap what to remember when you are looking at your code
      under the microscope:<indexterm id="I_indexterm6_d1e7788" significance="normal"><primary>scrutinizing code</primary><secondary>guidelines for</secondary></indexterm></para><itemizedlist><listitem><para>Don’t rely on giant, ugly <literal moreinfo="none">inspect</literal>
          statements if you can avoid it. Instead, use introspection to narrow
          your search down to the specific relevant objects.</para></listitem><listitem><para>Writing your own <literal moreinfo="none">#inspect</literal>
          method allows customized output from <literal moreinfo="none">Kernel#p</literal> and within
          <emphasis>irb</emphasis>. However, this means that you are
          responsible for adding new state to the debugging output as your
          objects evolve.</para></listitem><listitem><para>YAML provides a nice <literal moreinfo="none">Kernel#y</literal> method that provides a
          structured, easy-to-read representation of Ruby objects. This is
          also useful for spotting accidental reference duplication
          bugs.</para></listitem><listitem><para>Sometimes stack traces aren’t enough. You can <literal moreinfo="none">rescue</literal> and then reraise an error after
          printing some debugging output to help you find the root cause of
          your <phrase role="keep-together">problems</phrase>.</para></listitem></itemizedlist><para>So far, we’ve talked about solutions that work well as part of the
      active debugging process. However, in many cases it is also important to
      passively collect error feedback for dealing with later. It is possible
      to do this with Ruby’s logging system, so let’s shift gears a bit and
      check it out.<indexterm id="I_indexterm6_d1e7829" class="endofrange" startref="ch06_scrutinizingcode" significance="normal"/><indexterm id="I_indexterm6_d1e7830" class="endofrange" startref="ch06_debugscrutinize" significance="normal"/></para></sect2></sect1><sect1 id="I_sect16_d1e7831"><title>Working with Logger</title><para>I’m not generally a big fan of logfiles. I much prefer the immediacy
    of seeing problems directly reported on the screen as soon as they happen.
    If possible, I actually want to be thrown directly into my problematic
    code so I can take a look around. However, this isn’t always an option,
    and in certain cases, having an audit trail in the form of logfiles is as
    good as it’s going to get.<indexterm class="startofrange" id="ch06_debuglogger" significance="normal"><primary>debugging</primary><secondary>using logger</secondary></indexterm><indexterm class="startofrange" id="ch06_logger" significance="normal"><primary>logger standard library</primary></indexterm></para><para>Ruby’s standard library <emphasis>logger</emphasis> is fairly
    full-featured, allowing you to log many different kinds of messages and
    filter them based on their severity. The API is reasonably well
    documented, so I won’t be spending a ton of time here going over a
    feature-by-feature summary of what this library offers. Instead, I’ll show
    you how to replicate a bit of functionality that is especially common in
    Ruby’s web frameworks: comprehensive error logging.<indexterm class="startofrange" id="ch06_errorlog" significance="normal"><primary>error logging, comprehensive</primary></indexterm></para><para>If I pull up a log from one of my Rails applications, I can easily
    show what I’m talking about. The following is just a small section of a
    logfile, in which a full request and the error it ran into have been
    recorded:</para><programlisting id="I_programlisting6_d1e7854" format="linespecific">Processing ManagerController#call_in_sheet (for 127.0.0.1 at 2009-02-13 16:38:42) 
  [POST] Session ID: BAh7CCIJdXNlcmkiOg5yZXR1cm5fdG8wIgpmbGFzaElDOidBY3Rpb25Db250
  %0Acm9sbGVyOjpGbGFzaDo6Rmxhc2hIYXNoewAGOgpAdXNlZHsA--2f1d03dee418f4c9751925da42
  1ae4730f9b55dd Parameters: {"period"=&gt;"01/19/2009", "commit"=&gt;"Select", 
  "action"=&gt;"call_in_sheet", "controller"=&gt;"manager"}

<?dbfo-need height="1in"
?>
NameError (undefined local variable or method 'lunch' for 
  #&lt;CallInAggregator:0x2589240&gt;):
    /lib/reports.rb:368:in 'employee_record'
    /lib/reports.rb:306:in 'to_grouping'
    /lib/reports.rb:305:in 'each'
    /lib/reports.rb:305:in 'to_grouping'
    /usr/local/lib/ruby/gems/1.8/gems/ruport-1.4.0/lib/ruport/data/table.rb:169:in 
        'initialize'
    /usr/local/lib/ruby/gems/1.8/gems/ruport-1.4.0/lib/ruport/data/table.rb:809:in 
        'new'
    /usr/local/lib/ruby/gems/1.8/gems/ruport-1.4.0/lib/ruport/data/table.rb:809:in 
        'Table'
    /lib/reports.rb:304:in 'to_grouping'
    /lib/reports.rb:170:in 'CallInAggregator'
    /lib/reports.rb:129:in 'setup'
    /usr/local/lib/ruby/gems/1.8/gems/ruport-1.4.0/lib/ruport/renderer.rb:337:in 
        'render'
    /usr/local/lib/ruby/gems/1.8/gems/ruport-1.4.0/lib/ruport/renderer.rb:379:in 
        'build'
    /usr/local/lib/ruby/gems/1.8/gems/ruport-1.4.0/lib/ruport/renderer.rb:335:in 
        'render'
    /usr/local/lib/ruby/gems/1.8/gems/ruport-1.4.0/lib/ruport/renderer.rb:451:in 
        'method_missing'
    /app/controllers/manager_controller.rb:111:in 'call_in_sheet'
    /app/controllers/application.rb:62:in 'on'
    /app/controllers/manager_controller.rb:110:in 'call_in_sheet'
    /vendor/rails/actionpack/lib/action_controller/base.rb:1104:in 'send'
    /vendor/rails/actionpack/lib/action_controller/base.rb:1104:in 
        'perform_action_wit</programlisting><para>Although the production application would display a rather boring
    “We’re sorry, something went wrong” message upon triggering an error, our
    backend logs tell us exactly what request triggered the error and when it
    occurred. It also gives us information about the actual request, to aid in
    debugging. Though this particular bug is fairly boring, as it looks like
    it was just a typo that snuck through the cracks, logging each error that
    occurs along with its full stack trace provides essentially the same
    information that you’d get if you were running a script locally and ran
    into an error.</para><para>It’s nice that some libraries and frameworks have logging built in,
    but sometimes we’ll need to roll our own. To demonstrate this, we’ll be
    walking through a <literal moreinfo="none" role="keep-together">TCPServer</literal> that does simple arithmetic
    operations in prefix notation. We’ll start by taking a look at it without
    any logging or error-handling support:</para><programlisting id="I_programlisting6_d1e7865" format="linespecific">require "socket"

class Server

  def initialize
    @server   = TCPServer.new('localhost',port=3333)
  end

  def *(x, y)
    "#{Float(x) * Float(y)}"
  end

  def /(x, y)
    "#{Float(x) / Float(y)}"
  end

  def handle_request(session)
    action, *args = session.gets.split(/\s/)
    if ["*", "/"].include?(action)
      session.puts(send(action, *args))
    else
      session.puts("Invalid command")
    end
  end

  def run
    while session = @server.accept
      handle_request(session)
    end
  end
end</programlisting><para>We can use the following fairly generic client to interact with the
    server, which is similar to the one we used in <xref linkend="ch02" xrefstyle="chap-num-title"/>:</para><programlisting id="I_programlisting6_d1e7871" format="linespecific">require "socket"

class Client

  def initialize(ip="localhost",port=3333)
    @ip, @port = ip, port
  end

  def send_message(msg)
    socket = TCPSocket.new(@ip,@port)
    socket.puts(msg)
    response = socket.gets
    socket.close
    return response
  end

  def receive_message
    socket = TCPSocket.new(@ip,@port)
    response = socket.read
    socket.close
    return response
  end

end</programlisting><para>Without any error handling, we end up with something like this on
    the client side:</para><programlisting id="I_programlisting6_d1e7876" format="linespecific">client = Client.new

response = client.send_message("* 5 10")
puts response

response = client.send_message("/ 4 3")
puts response

response = client.send_message("/ 3 foo")
puts response

response = client.send_message("* 5 7.2")
puts response

## OUTPUTS ##

50.0
1.33333333333333
nil
client.rb:8:in 'initialize': Connection refused - connect(2) (Errno::ECONNREFUSED)
        from client.rb:8:in 'new'
        from client.rb:8:in 'send_message'
        from client.rb:35</programlisting><para>When we send the erroneous third message, the server never responds,
    resulting in a <literal moreinfo="none">nil</literal> response. But when we try to send a
    fourth message, which would ordinarily be valid, we see that our
    connection was refused. If we take a look server-side, we see that a
    single uncaught exception caused it to crash immediately:</para><programlisting id="I_programlisting6_d1e7883" format="linespecific">server_logging_initial.rb:15:in 'Float': 
invalid value for Float(): "foo" (ArgumentError)
        from server_logging_initial.rb:15:in '/'
        from server_logging_initial.rb:20:in 'send'
        from server_logging_initial.rb:20:in 'handle_request'
        from server_logging_initial.rb:25:in 'run'
        from server_logging_initial.rb:31</programlisting><para>Though this does give us a sense of what happened, it doesn’t give
    us much insight into when and why. It also seems just a bit fragile to
    have a whole server come crashing down on the account of a single bad
    request. With a little more effort, we can add logging and error handling
    and make things behave much better:</para><programlisting id="I_programlisting6_d1e7887" format="linespecific">require "socket"
require "logger"

class StandardError
  def report
    %{#{self.class}: #{message}\n#{backtrace.join("\n")}}
  end
end

class Server

  def initialize(logger)
    @logger   = logger
    @server   = TCPServer.new('localhost',port=3333)
  end

  def *(x, y)
    "#{Float(x) * Float(y)}"
  end

  def /(x, y)
    "#{Float(x) / Float(y)}"
  end

  def handle_request(session)
    action, *args = session.gets.split(/\s/)
    if ["*", "/"].include?(action)
      @logger.info "executing: '#{action}' with #{args.inspect}"
      session.puts(send(action, *args))
    else
      session.puts("Invalid command")
    end
  rescue StandardError =&gt; e
    @logger.error(e.report)
    session.puts "Sorry, something went wrong."
  end

  def run
    while session = @server.accept
      handle_request(session)
    end
  end
end

begin
  logger = Logger.new("development.log")
  host   = Server.new(logger)

  host.run
rescue StandardError =&gt; e
  logger.fatal(e.report)
  puts "Something seriously bad just happened, exiting"
end</programlisting><para>We’ll go over the details in just a minute, but first, let’s take a
    look at the output on the client side running the identical code from
    earlier:</para><programlisting id="I_programlisting6_d1e7891" format="linespecific">client = Client.new

response = client.send_message("* 5 10")
puts response

response = client.send_message("/ 4 3")
puts response

response = client.send_message("/ 3 foo")
puts response

response = client.send_message("* 5 7.2")
puts response

## OUTPUTS ##

50.0
1.33333333333333
Sorry, something went wrong.
36.0</programlisting><para>We see that the third message is caught as an error and an apology
    is promptly sent to the client. But the interesting bit is that the fourth
    example continues to run normally, indicating that the server did not
    crash this time around.</para><para>Of course, if we swallowed all errors and just returned “We’re
    sorry” every time something happened without creating a proper paper trail
    for debugging, that’d be a terrible idea. Upon inspecting the server logs,
    we can see that we haven’t forgotten to keep ourselves covered:</para><programlisting id="I_programlisting6_d1e7897" format="linespecific"># Logfile created on Sat Feb 21 07:07:49 -0500 2009 by /
I, [2009-02-21T07:08:54.335294 #39662]  INFO -- : executing: '*' with ["5", "10"]
I, [2009-02-21T07:08:54.335797 #39662]  INFO -- : executing: '/' with ["4", "3"]
I, [2009-02-21T07:08:54.336163 #39662]  INFO -- : executing: '/' with ["3", "foo"]
E, [2009-02-21T07:08:54.336243 #39662] ERROR -- : 
ArgumentError: invalid value for Float(): "foo"
server_logging.rb:22:in 'Float'
server_logging.rb:22:in '/'
server_logging.rb:28:in 'send'
server_logging.rb:28:in 'handle_request'
server_logging.rb:36:in 'run'
server_logging.rb:45
I, [2009-02-21T07:08:54.336573 #39662]  INFO -- : executing: '*' with ["5", "7.2"]</programlisting><para>Here we see two different levels of logging going on,
    <literal moreinfo="none">INFO</literal> and <literal moreinfo="none">ERROR</literal>. The purpose of our
    <literal moreinfo="none">INFO</literal> logs is simply to document requests as parsed by
    our server. This is to ensure that the messages and their parameters are
    being processed as we expect. Our <literal role="keep-together" moreinfo="none">ERROR</literal> logs document the actual errors we
    run into while processing things, and you can see in this example that the
    stack trace written to the logfile is nearly identical to the one that was
    produced when our more fragile version of the server crashed.<indexterm id="I_indexterm6_d1e7913" significance="normal"><primary>ERROR logging level</primary></indexterm><indexterm id="I_indexterm6_d1e7916" significance="normal"><primary>INFO logging level</primary></indexterm><indexterm id="I_indexterm6_d1e7920" significance="normal"><primary>logging</primary><secondary>INFO and ERROR levels</secondary></indexterm></para><para>Although the format is a little different, like the Rails logs, this
    provides us with everything we need for debugging. A time and date of the
    issue, a record of the actual request, and a trace that shows where the
    error originated. Now that we’ve seen it in action, let’s take a look at
    how it all comes together.</para><para>We’ll start with the small extension to <literal moreinfo="none">StandardError</literal>:<indexterm id="I_indexterm6_d1e7933" significance="normal"><primary>StandardError class</primary></indexterm></para><programlisting id="I_programlisting6_d1e7936" format="linespecific">class StandardError
  def report
    %{#{self.class}: #{message}\n#{backtrace.join("\n")}}
  end
end</programlisting><para>This convenience method allows us to produce error reports that look
    similar to the ones you’ll find on the command line when an exception is
    raised. Although <literal moreinfo="none" role="keep-together">StandardError</literal> objects provide all the same
    information, they do not have a single public method that provides the
    same report data that Ruby does, so we need to assemble it on our
    own.</para><para>We can see how this error report is used in the main <literal moreinfo="none">handle_request</literal> method. Notice that the server is
    passed a <literal moreinfo="none">Logger</literal> instance, which is used
    as <literal moreinfo="none">@logger</literal> in the following
    code:</para><programlisting id="I_programlisting6_d1e7954" format="linespecific">def handle_request(session)
  action, *args = session.gets.split(/\s/)
  if ["*", "/"].include?(action)
    @logger.info "executing: '#{action}' with #{args.inspect}"
    session.puts(send(action, *args))
  else
    session.puts("Invalid command")
  end
rescue StandardError =&gt; e
  @logger.error(e.report)
  session.puts "Sorry, something went wrong."
end</programlisting><para>Here, we see where the messages in our logfile actually came from.
    Before the server attempts to actually execute a command, it records what
    it has parsed out using <literal moreinfo="none">@logger.info</literal>.
    Then, it attempts to send the message along with its parameters to the
    object itself, printing its return value to the client end of the socket.
    If this fails for any reason, the relevant error is captured into <literal moreinfo="none">e</literal> through <literal moreinfo="none">rescue</literal>. This will catch all descendants of
    <literal moreinfo="none">StandardError</literal>, which includes virtually
    all exceptions Ruby can throw. Once it is captured, we utilize the custom
    <literal moreinfo="none">StandardError#report</literal> extension to
    generate an error report string, which is then logged as an error in the
    logfile. The apology is sent along to the client, thus completing the
    cycle.<indexterm id="I_indexterm6_d1e7974" significance="normal"><primary>StandardError#report method</primary></indexterm></para><para>That covers what we’ve seen in the logfile so far, but there is an
    additional measure for error handling in this application. We see this in
    the code that actually gets everything up and running:</para><?dbfo-need height=”1in”
?><programlisting id="I_programlisting6_d1e7980" format="linespecific">begin
  logger = Logger.new("development.log")
  host   = Server.new(logger)

  host.run
rescue StandardError =&gt; e
  logger.fatal(e.report)
  puts "Something seriously bad just happened, exiting"
end</programlisting><para>Although our response-handling code is pretty well insulated from
    errors, we still want to track in our logfile any server crashes that may
    happen. Rather than using <literal moreinfo="none">ERROR</literal> as our designation, we
    instead use <literal moreinfo="none">FATAL</literal>, indicating that our server has no
    intention of recovering from errors that bubble up to this level. I’ll
    leave it up to you to figure out how to crash the server once it is
    running, but this technique also allows us to log things such as
    misspelled variable and method names among other issues within the
    <literal moreinfo="none">Server</literal> class. To illustrate this,
    replace the <literal moreinfo="none">run</literal> method with the
    following code:<indexterm id="I_indexterm6_d1e7996" significance="normal"><primary>FATAL logging level</primary></indexterm></para><programlisting id="I_programlisting6_d1e8000" format="linespecific">def run
  while session = @server.accept
    handle_request(sessions)
  end
end</programlisting><para>You’ll end up crashing the server and producing the following log
    message:</para><programlisting id="I_programlisting6_d1e8004" format="linespecific">F, [2009-02-21T07:39:40.592569 #39789] FATAL -- : NameError: undefined local
variable or method 'sessions' for #&lt;Server:0x20c970&gt;
server_logging.rb:36:in 'run'
server_logging.rb:45</programlisting><para>This can be helpful if you’re deploying code remotely and have some
    code that runs locally but not on the remote host, among other
    things.</para><para>Although we have not covered <literal moreinfo="none">Logger</literal> in depth by any means, we’ve walked
    through an example that can be used as a template for more general needs.
    Most of the time, logging makes the most sense when you don’t have easy,
    immediate access to the running code, and can be overkill in other places.
    If you’re considering adding logging code to your applications, there are
    a few things to keep in mind:<indexterm id="I_indexterm6_d1e8013" significance="normal"><primary>logging</primary><secondary>guidelines for</secondary></indexterm></para><itemizedlist><listitem><para>Error logging is essential for long-running server processes,
        during which you may not physically be watching the application moment
        by moment.</para></listitem><listitem><para>If you are working in a multiprocessing environment, be sure to
        use a separate logfile for each process, as otherwise there will be
        clashes.</para></listitem><listitem><para><literal moreinfo="none">Logger</literal> is powerful and
        includes a ton of features not covered here, including built-in
        logfile rotation.</para></listitem><listitem><para>See the template for <literal moreinfo="none">StandardError#report</literal> if you want to include
        error reports in your logs that look similar to the ones that Ruby
        generates on the command line.</para></listitem><listitem><para>When it comes to logging error messages,
        <literal moreinfo="none">FATAL</literal> should represent a bug from which your code
        has no intention of recovering; <literal moreinfo="none">ERROR</literal> is more
        open-ended.</para></listitem></itemizedlist><para>Depending on the kind of work you do, you may end up using <literal moreinfo="none">Logger</literal> every day or not at all. If it’s the
    former case, be sure to check out the API documentation for many of the
    features not covered here.</para><para>And with that, we’ve reached the end of another chapter. I’ll just
    wrap up with some closing remarks, and then we can move on to more upbeat
    topics.<indexterm id="I_indexterm6_d1e8052" class="endofrange" startref="ch06_errorlog" significance="normal"/><indexterm id="I_indexterm6_d1e8053" class="endofrange" startref="ch06_debuglogger" significance="normal"/><indexterm id="I_indexterm6_d1e8054" class="endofrange" startref="ch06_logger" significance="normal"/></para></sect1><sect1 id="I_sect16_d1e8055"><title>Conclusions</title><para>Dealing with defective code is something we all need to do from time
    to time. If we approach these issues in a relatively disciplined way, we
    can methodically corner and squash pretty much any bug that can be
    imagined. Debugging Ruby code tends to be a fluid process, starting with a
    good specification of how things should actually work, and then exercising
    various investigative tactics until a fix can be found. We don’t
    necessarily need a debugger to track down issues in our code, but we do
    need to use Ruby’s introspective features as much as possible, as they
    have the power to reveal to us exactly what is going on under the
    hood.</para><para>Once you get into a comfortable workflow for resolving issues in
    your Ruby code, it becomes more and more straightforward. If you find
    yourself lost while hunting down some bug, take the time to slow down and
    utilize the strategies we’ve gone over in this chapter. Once you get the
    hang of them, the tighter feedback loop will kick in and make your job
    much easier.<indexterm id="I_indexterm6_d1e8062" class="endofrange" startref="ch06_debugging" significance="normal"/></para></sect1></chapter><chapter id="I_chapter7_d1e8063"><title>Reducing Cultural Barriers</title><para>Ten years ago, a book on best practices for any given programming
  language would seem perfectly complete without a chapter on
  multilingualization (m17n) and localization (L10n). In 2009, the story is
  just a little bit different.<indexterm id="I_indexterm7_d1e8068" significance="normal"><primary>L10n (localization)</primary></indexterm><indexterm id="I_indexterm7_d1e8071" significance="normal"><primary>m17n (multilingualization)</primary></indexterm></para><para>Now that we’ve created a network of applications and infrastructure
  designed not simply to be used by hackers and researchers, but by
  nontechnical folks as part of their day-to-day lives, we are living in a
  very different world. With most software serving first and foremost as a
  communication medium, it is unrealistic to think that all <phrase role="keep-together">conversations</phrase> should be conducted in English
  or require the use of specialized tools <phrase role="keep-together">otherwise</phrase>. This presents a challenge to those
  who implement software that needs to be accessible to a global user
  base.<indexterm id="I_indexterm7_d1e8082" significance="normal"><primary>localization</primary><see>L10n</see></indexterm><indexterm id="I_indexterm7_d1e8087" significance="normal"><primary>multilingualization</primary><see>m17n</see></indexterm></para><para>Although some may argue that it took too long to materialize, Ruby 1.9
  provides a robust and elegant solution to the m17n problem. Rather than
  binding its users to a particular internal encoding and requiring complex
  manual manipulation of text into that format, Ruby 1.9 provides facilities
  that make it easy to transcode text from one encoding to another. This
  system is well integrated so that things like pattern matching and I/O
  operations can be carried out in all of the encodings Ruby supports, which
  provides a great deal of flexibility for those who need to do
  encoding-specific operations. Of course, because painless transcoding is
  possible, you can also write code that accepts and produces text in a wide
  variety of encodings, but uses a single encoding throughout its internals,
  improving the consistency and simplicity of the underlying
  implementation.</para><para>In this chapter, we’re going to look at both of these approaches in
  some detail. We’ll also look at some of the shortcuts Ruby offers when it
  comes to day-to-day scripting needs. In these cases, you may not need
  full-fledged support for arbitrarily encoded text, so there are ways to skip
  some steps if you know exactly what you’ll be dealing with. By the time we
  wrap up with our discussion of m17n, you’ll have a few solid strategies that
  can be adapted to fit your needs.</para><para>Once you are comfortable with how to store, manipulate, and produce
  internationalized text in various character encodings, you may want to know
  about how to customize your software so that its interface is adapted to
  whatever the native language and dialogue of its users might be. Although
  multilingualization and localization requirements don’t necessarily come in
  pairs, they often do, so I’ll wrap up this chapter with a brief
  demonstration of how to localize a simple Ruby application without excess
  duplication of effort.</para><para>Though we’ll be talking about both topics, it’s fair to say that
  technologically speaking, L10n is pretty easy, and m17n is fairly involved.
  This chapter won’t necessarily teach you about either, but you should
  certainly review the basics of character encodings and have a working
  understanding of Ruby’s m17n system before moving on. If you don’t, go ahead
  and look over your favorite Ruby reference book before moving on, and maybe
  check out Joel Spolsky’s <ulink url="http://www.joelonsoftware.com/articles/Unicode.html">classic
  article</ulink> on Unicode and character sets, which is the best I’ve seen
  as an <phrase role="keep-together">introduction</phrase>.<indexterm id="I_indexterm7_d1e8106" significance="normal"><primary>character sets</primary></indexterm><indexterm id="I_indexterm7_d1e8109" significance="normal"><primary>Unicode</primary></indexterm></para><para>Once you’re up to speed, we can move on to a practical example of m17n
  as seen in one of Ruby’s standard libraries.</para><para>As always, we’ll start with the deep dive and then go over some of the
  specifics later in the chapter. However, in this chapter in particular, I’m
  hoping that you don’t skip the initial real-world example. Even if you don’t
  fully grasp what’s going on, the concepts it introduces are essential for
  understanding the rest of the content in this chapter. It also happens to be
  some of the coolest code in the book, so let’s jump right in so you can see
  how it works.</para><sect1 id="I_sect17_d1e8116"><title>m17n by Example: A Look at Ruby’s CSV Standard Library</title><para>In a few other places in the book, I mentioned that Ruby’s standard
    library is a good place to look for quality code that best practices can
    be gleaned from. When it comes to m17n, the place to look is the CSV
    library. This library is used for reading and writing files in the popular
    comma-separated-value tabular data format. We won’t be talking much about
    the details of how this library is actually used here, but will instead be
    investigating a particular aspect of how it is implemented.<indexterm class="startofrange" id="ch07_CSVm17n" significance="normal"><primary>csv standard library</primary><secondary>m17n (multilingualization) by example</secondary></indexterm><indexterm class="startofrange" id="ch07_m17nCSV" significance="normal"><primary>m17n (multilingualization)</primary><secondary>examples in CSV standard library</secondary></indexterm></para><para>What we’re interested in is how CSV manages to parse data that is in
    any of the character encodings that Ruby supports without transcoding the
    source text. To clarify the challenge, we can notice that generally
    speaking, character encodings are not necessarily compatible with one
    another:<indexterm id="I_indexterm7_d1e8133" significance="normal"><primary>character encodings</primary><secondary>parsing in CSV library</secondary></indexterm><footnote><para>Throughout this chapter, note that <literal moreinfo="none">一</literal> is the
        Japanese character for 1, not a double dash.</para></footnote></para><programlisting id="I_programlisting7_d1e8144" format="linespecific"># coding: UTF-8

utf8_string = "foo 一 bar"
sjis_string = utf8_string.encode("Shift_JIS")

p utf8_string == sjis_string #=&gt; false</programlisting><para>This issue is propagated well beyond <literal moreinfo="none">String</literal> equality, and can cause more noisy
    problems in things like pattern matching or string manipulation:<indexterm id="I_indexterm7_d1e8151" significance="normal"><primary>character encodings</primary><secondary>UTF-8</secondary></indexterm><indexterm id="I_indexterm7_d1e8156" significance="normal"><primary>UTF-8 character encoding</primary></indexterm></para><programlisting id="I_programlisting7_d1e8159" format="linespecific">sjis_string =~ /(\w+)\s一\s(\w+)/
encoding_test.rb:6:in '&lt;main&gt;': incompatible encoding regexp match 
(UTF-8 regexp with Shift_JIS string) (Encoding::CompatibilityError)

utf8_string &lt;&lt; sjis_string # RAISES
encoding_test.rb:6:in '&lt;main&gt;': incompatible character encodings: 
UTF-8 and Shift_JIS (Encoding::CompatibilityError)</programlisting><para>So the fact remains that some transcoding needs to be done. But
    imagine that in this example <literal moreinfo="none">sjis_string</literal> represents some preloaded data that
    has not been converted yet. If our source encoding is set to use UTF-8, we
    could of course transcode the <literal moreinfo="none">sjis_string</literal> to UTF-8 before operating on it.
    However, this could potentially be costly if our source text was large. To
    work around this, CSV converts its parsing patterns instead. We’ll look at
    that in much greater detail in just a moment, but just to get a feel for
    it, let’s look at an oversimplified example of how that might
    work:<indexterm id="I_indexterm7_d1e8169" significance="normal"><primary>sjis_re function</primary></indexterm></para><programlisting id="I_programlisting7_d1e8172" format="linespecific">def sjis_re(str)
  Regexp.new(str.encode("Shift_JIS"))
end

sjis_string =~ sjis_re("(\w+)\s一\s(\w+)")
p [$1, $2] #=&gt; ["foo", "bar"]</programlisting><para>Here, we use a UTF-8 string literal to build up a regular
    expression, but before it is constructed, the string is transcoded to
    Shift-JIS. As a result, the pattern it creates is capable of matching
    against Shift-JIS strings.<indexterm id="I_indexterm7_d1e8176" significance="normal"><primary>regular expressions</primary><secondary>defining to match text in encoding different from
        source</secondary></indexterm></para><para>Although a bit more work than using <literal moreinfo="none">Regexp</literal> literals, this presents a fairly natural
    way of defining regular expressions to match text that is in a different
    encoding from the source encoding. If we build on this concept a little
    bit, you can get a sense of how CSV’s parser works.</para><para>Let’s look at the CSV implementation from the bottom up. The end
    goal is to generate a parser in the encoding of the original data source
    that can extract cells from a tabular data format. To do this, CSV needs
    to be able to transcode some special characters into the encoding of the
    source text. These include the column separator, row separator, and
    literal quote character. As these can all be customized when a CSV is
    loaded, some general helpers for encoding strings and regular expressions
    come in handy:</para><programlisting id="I_programlisting7_d1e8189" format="linespecific"># Builds a regular expression in &lt;tt&gt;@encoding&lt;/tt&gt;.  All +chunks+ will be
# transcoded to that encoding.
#
def encode_re(*chunks)
  Regexp.new(encode_str(*chunks))
end

# Builds a String in &lt;tt&gt;@encoding&lt;/tt&gt;.  All +chunks+ will be transcoded to
# that encoding.
#
def encode_str(*chunks)
  chunks.map { |chunk| chunk.encode(@encoding.name) }.join
end</programlisting><para>In this code, <literal moreinfo="none">@encoding</literal> refers to
    the <literal moreinfo="none">Encoding</literal> object pulled from the
    underlying CSV string. For example, you might be trying to load a CSV file
    encoded in Shift-JIS:<indexterm id="I_indexterm7_d1e8199" significance="normal"><primary>Encoding objects</primary></indexterm></para><programlisting id="I_programlisting7_d1e8202" format="linespecific"># coding: UTF-8

require "csv"

CSV.read("data.csv", encoding: "Shift_JIS")</programlisting><para>In essence, these two helper methods provide the same functionality
    as our <literal moreinfo="none">sjis_re</literal> function that we built
    earlier. The main difference is that here, we have gleaned the necessary
    information from an <literal moreinfo="none">Encoding</literal> object
    stored in the CSV instance rather than hardcoded a particular encoding to
    use. This makes perfect sense in the context of CSV, and hopefully is
    relatively easy to understand.<indexterm id="I_indexterm7_d1e8212" significance="normal"><primary>sjis_re function</primary></indexterm></para><para>In addition to encoding regular expressions, because CSV accepts
    user-entered values that modify its core parser, it needs to escape them.
    Although the built-in <literal moreinfo="none">Regexp.escape()</literal>
    method works with most of the encodings Ruby supports, at the time of the
    Ruby 1.9.1 release, it had some issues with a handful of them. To work
    around this, CSV rolls its own escape method:<indexterm id="I_indexterm7_d1e8220" significance="normal"><primary>regular expressions</primary><secondary>escaping special characters</secondary></indexterm><indexterm id="I_indexterm7_d1e8225" significance="normal"><primary>escaping special characters in regular expressions</primary></indexterm><indexterm id="I_indexterm7_d1e8228" significance="normal"><primary>Regexp.escape( ) method</primary></indexterm></para><programlisting id="I_programlisting7_d1e8231" format="linespecific"># This method is an encoding safe version of Regexp.escape().  It will escape
# any characters that would change the meaning of a regular expression in the
# encoding of +str+.  Regular expression characters that cannot be transcoded
# to the target encoding will be skipped and no escaping will be performed if
# a backslash cannot be transcoded.
#
def escape_re(str)
  str.chars.map { |c| @re_chars.include?(c) ? @re_esc + c : c }.join
end</programlisting><para>This means that once things like the column separator, row
    separator, and quote character have been specified by the user and
    converted into the specified encoding, this code can check to see whether
    the transcoded characters need to be escaped. To make things clearer, we
    can see that <literal moreinfo="none">@re_chars</literal> is set in the
    <literal moreinfo="none">CSV</literal> constructor as simply a list of
    regular expression reserved characters transcoded to the specified
    <literal moreinfo="none">@encoding</literal>:</para><programlisting id="I_programlisting7_d1e8244" format="linespecific">@re_chars =   %w[ \\ .  [  ]  -  ^  $  ?
                  *  +  {  }  (  )  |  #
                  \  \r \n \t \f \v ].
              map { |s| s.encode(@encoding) rescue nil }.compact</programlisting><para>When we put these helpers together, we can see the big picture
    materialize within CSV’s core parsers. Although the next code sample may
    look long at first, if you read through it, you’ll see it’s basically just
    a handful of regular expressions each doing a particular part of the CSV
    parsing job:</para><programlisting id="I_programlisting7_d1e8248" format="linespecific"># Pre-compiles parsers and stores them by name for access during reads.
def init_parsers(options)
  # store the parser behaviors
  @skip_blanks      = options.delete(:skip_blanks)
  @field_size_limit = options.delete(:field_size_limit)

  # prebuild Regexps for faster parsing
  esc_col_sep = escape_re(@col_sep)
  esc_row_sep = escape_re(@row_sep)
  esc_quote   = escape_re(@quote_char)
  @parsers = {
    # for empty leading fields
    leading_fields: encode_re("\\A(?:", esc_col_sep, ")+"),
    # The Primary Parser
    csv_row:        encode_re(
      "\\G(?:\\A|", esc_col_sep, ")",                # anchor the match
      "(?:", esc_quote,                              # find quoted fields
             "((?&gt;[^", esc_quote, "]*)",             # "unrolling the loop"
             "(?&gt;", esc_quote * 2,                   # double for escaping
             "[^", esc_quote, "]*)*)",
             esc_quote,
             "|",                                    # ... or ...
             "([^", esc_quote, esc_col_sep, "]*))",  # unquoted fields
      "(?=", esc_col_sep, "|\\z)"                    # ensure field is ended
    ),
    # a test for unescaped quotes
    bad_field:      encode_re(
      "\\A", esc_col_sep, "?",                   # an optional comma
      "(?:", esc_quote,                          # a quoted field
             "(?&gt;[^", esc_quote, "]*)",          # "unrolling the loop"
             "(?&gt;", esc_quote * 2,               # double for escaping
             "[^", esc_quote, "]*)*",
             esc_quote,                          # the closing quote
             "[^", esc_quote, "]",               # an extra character
             "|",                                # ... or ...
             "[^", esc_quote, esc_col_sep, "]+", # an unquoted field
             esc_quote, ")"                      # an extra quote
    ),
    # safer than chomp!()
    line_end:       encode_re(esc_row_sep, "\\z"),
    # illegal unquoted characters
    return_newline: encode_str("\r\n")
  }
end</programlisting><para>By default, the <literal moreinfo="none">@col_sep</literal> will be
    a comma, and the <literal moreinfo="none">@quote_char</literal> will be a
    double-quote. The default <literal moreinfo="none">@row_sep</literal> can
    vary depending on what sort of line endings are used in the file. These
    options can also be overridden when data is loaded. For example, if you
    for some reason had data columns separated by the Japanese character for
    2, you could split things up that way:</para><programlisting id="I_programlisting7_d1e8262" format="linespecific"># coding: UTF-8

require "csv"

CSV.read("data.csv", encoding: "Shift_JIS", col_sep: "二")</programlisting><para>All of these options get automatically transcoded to the specified
    <literal moreinfo="none">encoding</literal>, which means you don’t need to
    do the UTF-8 → Shift-JIS conversion manually here. This, combined with
    some of the other conveniences we’ve gone over, makes it clear that
    despite the fact that CSV manages to support every encoding Ruby does, it
    minimizes the amount an end user needs to know about the underlying grunt
    work. As long as the proper encoding is specified, CSV handles all the
    rest, and can even do things like auto-transcoding on load if you ask it
    to.</para><para>When it boils down to it, there isn’t a whole lot of complexity
    here. By working with strings and regular expressions indirectly through
    encoding helpers, we can be sure that any pattern matching or text
    manipulation gets done in a compatible way. By translating the parser
    rather than the source data, we incur a fixed cost rather than one that
    varies in relation to the size of the data source. For a need like CSV
    processing, this is very important, as the format is often used for large
    data dumps.</para><para>The downside of this approach is of course that you need to be extra
    careful about how you work with your source text. It is not a big deal
    here because CSV processing is a well-specified task that has limited
    feature requirements. Constantly having to remember to encode every string
    and regular expression you use in your project could quickly become
    overwhelming if you are working on a more multifaceted problem.</para><para>In the next section, we’ll cover an alternative m17n solution that
    isn’t quite as pure as the approach CSV takes, but is generally less work
    to implement and still works fairly well for most needs.<indexterm id="I_indexterm7_d1e8275" class="endofrange" startref="ch07_CSVm17n" significance="normal"/><indexterm id="I_indexterm7_d1e8276" class="endofrange" startref="ch07_m17nCSV" significance="normal"/></para></sect1><sect1 id="I_sect17_d1e8277"><title>Portable m17n Through UTF-8 Transcoding</title><para>Although it’s nice to be able to support each character encoding
    natively, it can be quite difficult to maintain a complex system that
    works that way. The easy way out is to standardize on a single, fairly
    universal character encoding to write your code against. Then, all that
    remains to be done is to transcode any string that comes in, and possibly
    transcode again on the way out. The character set of choice for use in
    code that needs to be portable from one system to another is
    UTF-8.<indexterm class="startofrange" id="ch07_UTF8library" significance="normal"><primary>UTF-8 character encoding</primary><secondary>writing UTF-8-enabled Ruby library</secondary></indexterm><indexterm class="startofrange" id="ch07_m17nportable" significance="normal"><primary>m17n (multilingualization)</primary><secondary>portable m17n through UTF-8 transcoding</secondary></indexterm></para><para>Many Ruby libraries consume UTF-8 and UTF-8 only. The choice is a
    reasonable one, as UTF-8 is a proper superset of ASCII, meaning that code
    that pays no attention to specialized character encodings is likely to
    work without modification. UTF-8 also is capable of representing the
    myriad character sets that make up Unicode, which means it can represent
    nearly any glyph you might imagine in any other character encoding. As a
    variable-length character encoding, it does this fairly efficiently, so
    that users who do not need extra bytes to represent large character sets
    do not incur a significant memory penalty.</para><para>We’re now going to walk through the general process of writing a
    UTF-8-enabled Ruby library. Along the way, we’ll occasionally look at some
    examples from Prawn, to give a sense of what these techniques look like
    when they’re applied in an actual project.</para><sect2><title>Source Encodings</title><para>A key aspect of any m17n-capable Ruby projects is to properly set
      the source encodings of its files. This is done via the magic comments
      that we have already seen in some of the earlier examples in this
      chapter. When it comes to Prawn, you’ll see that each and every source
      file that makes up the library starts with a line like this:<indexterm id="I_indexterm7_d1e8301" significance="normal"><primary>m17n (multilingualization)</primary><secondary>portable m17n through UTF-8 transcoding</secondary><tertiary>source encodings</tertiary></indexterm><indexterm id="I_indexterm7_d1e8308" significance="normal"><primary>source encodings, setting</primary></indexterm><indexterm id="I_indexterm7_d1e8311" significance="normal"><primary>character encodings</primary><secondary>setting source encodings</secondary></indexterm></para><programlisting id="I_programlisting7_d1e8316" format="linespecific"># coding: UTF-8</programlisting><para>In order for Ruby to pick it up, this comment must be the first
      line in the file, unless a shebang is present, such as in the following
      example:</para><programlisting id="I_programlisting7_d1e8320" format="linespecific">#!/usr/bin/env ruby
# coding: UTF-8</programlisting><para>In this case, the magic comment can appear on the second line.
      However, in all other situations, nothing else should come before it.
      Although Ruby is very strict about where you place the comment, it’s
      fairly loose about the way you write it. Case does not matter as long as
      it’s in the form of <literal moreinfo="none">coding:
      some_encoding</literal>, and extra text may appear before or after it.
      This is used primarily for editor support, allowing things such as
      Emacs-style strings:</para><programlisting id="I_programlisting7_d1e8327" format="linespecific"># -*- coding: utf-8 -*-</programlisting><para>However you choose to format your magic comments, actually
      including them is important. Their purpose is to tell Ruby what encoding
      your regex and string literals are in. Forgetting to explicitly set the
      source encoding in this manner can cause all sorts of nasty problems, as
      it will force Ruby to fall back to US-ASCII, breaking virtually all
      internationalized text.<indexterm id="I_indexterm7_d1e8331" significance="normal"><primary>string literals, specifying character encoding
          for</primary></indexterm><indexterm id="I_indexterm7_d1e8334" significance="normal"><primary>regular expressions</primary><secondary>specifying character encoding for</secondary></indexterm></para><para>Once you set the source encoding to UTF-8 in all your files, if
      your editor is producing UTF-8 output, you can be sure of the encoding
      of your literals. That’s the first step.</para></sect2><sect2><title>Working with Files</title><para>By default, Ruby uses your locale settings to determine the
      default external character encoding for files. You can check what yours
      is set to by running this code:<indexterm id="I_indexterm7_d1e8346" significance="normal"><primary>m17n (multilingualization)</primary><secondary>portable m17n through UTF-8 transcoding</secondary><tertiary>working with files</tertiary></indexterm><indexterm id="I_indexterm7_d1e8353" significance="normal"><primary>external character encoding for files</primary></indexterm><indexterm id="I_indexterm7_d1e8356" significance="normal"><primary>files, character encodings</primary></indexterm></para><programlisting id="I_programlisting7_d1e8359" format="linespecific">$ ruby -e "p Encoding.default_external"</programlisting><para>On my system, this prints out <literal moreinfo="none">#&lt;Encoding:UTF-8&gt;</literal>, but yours might be
      different. If your locale information isn’t set, Ruby assumes that there
      is no suitable default encoding, reverting to <literal moreinfo="none">ASCII-8BIT</literal> to interpret external files as
      sequences of untranslated bytes.<indexterm id="I_indexterm7_d1e8369" significance="normal"><primary>default_external encoding</primary></indexterm></para><para>The actual value your <literal moreinfo="none">default_external</literal> is set to doesn’t really
      matter when you’re developing code that needs to run on systems that you
      do not control. Because most libraries fall under this category, it
      means that you simply cannot rely on <literal moreinfo="none">File.open()</literal> or <literal moreinfo="none">File.read()</literal> to work without explicitly
      specifying an encoding.<indexterm id="I_indexterm7_d1e8383" significance="normal"><primary>File.open( ) and File.read( ), character encodings
          and</primary></indexterm></para><para>This means that if you want to open a file that is in Latin-1
      (ISO-8859-1), but process it within your UTF-8-based library, you need
      to write code something like this:<indexterm id="I_indexterm7_d1e8388" significance="normal"><primary>Latin-1 (ISO-8859-1) encoding</primary></indexterm></para><programlisting id="I_programlisting7_d1e8391" format="linespecific">data = File.read("foo.txt", encoding:"ISO-8859-1:UTF-8")</programlisting><para>Here, we’ve indicated that the file we are reading is encoded in
      ISO-8859-1, but that we want to transcode it to UTF-8 immediately so
      that the string we end up with in our program is already converted for
      us. Unless you need to retain the original encoding of the text for some
      reason, this is generally a good idea when processing files within a
      UTF-8 based library.</para><para>Writing back to file works in a similar fashion. Here’s what it
      looks like to automatically transcode text back to Latin-1 from a UTF-8
      source string:</para><programlisting id="I_programlisting7_d1e8397" format="linespecific">File.open("foo.txt", "w:ISO-8859-1:UTF-8") { |f| f &lt;&lt; data + "Some extra text" }</programlisting><para>Although the syntax is slightly different here, the idea is the
      same. We specify first the external character encoding that is used for
      the file and second the internal encoding we are working with. So with
      this in mind, in a UTF-8-based library, you will need to supply an
      encoding string of the form <literal moreinfo="none">external_format:UTF-8</literal> whenever you’re working
      with text files. Of course, if the external format happens to be UTF-8,
      you would just write something like this:</para><programlisting id="I_programlisting7_d1e8405" format="linespecific">data = File.read("foo.txt", encoding: "UTF-8")
File.open("foo.txt", "w:UTF-8") { |f| f &lt;&lt; data + "Some extra text"</programlisting><para>The underlying point here is that if you want to work with files
      in a portable way, you need to be explicit about their character
      encodings. Without doing this, you cannot be sure that your code will
      work consistently from machine to machine. Also, if you want to make it
      so all of the internals of your system operate in a single encoding, you
      need to explicitly make sure the loaded files get translated to UTF-8
      before you process the text in them. If you take care of these two
      things, you can mostly forget about the details, as all of the actual
      work will end up getting done on UTF-8 strings.</para><para>There is one notable exception to this rule, which is dealing with
      binary files. It used to be the case that at least on *nix, you could
      get away with code like this on Ruby 1.8:<indexterm id="I_indexterm7_d1e8411" significance="normal"><primary>binary files, character encodings and</primary></indexterm></para><programlisting id="I_programlisting7_d1e8414" format="linespecific">img_data = File.read("foo.png")</programlisting><para>Reading binary files this way was never a good idea, because it
      would cause data corruptions on Windows due to the fact that it does
      automatic conversions to the line endings of the files. However, there
      is now a reason not to write code like this, regardless of what platform
      you are on.</para><para>As we had mentioned before, Ruby looks to your <literal moreinfo="none">default_external</literal> encoding when one is not
      explicitly specified. Because this is set by your locale, it can be any
      number of things. On my system, as my locale is set to UTF-8, Ruby
      thinks I’m trying to load a UTF-8 based file and interprets my binary as
      such. This promptly breaks things in all sorts of unpleasant ways, so it
      is something to be avoided. Luckily, if we simply use <literal moreinfo="none">File.binread()</literal>, all these problems go
      away:<indexterm id="I_indexterm7_d1e8426" significance="normal"><primary>File.binread( ) method</primary></indexterm></para><programlisting id="I_programlisting7_d1e8429" format="linespecific">img_data = File.binread("foo.png")
img_data.encoding #=&gt; #&lt;Encoding:ASCII-8BIT&gt;</programlisting><para>For more complex needs, or for when you need to write a binary
      file, Ruby 1.9 has also changed the meaning of <literal moreinfo="none">"rb"</literal> and <literal moreinfo="none">"wb"</literal> in <literal moreinfo="none">File.open()</literal>. Rather than simply disabling
      line-ending conversion, using these file modes will now set the external
      encoding to <literal moreinfo="none">ASCII-8BIT</literal> by default.
      You can see this being used in Prawn’s <literal moreinfo="none">Document#render_file</literal> method, which simply
      takes the raw PDF string written by <literal moreinfo="none">Document#render</literal> and outputs a binary
      file:<indexterm id="I_indexterm7_d1e8452" significance="normal"><primary>Prawn::Document#render_file method</primary></indexterm></para><programlisting id="I_programlisting7_d1e8455" format="linespecific">class Prawn::Document

  # ...

  def render_file(filename)
    File.open(filename,"wb") { |f| f &lt;&lt; render }
  end

end</programlisting><para>This approach may already seem familiar to those who have needed
      to deploy code that runs on Windows machines. However, this section is
      meant to remind folks who may not have previously needed to worry about
      this that they need to be careful as well.</para><para>There really isn’t a whole lot to worry about when working with
      files using this m17n strategy, but the few things that you do need to
      do are important to remember. Unless you’re working with binaries, be
      sure to explicitly specify the external encoding of your files, and
      transcode them to UTF-8 upon read or write. If you are working with
      binaries, be sure to use <literal moreinfo="none">File.binread()</literal> or <literal moreinfo="none">File.open()</literal> with the proper flags to make sure
      that your text is not accidentally encoded into the character set
      specified by your locale. This one can produce subtle bugs that you
      might not encounter until you run your code on another machine, so it’s
      important to try to avoid in the first place.</para><para>Now that we’ve talked about source encodings and files, the main
      thing that’s left to discuss is how to transcode input from users in a
      fairly organized way, and produce output in the formats you need. Though
      this is not complicated, it’s worth looking at some real code to see how
      this is handled.</para></sect2><sect2><title>Transcoding User Input in an Organized Fashion</title><para>When dealing with user input, you need to make a decision
      regarding what should be transcoded and where. In the case of Prawn, we
      take a very minimalist approach to this. While we expect the end user to
      provide us with UTF-8-encoded strings, many of the features that involve
      simple comparisons work without the need for transcoding.<indexterm class="startofrange" id="ch07_m17ntranscodeuser" significance="normal"><primary>m17n (multilingualization)</primary><secondary>portable m17n through UTF-8 transcoding</secondary><tertiary>transcoding user input</tertiary></indexterm><indexterm class="startofrange" id="ch07_transcodeuserin" significance="normal"><primary>transcoding</primary><secondary>user input</secondary></indexterm><indexterm class="startofrange" id="ch07_userinputtranscode" significance="normal"><primary>user input, transcoding</primary></indexterm></para><para>As it turns out, Ruby does a lot of special casing when it comes
      to strings containing only ASCII characters. Although strings that have
      different character encodings from one another are generally not
      comparable and cannot be combined through manipulations, these rules do
      not apply if each of them consists of only ASCII characters.<indexterm id="I_indexterm7_d1e8492" significance="normal"><primary>ASCII strings, transcoding and</primary></indexterm></para><para>It turns out that in practice, you don’t really need to worry
      about transcoding whenever you are comparing user input to a finite set
      of possible ASCII values.</para><para>Here’s an example of a case where transcoding is not
      necessary:</para><programlisting id="I_programlisting7_d1e8499" format="linespecific"># coding: iso-8859-1

require "prawn"

Prawn::Document.generate("output.pdf", :page_size =&gt; "LEGAL") do
  stroke_line [100,100], [200,200]
end</programlisting><para>In this case, neither the filename nor the page size are
      transcoded within Prawn. Although we passed Latin-1 strings in, Prawn
      didn’t bother to translate them to UTF-8, because it didn’t need to. The
      filename is eventually passed straight through to <literal moreinfo="none">File.open()</literal>, so no manipulations or
      comparisons are ever done on it. However, <literal moreinfo="none">:page_size</literal> is used to look up page dimensions
      in a hash that looks something like this:</para><programlisting id="I_programlisting7_d1e8509" format="linespecific">SIZES = {     "A4" =&gt; [595.28, 841.89 ],
           "FOLIO" =&gt; [612.00, 936.00 ],
           "LEGAL" =&gt; [612.00, 1008.00],
          "LETTER" =&gt; [612.00, 792.00 ]  }</programlisting><para>Although the whole of Prawn’s source is using UTF-8 literals, and
      the example we showed earlier is using Latin-1, the proper page size
      ends up getting looked up in the hash. As it turns out, the laziness of
      Ruby’s m17n system really comes in handy.</para><para>When dealing with strings in which <literal moreinfo="none">String#ascii_only?</literal> returns <literal moreinfo="none">true</literal>, the object acts for all intents and
      purposes as if it were an ASCII string. It will play nice with strings
      of other encodings as long as they too consist entirely of ASCII
      characters.<indexterm id="I_indexterm7_d1e8521" significance="normal"><primary>String#ascii_only? method</primary></indexterm></para><para>This gives you a good criteria for what needs to be transcoded and
      what doesn’t. If you can be sure that you never manipulate or compare a
      string, it can be safely ignored in most cases. In cases in which you do
      manipulation or comparison, if the input strings will consist of nothing
      more than ASCII characters in all cases, you do not need to transcode
      them. All other strings need to be transcoded to UTF-8 within your
      library unless you expect users to do the conversions
      themselves.<indexterm id="I_indexterm7_d1e8526" significance="normal"><primary>transcoding</primary><secondary>criteria for what needs transcoding</secondary></indexterm></para><para>After combing your API, depending on your needs, the number of
      parameters that need to be converted may be a lot or a little. In the
      case of Prawn, even though it is a relatively complex system, it turned
      out to be a very small task to make the library work fairly well with
      the arbitrary strings that users pass in to our methods.</para><para>Essentially the only time we needed to normalize encodings of
      strings was when dealing with text that ends up getting displayed within
      the PDFs. Because our system essentially works by mapping Unicode code
      points to the actual outlines of characters (glyphs) that end up getting
      rendered to the document, we cannot simply deal with any text the user
      provides us. It needs to be transcoded.</para><para>If we look at the core <literal moreinfo="none">text()</literal>
      method, we can see where this actually occurs in Prawn:<indexterm id="I_indexterm7_d1e8541" significance="normal"><primary>text( ) method</primary></indexterm></para><programlisting id="I_programlisting7_d1e8544" format="linespecific">def text(text,options={})
  # we'll be messing with the strings encoding, don't change the users
  # original string
  text = text.to_s.dup   ## A ##

  save_font do
    options = text_options.merge(options)
    process_text_options(options)

    font.normalize_encoding(text) unless @skip_encoding  ## B ##

    # ... remainder of method is not important
  end
end</programlisting><para>On the line marked <emphasis>A</emphasis>, we see that the
      <literal moreinfo="none">text()</literal> method makes a copy of the
      string, because we will change its encoding later. The few lines that
      follow it are not of interest, until we reach the line marked
      <emphasis>B</emphasis>. This line calls <literal moreinfo="none">Prawn::Font#normalize_encoding</literal> with the text
      that is to be rendered, and that method is responsible for doing the
      transcoding. This method is actually implemented by subclasses of
      <literal moreinfo="none">Prawn::Font</literal>, <phrase role="keep-together">because</phrase> different font systems require
      different encodings. In the interest of simplicity, we’ll look at TTF
      fonts, where UTF-8 text is used:<indexterm id="I_indexterm7_d1e8567" significance="normal"><primary>Prawn::Font#normalize_encoding method</primary></indexterm><indexterm id="I_indexterm7_d1e8570" significance="normal"><primary>normalize_encoding methods</primary></indexterm></para><programlisting id="I_programlisting7_d1e8573" format="linespecific">module Prawn
  class Font
    class TTF &lt; Font

      def normalize_encoding(text)
        text.encode!("UTF-8")
      end

    end
  end
end</programlisting><para>Here we can see that the code for <literal moreinfo="none">Prawn::Font::TTF#normalize_encoding()</literal> is just
      a thin wrapper on <literal moreinfo="none">String#encode!()</literal>,
      which is used to modify the encoding of a string in place. The reason it
      exists at all is because different font systems have different
      requirements; for example, <literal moreinfo="none">Prawn::Font::AFM</literal> uses Windows-1252 under the
      hood.<indexterm id="I_indexterm7_d1e8586" significance="normal"><primary>Prawn::Font::TTF#normalize_encoding method</primary></indexterm><indexterm id="I_indexterm7_d1e8589" significance="normal"><primary>String#encode! method</primary></indexterm></para><para>The underlying idea here is simple, though. You can clean up your
      code significantly by identifying the points where encodings matter in
      your code. Oftentimes, there will be a handful of low-level functions
      that are at the core of your system, and they are the places where
      transcoding needs to be done. In the case of Prawn, even with things
      like formatted text boxes and tables and other fancy means of putting
      content on the page, the core method that is used by all of those
      features is the single <literal moreinfo="none">text()</literal> method.
      At this point, we call a <literal moreinfo="none">normalize_encoding</literal> method that abstracts away
      the actual encoding that gets used. In the case of Prawn, this is
      especially important—although the core library works in UTF-8, depending
      on which font you use, text strings entered from the user may end up
      being transcoded into various different encodings.</para><para>Although some libraries may be more complex than others to
      implement in this manner, for a wide variety of purposes, this works
      fairly well. The main reason for using UTF-8 is that it provides a good
      base encoding that most other encodings can be transcoded into. If you
      take advantage of Ruby’s shortcuts when it comes to ASCII strings, you
      can safely ignore a lot of the finer points about whether two different
      encodings play nice together.</para><para>Though a library implemented in this way isn’t truly set up to
      deal with arbitrary character encodings in the way that something like
      CSV implements its m17n support, it provides an easy solution that may
      work in most cases. Although the looseness of such a system does have
      some drawbacks, the advantages are often worth it.<indexterm id="I_indexterm7_d1e8604" class="endofrange" startref="ch07_m17ntranscodeuser" significance="normal"/></para><para>Roughly, the process of building a UTF-8 based system goes like
      this:<indexterm id="I_indexterm7_d1e8607" significance="normal"><primary>m17n (multilingualization)</primary><secondary>portable m17n through UTF-8 transcoding</secondary><tertiary>guidelines for</tertiary></indexterm></para><itemizedlist><listitem><para>Be sure to set the source encoding of every file in your
          project to UTF-8 using magic comments.</para></listitem><listitem><para>Use the <literal moreinfo="none">external:internal</literal> encoding string
          when opening any I/O stream, specifying the internal encoding as
          UTF-8. This will automatically transcode files to UTF-8 upon read,
          and automatically transcode from UTF-8 to the external encoding on
          write.</para></listitem><listitem><para>Make sure to either use <literal moreinfo="none">File.binread()</literal> or include the <literal moreinfo="none">"b"</literal> flag when dealing with binary files.
          Otherwise, your files may be incorrectly interpreted based on your
          locale, rather than being treated as a stream of unencoded
          bytes.</para></listitem><listitem><para>When dealing with user-entered strings, only transcode those
          that need to be manipulated or compared to non-ASCII strings. All
          others can be left in their native encoding as long as they consist
          of ASCII characters only or they are not manipulated by your
          code.</para></listitem><listitem><para>Do not rely on <literal moreinfo="none">default_external</literal> or <literal moreinfo="none">default_internal</literal>, and be sure to set your
          source encodings properly. This ensures that your code will not
          depend on environmental conditions to run.</para></listitem><listitem><para>If you need to do a ton of text processing on user-entered
          strings that may use many different character mappings, it might not
          be a great idea to use this approach.</para></listitem></itemizedlist><para>Although you may run into some other challenges depending on what
      your actual project is like, the tips above should get you most of the
      way to a working solution.</para><para>Each approach we’ve discussed so far illustrates a trade-off
      between high compatibility and simplicity of implementation. While
      UTF-8-based systems with limited automatic transcoding support represent
      a middle-of-the-road approach, we’ll now look at how to use every
      possible shortcut to quickly get your job done at the expense of <phrase role="keep-together">portability</phrase>.<indexterm id="I_indexterm7_d1e8656" class="endofrange" startref="ch07_userinputtranscode" significance="normal"/><indexterm id="I_indexterm7_d1e8657" class="endofrange" significance="normal"/><indexterm id="I_indexterm7_d1e8658" class="endofrange" startref="ch07_UTF8library" significance="normal"/><indexterm id="I_indexterm7_d1e8659" class="endofrange" startref="ch07_m17nportable" significance="normal"/></para></sect2></sect1><sect1 id="I_sect17_d1e8661"><title>m17n in Standalone Scripts</title><para>Ruby is a scripting language at heart. Although the earlier m17n
    represents an elegant and highly flexible system, it would be tedious to
    think about all of its details when you just want to process some
    datafiles or run a quick one-liner on the command line. Although we won’t
    spend much time going over the minute details, I want to make sure that
    you get a chance to see how Ruby lets the m17n system get out of your way
    a bit when it comes to day-to-day scripting needs.<indexterm class="startofrange" id="ch07_m17nstandalone" significance="normal"><primary>m17n (multilingualization)</primary><secondary sortas="standalone">in standalone scripts</secondary></indexterm></para><sect2><title>Inferring Encodings from Locale</title><para>The key things that Ruby’s m17n system can modify when it comes to
      encodings are the source encoding, the default external encoding of
      files, and the default internal encoding that loaded files should be
      transcoded to. The following simple script inspects each of these values
      to see how they relate to your system’s locale:<indexterm id="I_indexterm7_d1e8676" significance="normal"><primary>m17n (multilingualization)</primary><secondary sortas="standalone">in standalone scripts</secondary><tertiary>inferring encodings from locale</tertiary></indexterm><indexterm id="I_indexterm7_d1e8683" significance="normal"><primary>locale, inferring encodings from</primary></indexterm></para><programlisting id="I_programlisting7_d1e8686" format="linespecific">puts "Source encoding: #{__ENCODING__.inspect}"
puts "Default external: #{Encoding.default_external.inspect}"
puts "Default internal: #{Encoding.default_internal.inspect}"
puts "Locale charmap: #{ Encoding.locale_charmap.inspect}"
puts "LANG environment variable: #{ENV['LANG'].inspect}"</programlisting><para>When we run this code without a magic comment, I get the following
      output on my system. Your exact values may vary, as I’ll explain in a
      moment:</para><programlisting id="I_programlisting7_d1e8690" format="linespecific">$ ruby encoding_checker.rb

Source encoding: #&lt;Encoding:US-ASCII&gt;
Default external: #&lt;Encoding:UTF-8&gt;
Default internal: nil
Locale charmap: "UTF-8"
LANG environment variable: "en_US.UTF-8"</programlisting><para>Here, we see that the source encoding has fallen back to US-ASCII
      because none was explicitly set. However, the default external matches
      our locale charmap, which is <phrase role="keep-together">inferred</phrase> from the <literal moreinfo="none">LANG</literal> environment variable. Although your
      locale may not be set to UTF-8, you should see that these values match
      each other on your system, as long as <literal moreinfo="none">LANG</literal> is set to one of the encodings Ruby
      supports. A default internal encoding of <literal moreinfo="none">nil</literal> tells us that text should not be
      transcoded automatically while reading and writing files, but be kept in
      the same encoding as the locale.</para><para>To see how these values can be influenced, we can change our
      locale via the <literal moreinfo="none">LANG</literal> environment variable, and check
      what happens:<indexterm id="I_indexterm7_d1e8711" significance="normal"><primary>LANG environment variable</primary></indexterm></para><programlisting id="I_programlisting7_d1e8714" format="linespecific">$ LANG="en_US.ISO8859-1" ruby encoding_checker.rb

Source encoding: #&lt;Encoding:US-ASCII&gt;
Default external: #&lt;Encoding:ISO-8859-1&gt;
Default internal: nil
Locale charmap: "ISO8859-1"
LANG environment variable: "en_US.ISO8859-1"</programlisting><para>Here we see that rather than UTF-8, Latin-1 is used as the default
      external now. This means that if you modify this environment variable
      globally, Ruby will use it to determine what fallback encoding to use
      when dealing with I/O operations.</para><para>So on my system, where UTF-8 is the default external encoding, I
      can open files knowing that if I don’t specify any particular character
      mapping, they will load in as UTF-8:</para><programlisting id="I_programlisting7_d1e8720" format="linespecific">&gt;&gt; File.read("hello.txt")
=&gt; "Hello, world\n"
&gt;&gt; File.read("hello.txt").encoding
=&gt; #&lt;Encoding:UTF-8&gt;</programlisting><para>On your system, your locale charmap will determine this. As long
      as your operating system is properly configured, Ruby should have a
      sensible default encoding for use in I/O operations.</para><para>Although this is very handy, one thing to keep in mind is that the
      locale settings on your system do not affect the default source
      encoding. This means that for all the source files you create, you need
      to set the actual source encoding via magic comment. This restriction is
      actually a good thing, as it makes it hard to make your Ruby programs so
      fragile that a change to <literal moreinfo="none">LANG</literal> can
      break them. However, there is an exception in which allowing the locale
      to influence the source can be a good thing, and that’s for quick
      one-liners.</para><para>Whenever we use <literal moreinfo="none">ruby -e</literal>, the
      purpose is to do some sort of quick, one-off task. Those who use this
      technique often might have already found that there are all sorts of
      shortcuts that can be used when running in this mode. As it turns out,
      this applies to m17n as well:</para><programlisting id="I_programlisting7_d1e8735" format="linespecific">$ ruby -e "p __ENCODING__"
#&lt;Encoding:UTF-8&gt;</programlisting><para>Rather than falling back to ASCII, we can see that it infers the
      source encoding from the locale. To further illustrate that, we can
      reset <literal moreinfo="none">LANG</literal> to Latin-1 again:</para><programlisting id="I_programlisting7_d1e8742" format="linespecific">$ LANG="en_US.ISO8859-1" ruby -e "p __ENCODING__"
#&lt;Encoding:ISO-8859-1&gt;</programlisting><para>As we can see, the source encoding is taken to be whatever our
      system is using for its locale, rather than requiring an explicit
      setting. This makes a lot of sense, because when we write one-liners, we
      typically want to use whatever our terminal is using as an encoding. It
      would also seem quite strange to embed a magic comment into a one-line
      script.</para><para>Because <literal moreinfo="none">ruby -e</literal> will also infer
      the default external encoding in the same way that we’ve shown before
      when dealing with actual scripts, we end up with a powerful tool on our
      hands.</para><para>As you can see, Ruby’s locale-based fallbacks make it possible in
      some cases to just ignore the details of the m17n system, or if
      necessary, to set an environment variable once and forget about it. The
      fact that <literal moreinfo="none">ruby -e</literal> uses a locale-based
      source encoding means that you can also continue using Ruby as a
      command-line tool without too much friction. But now that we’ve looked
      at how Ruby’s character mappings can be influenced by external means, we
      should take a look at how we can get a bit more fine-grained control
      over these things at the Ruby level.</para></sect2><sect2><title>Customizing Encoding Defaults</title><para>If we want to be explicit about our default external encoding, we
      can set it within our files via a simple accessor. In this example,
      we’re indicating that the files we work with should be treated as
      Latin-1 by default, even though our script is encoded in
      UTF-8:<indexterm id="I_indexterm7_d1e8761" significance="normal"><primary>m17n (multilingualization)</primary><secondary sortas="standalone">in standalone scripts</secondary><tertiary>customizing encoding defaults</tertiary></indexterm></para><programlisting id="I_programlisting7_d1e8768" format="linespecific"># coding: UTF-8
Encoding.default_external = Encoding.find("ISO-8859-1")

data = File.read("hello.txt")
p data.encoding #=&gt; #&lt;Encoding:ISO-8859-1&gt;</programlisting><para>If we plan to transcode our data upon load, we can also set the
      <literal moreinfo="none">default_internal</literal> encoding. In the
      following example, we specify that I/O operations should by default be
      transcoded using the source encoding:<indexterm id="I_indexterm7_d1e8775" significance="normal"><primary>default_internal encoding</primary></indexterm></para><programlisting id="I_programlisting7_d1e8778" format="linespecific"># coding: UTF-8
Encoding.default_external = Encoding.find("ISO-8859-1")
Encoding.default_internal = __ENCODING__

data = File.read("hello.txt")
p data.encoding #=&gt; #&lt;Encoding:UTF-8&gt;</programlisting><para>Here we see that the text loaded from the file ends up encoded in
      UTF-8. However, this is done in a safe way. The file is first loaded in
      using the <literal moreinfo="none">default_internal</literal> encoding
      and then translated to the <literal moreinfo="none">default_external</literal> encoding. To illustrate this
      further, the previous example is functionally equivalent to this more
      explicit one:<indexterm id="I_indexterm7_d1e8788" significance="normal"><primary>default_external encoding</primary></indexterm></para><programlisting id="I_programlisting7_d1e8791" format="linespecific"># coding: UTF-8

data = File.read("hello.txt", encoding: "ISO-8859-1:UTF-8")
p data.encoding #=&gt; #&lt;Encoding:UTF-8&gt;</programlisting><para>The difference is that when you set <literal moreinfo="none">default_external</literal> and <literal moreinfo="none">default_internal</literal>, the changes apply globally.
      Because this is a somewhat invasive change to make, you can see that
      messing with the internal and external encodings is reasonable to do
      only in scripting applications, since it does not apply well to code
      that needs to be portable.</para><para>However, in cases where it is reasonable to make this change
      globally, it can be used to avoid repeating encodings incessantly every
      time you do I/O operations. You can even specify these options on the
      command line, to allow them to be specified at the time the script is
      run:</para><programlisting id="I_programlisting7_d1e8803" format="linespecific">$ ruby -E iso-8859-1:utf-8 hello.rb
#&lt;Encoding:UTF-8&gt;</programlisting><para>Now our script is almost entirely devoid of explicit m17n
      details:</para><programlisting id="I_programlisting7_d1e8808" format="linespecific"># coding: UTF-8

data = File.read("hello.txt")
p data.encoding #=&gt; #&lt;Encoding:UTF-8&gt;</programlisting><para>This is about as far as we’ll want to take it in most cases, but
      there is one more example worth sharing before we move on.</para><para>As you may know, Ruby 1.8 did not have a comprehensive m17n system
      like Ruby 1.9 does. However, it did ship with an ability to enable a
      sort of UTF-8 mode, which would tell the interpreter that the strings it
      was working with as well the data pulled in from external files should
      be interpreted as UTF-8 text. This was provided by the
      <emphasis>kcode</emphasis> system, and specified via the <literal moreinfo="none">-Ku</literal> flag. As it turns out, this works on Ruby
      1.9.1 and even allows you to modify the source encoding of your
      files.<indexterm id="I_indexterm7_d1e8820" significance="normal"><primary sortas="Ku flag">&#151;Ku flag</primary></indexterm><indexterm id="I_indexterm7_d1e8823" significance="normal"><primary>kcode system</primary></indexterm></para><para>If we run the <literal moreinfo="none">encoding_checker.rb</literal> file from before using
      <literal moreinfo="none">-Ku</literal>, here’s what you can expect to
      see:</para><programlisting id="I_programlisting7_d1e8834" format="linespecific">$ ruby -Ku encoding_checker.rb
Source encoding: #&lt;Encoding:UTF-8&gt;
Default external: #&lt;Encoding:UTF-8&gt;
Default internal: nil
Locale charmap: "UTF-8"
LANG environment variable: "en_US.UTF-8"</programlisting><para>Your locale settings may be different, but you should see that the
      source encoding and default external encoding have been set to UTF-8.
      Although this feature is primarily for backward compatibility, it is
      worth knowing about for a good “set it and forget it” default if you
      plan to work exclusively with UTF-8 in your scripts. Of course, if you
      have to work in most other encodings, you’ll need to use some
      combination of the techniques we’ve covered earlier in this section, so
      this is far from a magic bullet.<indexterm id="I_indexterm7_d1e8838" significance="normal"><primary>m17n (multilingualization)</primary><secondary sortas="standalone">in standalone scripts</secondary><tertiary>guidelines for</tertiary></indexterm></para><para>Now that we’ve covered a few different ways to simplify your
      scripts to get some of the m17n roadblocks out of the way, here’s a
      recap of the most important details to remember before we move
      on:</para><itemizedlist><listitem><para>The <literal moreinfo="none">LANG</literal> environment
          variable that specifies your system locale is used by Ruby to
          determine the default external encoding of files. A properly set
          locale can allow Ruby to automatically load files in their native
          encodings without explicitly stating what character mapping they
          use.</para></listitem><listitem><para>Although magic comments are typically required in files to set
          the source encoding, an exception is made for <literal moreinfo="none">ruby -e</literal>-based command-line scripts. The
          source encoding for these one-liners is determined by locale. In
          most cases, this is what you will want.</para></listitem><listitem><para>You can specify a default internal encoding that Ruby will
          automatically transcode loaded files into when no explicit internal
          encoding is specified. It is often reasonable to set this to match
          the source encoding in your scripts.</para></listitem><listitem><para>You can set default external/internal encodings via the
          command-line switch <literal moreinfo="none" role="keep-together">-Eexternal:internal</literal> if you do not
          want to explicitly set them in your scripts.</para></listitem><listitem><para>The <literal moreinfo="none">-Ku</literal> flag still works
          for putting Ruby into “UTF-8” mode, which is useful for backward
          compatibility with Ruby 1.8.</para></listitem><listitem><para>All of the techniques described in this section are suitable
          mostly for scripts or private use code. It is a bad idea to rely on
          locale data or manually set external and internal encodings in
          complex systems or code that needs to run on machines you do not
          have control over.</para></listitem></itemizedlist><para>We’ve covered a lot of ground so far, and we’ll be wrapping up
      with m17n to move on to L10n in just a short while. However, before we
      do, I’d like to cover just a couple short notes on how Ruby’s new m17n
      system impacts lower-level code, and how to get around the issues it
      creates.<indexterm id="I_indexterm7_d1e8880" class="endofrange" startref="ch07_m17nstandalone" significance="normal"/></para></sect2></sect1><sect1 id="I_sect17_d1e8881"><title>m17n-Safe Low-Level Text Processing</title><para>In previous versions of Ruby, strings were pretty much sequences of
    bytes rather than characters. This meant the following code seldom caused
    anyone to bat an <phrase role="keep-together">eyelash</phrase>:<indexterm class="startofrange" id="ch07_textprocm17n" significance="normal"><primary>text processing</primary><secondary>low level, m17n-safe</secondary></indexterm><indexterm class="startofrange" id="ch07_m17nsafe" significance="normal"><primary>m17n (multilingualization)</primary><secondary>safe, low-level text processing</secondary></indexterm></para><programlisting id="I_programlisting7_d1e8899" format="linespecific">File.open("hello.txt") { |f|
  loop do
    break if f.eof?
    chunk = "CHUNK: #{f.read(5)}"
    puts chunk unless chunk.empty?
  end
}</programlisting><para>The purpose of the previous example is to print out the contents of
    the file in chunks of five bytes, which, when it comes to ASCII, means
    five characters. However, multibyte character encodings, especially
    variable-length ones such as UTF-8, cannot be processed using this
    approach. The reason is fairly simple.<indexterm id="I_indexterm7_d1e8903" significance="normal"><primary>character encodings</primary><secondary>multibyte</secondary></indexterm><indexterm id="I_indexterm7_d1e8908" significance="normal"><primary>multibyte character encodings</primary></indexterm></para><para>Imagine this code running against a two-character, six-byte string
    in UTF-8 such as “<literal moreinfo="none">吴佳</literal>”. If we read five
    bytes of this string, we end up breaking the second character’s byte
    sequence, resulting in the mangled string “<literal moreinfo="none">吴\xE4\xBD</literal>”. Of course, whether this is a problem
    depends on your reason for reading a file in chunks.</para><para>If we are processing binary data, we probably don’t need to worry
    about character encodings or anything like that. Instead, just we read a
    fixed amount of data according to our needs, processing it however we’d
    like. But many times, the reason why we read data in chunks is not to
    process it at the byte level, but instead, to break it up into small parts
    as we work on it.</para><para>A perfect example of this, and a source of a good solution to the
    problem, is found within the CSV standard library. As we’ve seen before,
    this library is fully m17n-capable and takes great care to process files
    in a encoding-agnostic way. However, it also tries to be clever about
    certain things, which makes m17n support a bit more challenging.</para><para>Rather than assume <literal moreinfo="none">\n</literal> is the
    default line ending to separate rows within a CSV, the library tries to
    determine what the line endings of a file are from a list of possibilities
    by examining a file in chunks. It cannot accomplish this task by reading
    in a single line of text, because it does not know the line endings yet.
    It would be highly inefficient to try to read in the whole file to
    determine the endings, because CSV data can become huge. Therefore, what
    is needed is a way to process the data in chunks while searching for a
    line ending that does not break multibyte characters.</para><para>The solution is actually relatively simple, so we’ll take a look at
    the whole thing first and then discuss it in a little more detail:</para><programlisting id="I_programlisting7_d1e8930" format="linespecific">def read_to_char(bytes)
  return "" if @io.eof?
  data = @io.read(bytes)
  begin
    encoded = encode_str(data)
    raise unless encoded.valid_encoding?
    return encoded
  rescue  # encoding error or my invalid data raise
    if @io.eof? or data.size &gt;= bytes + 10
      return data
    else
      data += @io.read(1)
      retry
    end
  end
end</programlisting><para>Here, <literal moreinfo="none">@io</literal> is an <literal moreinfo="none">IO</literal> object of some sort, typically a <literal moreinfo="none">File</literal>, and the <literal moreinfo="none">encode_str()</literal> method is the same function we
    covered toward the beginning of this chapter, which is a thin wrapper over
    <literal moreinfo="none">String#encode()</literal>. If we walk through
    this step by step, we see that an empty string is returned if the stream
    is already at <literal moreinfo="none">eof?</literal>. Assuming that it is
    not, a specified number of <literal moreinfo="none">bytes</literal> is
    read.<indexterm id="I_indexterm7_d1e8956" significance="normal"><primary>encode_str( ) method</primary></indexterm><indexterm id="I_indexterm7_d1e8959" significance="normal"><primary>String#encode method</primary></indexterm><indexterm id="I_indexterm7_d1e8962" significance="normal"><primary>valid_encoding? method</primary></indexterm></para><para>Then, the string is encoded, and it is checked to see whether the
    character mapping is valid. To clarify what <literal moreinfo="none">valid_encoding?</literal> does, we can look at this simple
    example:</para><programlisting id="I_programlisting7_d1e8971" format="linespecific">p "吴佳".valid_encoding?       #=&gt; true
p "吴\xE4\xBD".valid_encoding? #=&gt; false</programlisting><para>When the encoding is valid, <literal moreinfo="none">read_to_char</literal> returns the chunk, assuming that
    the string was broken up properly. Otherwise, it raises an error, causing
    the <literal moreinfo="none">rescue</literal> block to be executed. Here,
    we see that the core fix relies on buffering the data slightly to try to
    read a complete character. What actually happens here is that the method
    gets retried repeatedly, adding one extra byte to the <literal moreinfo="none">data</literal> until it either reaches a total of 10 bytes
    over the specified chunk size, or hits the end of the file.<indexterm id="I_indexterm7_d1e8984" significance="normal"><primary>read_to_char</primary></indexterm></para><para>The reason why this works is that every encoding Ruby supports has a
    character size of less than 10 bytes. This is in fact a conservative
    estimate, but is sufficiently small to still be reasonable. Using this
    method, it is possible to process data in chunks in an encoding-safe
    way.</para><para>The code that we looked at here was pulled directly from the
    <emphasis>csv</emphasis> library, but it would be easy to tweak for your
    individual needs. The main idea is basically that we need to consume some
    extra bytes to complete a character sometimes, and we can determine
    whether this is necessary based on either an error from <literal moreinfo="none">String#encode()</literal> or the state of <literal moreinfo="none">String#valid_encoding?</literal>. I’ll leave the
    generalization of <literal moreinfo="none">read_to_char</literal> as an
    exercise for you, as its implementation will likely depend on the context,
    but this code from CSV is a solid conceptual base to start from.<indexterm id="I_indexterm7_d1e9003" significance="normal"><primary>String#valid_encoding? method</primary></indexterm></para><para>I’d like to wrap up this section by pointing out one other thing to
    remember about low-level operations on strings when it comes to m17n. If
    you’re used to thinking of bytes as character codes, you’ll need to
    rethink the way you are doing things. You might be used to getting
    character codes via <literal moreinfo="none">String#unpack</literal>:<indexterm id="I_indexterm7_d1e9011" significance="normal"><primary>String#unpack method</primary></indexterm></para><programlisting id="I_programlisting7_d1e9014" format="linespecific">&gt;&gt; "Hello world".unpack("C*")
=&gt; [72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100]</programlisting><para>Though this can be made to work for a handful of encodings, if you
    need to keep your code character-mapping-agnostic, you’ll want to actually
    use <literal moreinfo="none">String#ord</literal> instead here:<indexterm id="I_indexterm7_d1e9021" significance="normal"><primary>String#ord method</primary></indexterm></para><programlisting id="I_programlisting7_d1e9024" format="linespecific">&gt;&gt; "Hello world".chars.map(&amp;:ord)
=&gt; [72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100]</programlisting><para>This will work fine with any encoding you work with, giving back the
    ordinal value based on the actual encoding rather than the byte
    value:</para><programlisting id="I_programlisting7_d1e9028" format="linespecific">&gt;&gt; utf8_string
=&gt; "吴佳"
&gt;&gt; utf8_string.chars.map(&amp;:ord)
=&gt; [21556, 20339]</programlisting><para>There is more we could talk about here, but I’d rather not go
    through the gory details exhaustively. The underlying theme of working
    with low-level text operations in an m17n-safe way is that characters are
    not necessarily equivalent to bytes. If you remember that simple idea,
    most of the rest of the core ideas will fall into place.</para><para>Now that we’ve talked quite a bit about how to actually process text
    in a wide variety of character mappings, we’ll discuss a slightly
    higher-level topic. If you are going to support multiple languages in your
    application, you’ll want a clean and organized way to do it. The next
    section will give you some tips on how to accomplish that without too much
    of a hassle.<indexterm id="I_indexterm7_d1e9035" class="endofrange" startref="ch07_textprocm17n" significance="normal"/><indexterm id="I_indexterm7_d1e9036" class="endofrange" startref="ch07_m17nsafe" significance="normal"/></para></sect1><sect1 id="I_sect17_d1e9037"><title>Localizing Your Code</title><para>To make an application truly multilingual, we need to do more than
    just be able to process and produce text in different languages. We also
    need to provide a way for the user interface to be translated into the
    natural languages we wish to support. If you wanted to support even a
    small handful of languages, neither building multiple versions of your
    application nor writing tons of special casing wherever text is displayed
    will be a maintainable solution. Instead, what is needed is a way to mark
    the relevant sections of text with meaningful tags that can then be
    altered by external translation files. This is the process of localization
    (L10n).<indexterm class="startofrange" id="ch07_L10n" significance="normal"><primary>L10n (localization)</primary></indexterm></para><para>We’re going to be looking at a tiny L10n package I put together when
    I realized there weren’t any Ruby 1.9-based tools available that worked
    outside of Rails. It is called <literal moreinfo="none">Gibberish::Simple</literal>, and is a fork of the very
    cool <literal moreinfo="none">Gibberish</literal> plug-in by Chris
    Wanstrath. The main modifications I made were to port the library to Ruby
    1.9.1, remove all dependencies including the Rails integration, and change
    the system a bit so that it does not depend on core extensions. Other than
    that, all of the hard work was done by Chris and he deserves all the
    credit for the actual system, which, as you’ll see in a minute, is quite
    easy to use.<indexterm id="I_indexterm7_d1e9053" significance="normal"><primary>Wanstrath, Chris</primary></indexterm><indexterm id="I_indexterm7_d1e9056" significance="normal"><primary>Gibberish plug-in</primary></indexterm><indexterm id="I_indexterm7_d1e9059" significance="normal"><primary>Gibberish::Simple module</primary></indexterm></para><para>We’re going to first look at a very trivial web application using
    the Sinatra web framework. It implements the children’s game “Rock, Paper,
    Scissors.”<footnote><para>See <ulink url="http://en.wikipedia.org/wiki/Rock-paper-scissors">http://en.wikipedia.org/wiki/Rock-paper-scissors</ulink>.</para></footnote> We’ll look at it both before and after localization, to give
    you a feel for the actual process of localizing your text.</para><para>The entire application is dirt-simple, with only two screens. The
    first lets you choose from “Rock,” “Paper,” and “Scissors” for your weapon
    (<xref linkend="fig_7-1"/>).</para><figure float="none" id="fig_7-1"><title>Choosing a weapon</title><mediaobject id="d1e958"><imageobject role="print"><imagedata fileref="figs/print/rubp_0701.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/rubp_0701.png" format="PNG"/></imageobject></mediaobject></figure><para>The ERB template used to generate this view is trivial, as you might
    expect:<indexterm id="I_indexterm7_d1e9085" significance="normal"><primary>ERB templates</primary><secondary sortas="Rock">for Rock, Paper, Scissors game
        views</secondary></indexterm></para><programlisting id="I_programlisting7_d1e9090" format="linespecific">&lt;html&gt;
&lt;head&gt;
  &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;form method="post"&gt;
    &lt;% ["Rock", "Paper", "Scissors"].each do |weapon| %&gt;
      &lt;input type="radio" name="weapon" value="&lt;%= weapon %&gt;"&gt;
        &lt;%= weapon %&gt;
      &lt;/input&gt;
    &lt;% end %&gt;
    &lt;input type="submit" value="Shoot"&gt;
  &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</programlisting><para>Here we’re just doing some simple dynamic form generation, and even
    a basic understanding of HTML should be sufficient to understand what’s
    going on, so I won’t go into details.</para><para>After submitting this form data, the game logic is done behind the
    scenes and the opponent’s choice is revealed (<xref linkend="fig_7-2"/>).</para><figure float="none" id="fig_7-2"><title>Announcing the winner</title><mediaobject id="d1e985"><imageobject role="print"><imagedata fileref="figs/print/rubp_0702.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/rubp_0702.png" format="PNG"/></imageobject></mediaobject></figure><para>This ERB template is even more simple than the last one, as it just
    displays some pregenerated data:</para><programlisting id="I_programlisting7_d1e9109" format="linespecific">&lt;html&gt;
&lt;head&gt;
  &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt; You: &lt;%= @player_weapon %&gt;&lt;/p&gt;
  &lt;p&gt; Opponent: &lt;%= @opponent_weapon %&gt;&lt;/p&gt;
  &lt;h3&gt;&lt;%= end_game_message %&gt;&lt;/h3&gt;
&lt;/body&gt;
&lt;/html&gt;</programlisting><para>Tying the whole application together is the actual Sinatra
    application. It handles the game logic and generates the appropriate
    messages, but is not in any way complex. Here’s the whole thing, which
    consists of nothing more than two URI handlers and a helper function that
    determines who won:<indexterm id="I_indexterm7_d1e9113" significance="normal"><primary>Sinatra application for Rock, Paper, Scissors game</primary></indexterm></para><programlisting id="I_programlisting7_d1e9116" format="linespecific">require "sinatra"

get '/rps' do
  erb :rps_start
end

post '/rps' do
  @player_weapon    = params[:weapon]
  @opponent_weapon  = %w[Rock Paper Scissors].sample
  erb :rps_end
end

helpers do
  def end_game_message
    return "It's a tie" if @player_weapon == @opponent_weapon

    winning_combos = [["Paper","Rock"],["Rock","Scissor"],["Scissors","Paper"]]
    if winning_combos.include?([@player_weapon, @opponent_weapon])
      "You Win"
    else
      "You Lose"
    end
  end
end</programlisting><para>Although tiny, this does represent a fully functional application.
    The fact that we’re presenting an interface for users to interact with
    means that interface can be localized. We’ll now look at how to go about
    adding two languages, French and Chinese.</para><para>One option would be to code up separate views and some specialized
    translation logic for each language, but that approach doesn’t scale
    particularly well. Instead, what we can do is come up with unique
    identifiers for each text segment in our application, and then create
    translation files that fill in the appropriate values depending on what
    language is selected. Ignoring how we actually integrate these translation
    files into our application for the moment, we can look at a couple of them
    to get a feel for how they look.</para><para>The following simple YAML file covers all the necessary Chinese
    translations for this <phrase role="keep-together">application</phrase>:<indexterm id="I_indexterm7_d1e9127" significance="normal"><primary>translation files, using in localization</primary></indexterm><indexterm id="I_indexterm7_d1e9130" significance="normal"><primary>yaml standard library</primary><secondary>file with Chinese translation for RPS game</secondary></indexterm><indexterm id="I_indexterm7_d1e9135" significance="normal"><primary>Chinese translations for RPS application</primary></indexterm></para><programlisting id="I_programlisting7_d1e9138" format="linespecific">win: 你赢了
lose: 你输了
tie: 平局

rock: 石头
paper: 布
scissors: 剪刀

shoot: 开
you: 你
opponent: 对手</programlisting><para>As you can see, these are direct mappings between English
    identifiers for text that appears in our application and their Chinese
    translations. Because all of the translation files will follow this same
    basic structure, you’ll notice that the French translation file looks
    pretty much the same:<indexterm id="I_indexterm7_d1e9142" significance="normal"><primary>yaml standard library</primary><secondary>file with French translation for RPS game</secondary></indexterm><indexterm id="I_indexterm7_d1e9147" significance="normal"><primary>French translation for RPS game</primary></indexterm></para><programlisting id="I_programlisting7_d1e9150" format="linespecific">win: Tu gagnes
lose: Tu perds
tie: Egalité

rock: Caillou
paper: Feuille
scissors: Ciseaux

shoot: On y va !
you: Toi
opponent: Adversaire</programlisting><para>With some translation files in hand, we can work on integrating
    <literal moreinfo="none">Gibberish::Simple</literal> into our application.
    Before we do that, we’ll look at a simple script that shows the basic
    mechanics of how things work. In the following example, it is assumed that
    <filename moreinfo="none">lang/cn.yml</filename> and <filename moreinfo="none">lang/fr.yml</filename>
    exist and are populated with the values here:</para><programlisting id="I_programlisting7_d1e9164" format="linespecific"># coding: UTF-8

require "gibberish/simple"

# Tell Gibberish that lang/ exists in the same root directory as this file
Gibberish::Simple.language_paths &lt;&lt; File.dirname(__FILE__)

# Let us use the T() translation helper globally
include Gibberish::Simple

p T("You Win", :win) #=&gt; "You Win"

Gibberish::Simple.use_language(:fr) do
  p T("You Win", :win) #=&gt; "Tu gagnes."
end

Gibberish::Simple.use_language(:cn) do
  p T("You Win", :win) #=&gt; "你赢了"
end

# Because there is no matching file, this falls back to the defaults

Gibberish::Simple.use_language(:en) do
  p T("You Win", :win) #=&gt; "You Win"
end</programlisting><para>Here we see that our text display calls are wrapped in a method call
    to <literal moreinfo="none">T()</literal>, which stands for translate.
    When no language is specified, this code displays the default value that
    is specified by the first argument. When a language is specified via the
    <literal moreinfo="none">use_language</literal> block, <literal moreinfo="none">T()</literal> will look up the appropriate translation via
    the unique tag for it. If <literal moreinfo="none" role="keep-together">use_language</literal> is given a language that does
    not have a matching YAML file, the defaults are reverted to. As you can
    see, for these basic needs, there isn’t a whole lot to it.</para><para>Now, we’re ready to take a look at the localized version of “Rock,
    Paper, Scissors.” We can start with the main application and work our way
    out to the views. Though some changes were necessary, you’ll see that the
    code is still pretty easy to follow:<indexterm id="I_indexterm7_d1e9182" significance="normal"><primary>L10n (localization)</primary><secondary>localized version of Rock, Paper, Scissors game</secondary></indexterm></para><programlisting id="I_programlisting7_d1e9187" format="linespecific">require "sinatra"
require "gibberish/simple"

Gibberish::Simple.language_paths &lt;&lt; File.dirname(__FILE__)
include Gibberish::Simple

get '/rps' do
  redirect '/rps/en'
end

get '/rps/:lang' do
  erb :rps_start
end

post '/rps/:lang' do
  @player_weapon    = params[:weapon]
  @opponent_weapon  = %w[Rock Paper Scissors].sample
  erb :rps_end
end

helpers do
  def end_game_message
    return T("It's a tie", :tie) if @player_weapon == @opponent_weapon

    winning_combos = [["Paper","Rock"],["Rock","Scissor"],["Scissors","Paper"]]
    if winning_combos.include?([@player_weapon, @opponent_weapon])
      T("You Win", :win)
    else
      T("You Lose", :lose)
    end
  end

  def weapon_name(weapon)
    T(weapon, weapon.downcase.to_sym)
  end

  def translated(&amp;block)
    Gibberish::Simple.use_language(params[:lang], &amp;block)
  end
end</programlisting><para>The first thing to notice is that I’ve decided to embed the language
    choice into the URI. This is the code that does that:</para><programlisting id="I_programlisting7_d1e9191" format="linespecific">get '/rps' do
  redirect '/rps/en'
end

get '/rps/:lang' do
  erb :rps_start
end</programlisting><para>You can see that going to <literal moreinfo="none">/rps</literal>
    actually redirects you to <literal moreinfo="none">/rps/en</literal>,
    which represents the English version of the game. The need for this code
    is mainly a consequence of the fact that we’re building something
    web-based without a database backend. In other applications, you could
    store the current language in whatever way makes the most sense for the
    individual solution. The key idea here is only that we need to be able to
    tell <literal moreinfo="none">Gibberish::Simple</literal> what language we
    want to work in. You’ll see how it’s used in a moment, but this <literal moreinfo="none">:lang</literal> parameter is used by our <literal moreinfo="none">translated</literal> helper to set the current language
    from within a view:<indexterm id="I_indexterm7_d1e9211" significance="normal"><primary>L10n (localization)</primary><secondary>passing all strings shown to viewer through translation
        filter</secondary></indexterm></para><programlisting id="I_programlisting7_d1e9216" format="linespecific">def translated(&amp;block)
  Gibberish::Simple.use_language(params[:lang], &amp;block)
end</programlisting><para>The rest of the remaining changes are simply wrapping anything that
    will eventually be displayed to the user in <literal moreinfo="none">T()</literal> calls. Notice this does not affect the
    actual logic of our code, which still works in terms of comparing “Rock,”
    “Paper,” and “Scissors” regardless of the language we’re displaying the UI
    in. This is an important aspect of localizing your code: you want to do it
    as late as possible so that your business logic is not affected by
    translations. The <literal moreinfo="none">weapon_name</literal> helper
    serves exactly this purpose:<indexterm id="I_indexterm7_d1e9226" significance="normal"><primary>L10n (localization)</primary><secondary>doing as late as possible to avoid effects on business
        logic</secondary></indexterm></para><programlisting id="I_programlisting7_d1e9231" format="linespecific">def weapon_name(weapon)
  T(weapon, weapon.downcase.to_sym)
end</programlisting><para>Beyond the additions of a couple helpers and some calls to <literal moreinfo="none">T()</literal>, much of the code is left unchanged. The
    more significant work involved with localizing this application is done at
    the view level. What follows is the template from the first screen, the
    weapon selection form:<indexterm id="I_indexterm7_d1e9238" significance="normal"><primary>L10n (localization)</primary><secondary>view level localization of Rock, Paper, Scissors
        game</secondary></indexterm></para><programlisting id="I_programlisting7_d1e9244" format="linespecific">&lt;html&gt;
&lt;head&gt;
  &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;form method="post"&gt;
    &lt;% translated do %&gt;
      &lt;% ["Rock", "Paper", "Scissors"].each do |weapon| %&gt;
        &lt;input type="radio" name="weapon" value="&lt;%= weapon %&gt;"&gt;
          &lt;%= weapon_name(weapon) %&gt;
        &lt;/input&gt;
      &lt;% end %&gt;
      &lt;input type="submit" value="&lt;%= T('Shoot!',:shoot) %&gt;"&gt;
   &lt;% end %&gt;
  &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</programlisting><para>Here, we see our helpers from the main application in action. The
    <literal moreinfo="none">translated</literal> <phrase role="keep-together">block is just syntactic</phrase> sugar that infers
    from the URI which language to pass to <literal moreinfo="none" role="keep-together">Gibberish::Simple.use_langauge</literal>. Within this
    block, every string displayed to the user must be directly or indirectly
    passed through <literal moreinfo="none">T()</literal> to be translated.
    However, we explicitly leave the values of the actual parameters
    untranslated, allowing our basic game logic to remain
    unmodified.<indexterm id="I_indexterm7_d1e9260" significance="normal"><primary>L10n (localization)</primary><secondary>writing helper functions for translation</secondary></indexterm></para><para>The second view is a bit easier because, as mentioned before, it’s
    strictly displaying information:</para><programlisting id="I_programlisting7_d1e9267" format="linespecific">&lt;html&gt;
&lt;head&gt;
  &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;% translated do %&gt;
    &lt;p&gt;&lt;%= T("You", :you) %&gt;: &lt;%= weapon_name(@player_weapon) %&gt;&lt;/p&gt;
    &lt;p&gt;&lt;%= T("Opponent", :opponent) %&gt;: &lt;%= weapon_name(@opponent_weapon) %&gt;&lt;/p&gt;
    &lt;h3&gt;&lt;%= end_game_message %&gt;&lt;/h3&gt;
  &lt;% end %&gt;
&lt;/body&gt;
&lt;/html&gt;</programlisting><para>Here, we’re just looking up a few more tagged text segments, so
    there’s nothing new to worry about. With these three files modified,
    heading to the <literal moreinfo="none">/rps/en</literal> URI gives you
    the same screens shown at the beginning of the chapter.</para><para>When we hit <literal moreinfo="none">/rps/cn</literal>, we get the
    screen for weapon selection (<xref linkend="fig_7-3"/>).</para><figure float="none" id="fig_7-3"><title>Weapon selection (Chinese)</title><mediaobject id="d1e1149"><imageobject role="print"><imagedata fileref="figs/print/rubp_0703.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/rubp_0703.png" format="PNG"/></imageobject></mediaobject></figure><para>Pressing the button brings us to the results screen (<xref linkend="fig_7-4"/>).</para><figure float="none" id="fig_7-4"><title>Announcing the winner (Chinese)</title><mediaobject id="d1e1168"><imageobject role="print"><imagedata fileref="figs/print/rubp_0704.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/rubp_0704.png" format="PNG"/></imageobject></mediaobject></figure><para>When we switch to the <literal moreinfo="none">/rps/fr</literal>
    URI, we get to pick our weapons in French (<xref linkend="fig_7-5"/>).</para><figure float="none" id="fig_7-5"><title>Weapon selection (French)</title><mediaobject id="d1e1189"><imageobject role="print"><imagedata fileref="figs/print/rubp_0705.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/rubp_0705.png" format="PNG"/></imageobject></mediaobject></figure><para>And, of course, we can see our final results as well (<xref linkend="fig_7-6"/>).</para><figure float="none" id="fig_7-6"><title>Announcing the winner (French)</title><mediaobject id="d1e1207"><imageobject role="print"><imagedata fileref="figs/print/rubp_0706.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/rubp_0706.png" format="PNG"/></imageobject></mediaobject></figure><para>At this point, we can take full advantage of the fact that the
    application has been localized. Adding new translations is as easy as
    dropping new YAML files into the <literal moreinfo="none">lang</literal>
    directory. This is clear evidence of why it is better to offer general
    localization support than it is to offer a “Chinese Version” and “French
    Version” and however many other versions of your application you can
    imagine. This simple approach lets you easily customize the text used in
    your interface without much modification to your underlying business
    logic.</para><para>Of course, the example we’ve shown here is about as simple as you
    might imagine. In more complicated cases, you may have phrases where some
    text needs to be in a different order, depending on which language you are
    dealing with. This is especially common with things like names. To deal
    with things like this, you can create templates that allow for
    substitutions. We’ll run through a simple example before wrapping things
    up here, just to give you an idea of how to work with situations like
    this.<indexterm id="I_indexterm7_d1e9336" significance="normal"><primary>names of people, localizing</primary></indexterm><indexterm id="I_indexterm7_d1e9339" significance="normal"><primary>L10n (localization)</primary><secondary>dealing with names of people</secondary></indexterm></para><para>In American English, names are typically represented as “Given
    Surname,” such as “Gregory Brown.” Here’s how we’d express that as a
    default in <literal moreinfo="none">Gibberish::Simple</literal>:</para><programlisting id="I_programlisting7_d1e9349" format="linespecific">data = { given_name: "Gregory", surname: "Brown" }
p T("{given_name} {surname}",  [:name, data]) #=&gt; "Gregory Brown"</programlisting><para>If we want to invert this order, we can easily do so in our
    templates. Here we’ve added a <literal moreinfo="none">:name</literal> tag
    to the <filename moreinfo="none">lang/cn.yml</filename> file that demonstrates how this is
    done:</para><programlisting id="I_programlisting7_d1e9359" format="linespecific">name: "{surname}{given_name}"</programlisting><para>Now, when we are dealing with a Chinese name, you can see that it
    gets composed with the last name first, and no space separating the last
    and first name:</para><programlisting id="I_programlisting7_d1e9363" format="linespecific">data = { given_name: "佳", surname: "吴" }
Gibberish::Simple.use_language(:cn) do
  p T("{given_name} {surname}", [:name, data]) #=&gt; "吴佳"
end</programlisting><para>As you might imagine, this technique can be used to cover a lot of
    ground, providing substantial flexibility in how you display your text
    segments. Not only can each language have its own substitutions for text,
    but it can also control the order in which it is <phrase role="keep-together">presented</phrase>.</para><para>What we’ve covered so far should sufficiently cover most ordinary
    localization needs, so we’ll use this as a convenient stopping point.
    Although I certainly recommend taking a look at <literal moreinfo="none">Gibberish::Simple</literal>, most of the ideas we’ve
    covered here apply to any generalized L10n strategy you might implement.
    When it comes down to it, you need to remember only a few
    things:<indexterm id="I_indexterm7_d1e9376" significance="normal"><primary>L10n (localization)</primary><secondary>guidelines for</secondary></indexterm></para><itemizedlist><listitem><para>The first step in localizing an application is identifying the
        unique text segments that need to be translated.</para></listitem><listitem><para>A generalized L10n system provides a way to keep all
        locale-specific content in translation files rather than tied up in
        the display code of your application.</para></listitem><listitem><para>Every string that gets displayed to the user must be passed
        through a translation filter so that it can be customized based on the
        specified language. In <literal moreinfo="none" role="keep-together">Gibberish::Simple</literal>, we use <literal moreinfo="none">T()</literal> for this; other systems may vary.</para></listitem><listitem><para>Translation should be done at as late a stage as possible, so
        that L10n-related modifications to text do not interfere with the core
        business logic of your program.</para></listitem><listitem><para>In many cases, you cannot simply interpolate strings in a
        predetermined order. <literal moreinfo="none">Gibberish::Simple</literal> offers a simple templating
        mechanism that allows each translation file to specify how substrings
        should be interpolated into a text segment. If you roll your own
        system, be sure to keep this in consideration.</para></listitem><listitem><para>Creating helper functions to simplify your translation code can
        come in handy when generating dynamic text output. For an example of
        this, go back and look at how <literal moreinfo="none">weapon_name()</literal> was used in the simple Sinatra
        example discussed here.</para></listitem><listitem><para>Because adding individual localization tags can be a bit
        tedious, it’s often a good idea to wait until you have a fully
        fleshed-out application before integrating a general L10n system, if
        it is possible to do so.</para></listitem></itemizedlist><para>If you keep these ideas in mind, you’ll have no trouble integrating
    L10n support into your applications. Once a system is in place, it is
    quite cool to see how quickly translation files can change the overall
    interface to support different languages on the fly.<indexterm id="I_indexterm7_d1e9417" class="endofrange" startref="ch07_L10n" significance="normal"/></para></sect1><sect1 id="I_sect17_d1e9418"><title>Conclusions</title><para>The process of multilingualization and localization is something
    that has been overlooked by programmers for far too long. This is mostly
    due to the fact that accomplishing any level of globalized support in
    software systems was until fairly recently a highly complex task. The
    demand for such functionality was also considerably lower before networked
    software dominated our ecosystem, due to the fact that software user bases
    typically were not globalized themselves.</para><para>In 2009, it is a whole different scene. If we want to write software
    that can be used comfortably by people all around the world, we need to
    rise to the occasion and make our code capable of speaking (or at least
    processing) the myriad collection languages that people are comfortable
    with. With Ruby 1.9, we have a powerful system for writing code that
    respects the cultural influences of our users, and we should take
    advantage of it whenever we can. The techniques shown in this chapter will
    help you make your software more accessible, whether it is open source or
    commercial. However, this chapter does not attempt to teach m17n, L10n in
    general, or the gritty details of how everything fits together in the
    context of Ruby. I strongly encourage you to read up on those topics
    before trying to apply any of the ideas you’ve gained here.</para></sect1></chapter><chapter id="I_chapter8_d1e9426"><title>Skillful Project Maintenance</title><para>If you have done any significant amount of software development,
  you’ll know that maintaining other people’s code can be a nightmare. You may
  have noticed that even maintaining your own code can quickly become hellish
  if you are away from a project for more than a few months. On the surface,
  it may seem that any project that is not actively being worked on by its
  original developers is doomed to stagnate.<indexterm class="startofrange" id="ch08_projmaint" significance="normal"><primary>project maintenance</primary></indexterm></para><para>There are ways to fight back against software rot, many of which have
  little to do with the quality of the code itself. Instead, by following some
  conventions as to how you structure your project, you can make it easier to
  navigate. By using lightweight tools, you can simplify automatic generation
  of API documentation, manage dependencies <phrase role="keep-together">and
  custom-built</phrase> software packages, and automate your software build
  process in a <phrase role="keep-together">number of ways</phrase>.</para><para>When you combine the project management utilities Ruby provides (RDoc,
  RubyGems, Rake, etc.) with some basic guidelines for how to lay things out,
  you end up with a powerful advantage. Rather than working around countless
  inconsistencies in overall project organization, you can reuse your
  knowledge from working on other projects to approach new codebases. Nowhere
  is this more valuable than in open source software, in which contributors
  may need to patch code that they have never worked with before.<indexterm id="I_indexterm8_d1e9444" significance="normal"><primary>RubyGems</primary></indexterm><indexterm id="I_indexterm8_d1e9447" significance="normal"><primary>RDoc</primary></indexterm><indexterm id="I_indexterm8_d1e9450" significance="normal"><primary>Rake</primary></indexterm><indexterm id="I_indexterm8_d1e9453" significance="normal"><primary>project management utilities in Ruby</primary></indexterm></para><para>For this reason, we’re going to kick off this chapter with a look at
  the benefits that standards can offer us, through a brief review of the
  conventions used in the Haml project. As we explore its codebase, try to
  imagine yourself as the new maintainer of the project. In that way, we’ll
  see how far our assumptions about the overall structure of a skillfully
  maintained Ruby project can get us.</para><sect1 id="I_sect18_d1e9458"><title>Exploring a Well-Organized Ruby Project (Haml)</title><para>Haml is a clean and powerful XHTML templating engine for Ruby that
    is used by many as an alternative to ERB within web applications. It was
    originally developed by <phrase role="keep-together">Hampton</phrase>
    Catlin and is now actively maintained by Nathan Weizenbaum. Though the
    <phrase role="keep-together">features</phrase> of this library are
    certainly interesting in their own right, we’ll primarily be focusing on
    the aspects of what makes Haml a maintainable project. To do this, we can
    pretend we have no idea what it actually does, and seek to discover a bit
    about these details by exploring the source code itself.<indexterm class="startofrange" id="ch08_projmaintHaml" significance="normal"><primary>project maintenance</primary><secondary>exploring well-organized project</secondary></indexterm><indexterm class="startofrange" id="xh08_Hamlproj" significance="normal"><primary>Haml project</primary></indexterm></para><para>After grabbing the source,<indexterm id="I_indexterm8_d1e9479" significance="normal"><primary>README file</primary><secondary>Haml project</secondary></indexterm><indexterm id="I_indexterm8_d1e9484" significance="normal"><primary>Haml project</primary><secondary>README file</secondary></indexterm><footnote><para>See <ulink url="http://github.com/nex3/haml/tree/master">http://github.com/nex3/haml/tree/master</ulink>.</para></footnote> we can start by looking for a file called
    <filename moreinfo="none">README</filename> or something similar. We find one called
    <filename moreinfo="none">README.rdoc</filename>, which gives us a nice description of why
    we might want to use Haml right at the top of the file:</para><blockquote><para><literal moreinfo="none">Haml and Sass are templating engines for the two most
      common types of documents on the web: HTML and CSS, respectively. They
      are designed to make it both easier and more pleasant to code HTML and
      CSS documents, by eliminating redundancy, reflecting the underlying
      structure that the document represents, and providing elegant, easily
      understandable, and powerful syntax.</literal></para></blockquote><para>The rest of the file fills in other useful details, including how to
    install the library, some usage examples, a list of the executables it
    ships with, and some information on the authors. For a user, this might be
    enough to get up and running with the library. But from our “imaginary new
    maintainer” perspective, one line in the <filename moreinfo="none">README</filename>
    caught my eye: <emphasis>To use Haml and Sass programmatically, check out
    the RDocs for the Haml and Sass modules.</emphasis></para><para>This indicated to me that the project has autogenerated API
    documentation, which is as good a place as any to start when you’re first
    getting to know the low-level details of a project. Noticing the project
    also has a <emphasis>Rakefile</emphasis>, we can check to see whether
    there is a task for generating the documentation:<indexterm id="I_indexterm8_d1e9518" significance="normal"><primary>documentation</primary><secondary>autogenerated API documentation</secondary></indexterm><indexterm id="I_indexterm8_d1e9523" significance="normal"><primary>rake task listing, Haml project</primary></indexterm><indexterm id="I_indexterm8_d1e9526" significance="normal"><primary>Haml project</primary><secondary>autogenerated API documentation</secondary></indexterm><indexterm id="I_indexterm8_d1e9531" significance="normal"><primary>documentation</primary><secondary>autogenerated API documentation</secondary></indexterm></para><screen format="linespecific">sandal:haml $ rake --tasks
(in /Users/sandal/devel/haml)
rake benchmark                 # Benchmark haml against ERb.
rake clobber_package           # Remove package products
rake clobber_rcov              # Remove rcov products for rcov
rake clobber_rdoc              # Remove rdoc products
rake gem                       # Build the gem file haml-2.1.0.gem
rake install                   # Install Haml as a gem.
rake package                   # Build all the packages
rake profile                   # Run a profile of Haml.
rake rcov                      # Analyze code coverage with tests
rake rdoc                      # Build the rdoc HTML Files
rake release                   # Release a new Haml package to Rubyforge.
rake repackage                 # Force a rebuild of the package files
rake rerdoc                    # Force a rebuild of the RDOC files
rake test                      # Run tests / To run with an alternate versi...
rake test:rails_compatibility  # Test all supported versions of rails.</screen><para>Sure enough, midway down the task list, we see <literal moreinfo="none">rake rdoc</literal>. Running this command spits out a
    bunch of noisy output, and then eventually generates some HTML
    documentation in the <emphasis>rdoc/</emphasis> directory. If we open up
    <emphasis>rdoc/index.html</emphasis> in our browser, we can see a complete
    class listing of the project, along with the familiar
    <filename moreinfo="none">README</filename> in HTML format. If we quickly scan the list of
    classes, <literal moreinfo="none">Haml::Engine</literal> is among the most
    interesting, based on name. Pulling up the documentation, we see a brief
    summary of the object along with its methods and attributes (<xref linkend="fig_8-1"/>).<indexterm id="I_indexterm8_d1e9558" significance="normal"><primary>Haml project</primary><secondary>Haml::Engine object and documentation</secondary></indexterm></para><figure float="none" id="fig_8-1"><title>API documentation for Haml::Engine, generated by RDoc</title><mediaobject id="d1e81"><imageobject role="print"><imagedata fileref="figs/print/rubp_0801.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/rubp_0801.png" format="PNG"/></imageobject></mediaobject></figure><para>Clicking on any of the methods in the list will bring us to their
    specific documentation, where we can even view their source, among other
    things. In the interest of peering under the hood, let’s take a look at
    the source. We can see a hint from the RDoc that this library follows a
    common convention, with source files in
    <filename moreinfo="none">lib/module_name/class_name.rb</filename>, which in this case is
    <filename moreinfo="none">lib/haml/engine.rb</filename>.<indexterm id="I_indexterm8_d1e9579" significance="normal"><primary>Haml project</primary><secondary>library layout</secondary></indexterm></para><para>Looking at just the top of the file, we see that the RDoc is
    actually being generated directly from the source:<indexterm id="I_indexterm8_d1e9586" significance="normal"><primary>documentation</primary><secondary>RDoc generated directly from source</secondary></indexterm><indexterm id="I_indexterm8_d1e9591" significance="normal"><primary>RDoc</primary><secondary>generated from source</secondary></indexterm></para><screen format="linespecific">module Haml
  # This is the class where all the parsing and processing of the Haml
  # template is done. It can be directly used by the user by creating a
  # new instance and calling &lt;tt&gt;to_html&lt;/tt&gt; to render the template. For example:
  #
  #   template = File.read('templates/really_cool_template.haml')
  #   haml_engine = Haml::Engine.new(template)
  #   output = haml_engine.to_html
  #   puts output
  class Engine
     #...
  end
end</screen><para>We could read directly through the source now to see which functions
    are most important, but tests often provide a better road map to where the
    interesting parts are. There are a few conventions for how to label test
    files, but the one Haml uses is straightforward and common. We find the
    relevant tests for <literal moreinfo="none">Haml::Engine</literal> in
    <filename moreinfo="none">test/haml/engine.rb</filename>.<indexterm id="I_indexterm8_d1e9607" significance="normal"><primary>documentation</primary><seealso>RDoc</seealso></indexterm><indexterm id="I_indexterm8_d1e9612" significance="normal"><primary>tests</primary><secondary>Haml project</secondary></indexterm></para><para>Although we won’t look through this file in great detail, you’ll
    find that it provides comprehensive testing of the overall templating
    language that <literal moreinfo="none">Haml::Engine</literal> processes.
    The top of the file starts with a couple helpers to keep the tests clean,
    including one that renders Haml to HTML:<indexterm id="I_indexterm8_d1e9622" significance="normal"><primary>Haml project</primary><secondary>tests describing how code is to be used</secondary></indexterm></para><screen format="linespecific">def render(text, options = {}, &amp;block)
  scope  = options.delete(:scope)  || Object.new
  locals = options.delete(:locals) || {}
  engine(text, options).to_html(scope, locals, &amp;block)
end</screen><para>Already this gives us some hints as to how <literal moreinfo="none">Haml::Engine</literal> works. We can see that this helper
    is further aided by another method that initializes the <literal moreinfo="none">Haml::Engine</literal>, which is not particularly
    important for us to look at.<indexterm id="I_indexterm8_d1e9637" significance="normal"><primary>testing</primary><secondary>use in describing how code should be used</secondary></indexterm></para><para>If we look just a little deeper in the file, we start to see how
    <literal moreinfo="none">render()</literal> is being used to generate HTML
    for comparison to the expected values:</para><screen format="linespecific">def test_empty_render_should_remain_empty
  assert_equal('', render(''))
end

def test_attributes_should_render_correctly
  assert_equal("&lt;div class='atlantis' style='ugly'&gt;&lt;/div&gt;",
    render(".atlantis{:style =&gt; 'ugly'}").chomp)
end

def test_ruby_code_should_work_inside_attributes
  author = 'hcatlin'
  assert_equal("&lt;p class='3'&gt;foo&lt;/p&gt;", render("%p{:class =&gt; 1+2} foo").chomp)
end</screen><para>This is just a tiny sampling of what is covered in this test case,
    but it gives you a clear sense of how tests are very useful in describing
    how some code is meant to be used. If we wanted to dig around and make
    some changes to how the code worked, we would first need to verify that
    the tests actually complete successfully. We can use <literal moreinfo="none">rake</literal> again for this. Though the output is a
    little messy, we can see that the whole suite is passing without errors
    upon running the <literal moreinfo="none">rake test</literal>
    command:<indexterm id="I_indexterm8_d1e9657" significance="normal"><primary>Haml project</primary><secondary>verifying successful completion of tests</secondary></indexterm><indexterm id="I_indexterm8_d1e9662" significance="normal"><primary>rake test command</primary></indexterm></para><screen format="linespecific">sandal:haml $ rake test
(in /Users/sandal/devel/haml)
[ file list omitted ]
Started
.................................................................................
.................................................................................
....... merb couldn't be loaded, skipping a test.................................
Finished in 5.031813 seconds.

232 tests, 1812 assertions, 0 failures, 0 errors</screen><para>This tells us that Haml is working fine on our system, at least to
    the extent that the original developers have specified. It is impossible
    to know if tests are truly comprehensive, but by the looks of Haml’s
    tests, which even include examples covering some regressions, you can be
    fairly confident that the tests will provide a decent safety net. By
    looking through these tests, we see that most of them hinge on the
    <literal moreinfo="none">Haml::Engine</literal> constructor, as well as
    the <literal moreinfo="none">Haml::Engine#to_html</literal>
    method.<footnote><para>Which happens to be an alias to <literal moreinfo="none">Haml::Engine#render</literal>, as indicated by the
        RDoc.</para></footnote> Though we won’t get into it here, this seems like a good
    entry point to study if you want to get more familiar with the core of
    Haml’s implementation. Along the way, you will likely encounter new
    objects and methods that you aren’t familiar with. When this happens, go
    back to the tests and API documentation as needed. Repeating this process
    is a surefire way to learn any well-tested library that follows common
    Ruby organizational conventions. But for now, let’s revisit something we
    glossed over a bit earlier.</para><para>When we saw the <literal moreinfo="none">rake task</literal> listing
    earlier, we saw all sorts of different tasks available to us. We covered
    the way to set up a test task in <xref linkend="ch01" xrefstyle="chap-num-title"/>—and we’ll look at the RDoc generation task a
    little later on in this chapter—but one task that is particularly
    interesting is the <literal moreinfo="none">rake install</literal> task,
    which will install Haml as a gem from the current sources. This can be
    very handy for testing your custom modifications locally, so let’s take a
    look at how that works:<indexterm id="I_indexterm8_d1e9692" significance="normal"><primary>rake install task, Haml project</primary></indexterm><indexterm id="I_indexterm8_d1e9695" significance="normal"><primary>Haml project</primary><secondary>rake install task, installing Haml as gem</secondary></indexterm></para><screen format="linespecific">desc "Install Haml as a gem."
task :install =&gt; [:package] do
  sudo = RUBY_PLATFORM =~ /win32/ ? '' : 'sudo'
  gem  = RUBY_PLATFORM =~ /java/  ? 'jgem' : 'gem'
  sh %{#{sudo} #{gem} install --no-ri pkg/haml-#{File.read('VERSION').strip}}
end</screen><para>Here, we see that Haml has provided a Rake task that will install a
    generated gem for you. It is smart about whether or not to use <literal moreinfo="none">sudo</literal>, depending on whether you are running on
    Windows. It also has some provisions built in to check whether you’re
    running on JRuby, where gems are installed via <literal moreinfo="none">jgem</literal> instead of <literal moreinfo="none">gem</literal>. Finally, it just executes a shell command
    in which it reads the current version from a file called <filename role="keep-together" moreinfo="none">VERSION</filename>. As you can see, the contents of
    this file are far from exciting:</para><screen format="linespecific">sandal:haml $ cat VERSION
2.1.0</screen><para>Using this approach, the Rakefile is kept independent of a
    particular version number, allowing a single place for updating version
    numbers. All of these tricks are done in the name of simplifying
    maintainability, making it easy to generate and install the library from
    source for testing.</para><para>Though I’ll cover how to set up gem specs in detail later, we can
    take a quick look at the <literal moreinfo="none">:package</literal> task
    that <literal moreinfo="none">:install</literal> depends on. It is
    actually generated via a utility provided with Rake, called <literal moreinfo="none">Rake::GemPackageTask</literal>:<indexterm id="I_indexterm8_d1e9732" significance="normal"><primary>Haml project</primary><secondary>Rake::GemPackageTask</secondary></indexterm><indexterm id="I_indexterm8_d1e9737" significance="normal"><primary>Rake::GemPackageTask</primary></indexterm></para><screen format="linespecific">require 'rake/gempackagetask'
load    'haml.gemspec'

Rake::GemPackageTask.new(HAML_GEMSPEC) do |pkg|
  if Rake.application.top_level_tasks.include?('release')
    pkg.need_tar_gz  = true
    pkg.need_tar_bz2 = true
    pkg.need_zip     = true
  end
end</screen><para>Here, we see that Haml customizes things a bit by generating zipped
    archives only when the <literal moreinfo="none">:release</literal> task is
    executed. Otherwise, only a gem is produced. This is mainly <phrase role="keep-together">because</phrase> zipped archives are not necessary
    for a local gem install, and Haml uses its <literal moreinfo="none">:package</literal> task both for preparing files for a
    release and for local builds.<indexterm id="I_indexterm8_d1e9753" significance="normal"><primary>Haml project</primary><secondary>zipped archives</secondary></indexterm></para><para>Though we haven’t dug down to actually fix anything in this code
    yet, or make any significant changes, we can see how much decent project
    organization comes into play when it comes to maintainability. Without any
    previous experience with the library, we were able to figure out what it
    is meant to do, saw a few examples of how it worked, generated
    documentation directly from the source that gave us some clues as to what
    the important objects were, and then found tests that described exactly
    how these objects should work.</para><para>We were able to run these tests to verify that the expectations set
    by the project maintainers were being upheld. We also saw how to build and
    install a package from source to be used system-wide via RubyGems. This
    provides us a way to try out our modifications locally before releasing
    the code in the wild, using the same packaging system that Ruby libraries
    are typically distributed through.</para><para>The important thing to remember here is that although Haml is a very
    good example of a Ruby library that is highly consistent with conventions,
    it didn’t invent any of them. In fact, this entire section was written
    based on my previous assumptions on how a well-structured Ruby project
    should operate, based on my experiences working with many popular open
    source codebases. We’ll now move from how this works in other people’s
    code to how you can follow these conventions in your own projects. Once
    those basic ground rules are established, we can move on to specific
    details about how to use tools such as RDoc, RubyGems, and Rake
    effectively to make maintenance much easier.<indexterm id="I_indexterm8_d1e9764" class="endofrange" startref="xh08_Hamlproj" significance="normal"/><indexterm id="I_indexterm8_d1e9765" class="endofrange" startref="ch08_projmaintHaml" significance="normal"/></para></sect1><sect1 id="I_sect18_d1e9766"><title>Conventions to Know About</title><para>When we walked through Haml in the previous example, we could see
    that it had a high degree of discoverability baked in through the
    conventions it uses. Though Ruby is free-form in nature and allows you to
    structure your files in pretty much any way you want, it makes sense to
    standardize in most cases. Making your project easily accessible to your
    users so they can figure out some questions on their own is one of the
    easiest things you can do to make your project more maintainable. Though
    each of the tips in this section may seem a bit trivial, combining them
    can be very powerful.<indexterm class="startofrange" id="ch08_projmaintconvention" significance="normal"><primary>project maintenance</primary><secondary>conventions to know about</secondary></indexterm></para><sect2><title>What Goes in a README</title><para>A somewhat universal software development standard is to have a
      <filename moreinfo="none">README</filename> file that provides a starting point to your
      software. Finding the right balance of information to include in this
      file can be a bit of a challenge.<indexterm class="startofrange" id="ch08_projmaintREADME" significance="normal"><primary>project maintenance</primary><secondary>conventions to know about</secondary><tertiary>README file contents</tertiary></indexterm><indexterm class="startofrange" id="ch08_README" significance="normal"><primary>README file</primary><secondary>contents of</secondary></indexterm></para><para>Minimally speaking, a good <filename moreinfo="none">README</filename> should
      include everything that is necessary to begin working with a project,
      and nothing more. For starters, you’ll need a brief one- or
      two-paragraph description of what the project is for, and what problems
      it is meant to solve. Drawing from another good open source example, we
      can see that the <filename role="keep-together" moreinfo="none">README</filename> for
      James Gray’s HighLine library opens in exactly this way:</para><screen format="linespecific">== Description

Welcome to HighLine.

HighLine was designed to ease the tedious tasks of doing console input and
output with low-level methods like gets() and puts().  HighLine provides a
robust system for requesting data from a user, without needing to code all the
error checking and validation rules and without needing to convert the typed
Strings into what your program really needs.  Just tell HighLine what you're
after, and let it do all the work.</screen><para>Next, it is generally a good idea to point out a couple of the
      core classes that make up the public API of your project. You don’t need
      to be comprehensive here; you just need to point out where the good
      starting points might be for users who wish to browse the API
      documentation:</para><screen format="linespecific">== Documentation

See HighLine and HighLine::Question for documentation.</screen><para>Because sometimes raw API documentation isn’t enough to get people
      started, it’s often a good idea to include a brief synopsis of your
      project’s capabilities through a few simple examples. You probably don’t
      want to get into very complicated needs here, just something to help
      users get their feet wet:</para><screen format="linespecific">== Examples

Basic usage:

  ask("Company?  ") { |q| q.default = "none" }

Validation:

  ask("Age?  ", Integer) { |q| q.in = 0..105 }
  ask("Name?  (last, first)  ") { |q| q.validate = /\A\w+, ?\w+\Z/ }

Type conversion for answers:

  ask("Birthday?  ", Date)
  ask("Interests?  (comma sep list)  ", lambda { |str| str.split(/,\s*/) })

Reading passwords:

  ask("Enter your password:  ") { |q| q.echo = false }
  ask("Enter your password:  ") { |q| q.echo = "x" }

ERb based output (with HighLine's ANSI color tools):

  say("This should be &lt;%= color('bold', BOLD) %&gt;!")

Menus:

  choose do |menu|
    menu.prompt = "Please choose your favorite programming language?  "

    menu.choice(:ruby) { say("Good choice!") }
    menu.choices(:python, :perl) { say("Not from around here, are you?") }
  end

For more examples see the examples/ directory of this project.</screen><para>If your install instructions are simple, you can just embed them
      in your <filename moreinfo="none">README</filename> file directly. However, in the case
      of HighLine, several install methods are supported, and optional
      dependencies enable certain features. For this reason, the
      <filename moreinfo="none">README</filename> simply contains a reference that tells the
      user to look in the <filename moreinfo="none">INSTALL</filename> file. This is what that
      file looks like:<indexterm id="I_indexterm8_d1e9825" significance="normal"><primary>install instructions</primary></indexterm></para><screen format="linespecific">= Installing HighLine

RubyGems is the preferred easy install method for HighLine.  However, you can
install HighLine manually as described below.

== Installing the Gem

HighLine is intended to be installed via the
RubyGems[http://rubyforge.org/projects/rubygems/] system.  To get the latest
version, simply enter the following into your command prompt:

  $ sudo gem install highline

You must have RubyGems[http://rubyforge.org/projects/rubygems/] installed for
the above to work.

== Installing Manually

Download the latest version of HighLine from the
{RubyForge project page}[http://rubyforge.org/frs/?group_id=683].  Navigate to
the root project directory and enter:

  $ sudo ruby setup.rb

== Using termios

While not a requirement, HighLine will take advantage of the termios library if
installed (on Unix).  This slightly improves HighLine's character reading
capabilities and thus is recommended for all Unix users.

If using the HighLine gem, you should be able to add termios as easily as:

  $ sudo gem install termios

For manual installs, consult the termios documentation.</screen><para>Finally, once you’ve told users what your project is, where to
      look for documentation, how it looks in brief, and how to get it
      installed, you’ll want to let them know how to contact you in case
      something goes wrong:</para><screen format="linespecific">== Questions and/or Comments

Feel free to email {James Edward Gray II}[mailto:james@grayproductions.net] or
{Gregory Brown}[mailto:gregory.t.brown@gmail.com] with any questions.</screen><para>In the case of HighLine, we have a very minimal process because
      the library is small and simple. If you’re working on a bigger project,
      this might be the right place to link to a mailing list or bug
      tracker.</para><para>This pretty much sums up everything you need to know to write a
      good <filename moreinfo="none">README</filename>. Although this explanation is
      admittedly not Ruby-specific, it is a skill that helps make even
      in-house projects much more accessible. A decent
      <filename moreinfo="none">README</filename> will instruct other developers about the
      bare minimum details, and get them launched in the right direction for
      working with your code.</para><para>Keep your <filename moreinfo="none">README</filename> short and sweet so that it
      mainly points to information rather than containing a ton of information
      within itself. From a maintainability standpoint, this makes it much
      less likely that your <filename moreinfo="none">README</filename> will become
      out-of-date or irrelevant.<indexterm id="I_indexterm8_d1e9853" class="endofrange" startref="ch08_README" significance="normal"/><indexterm id="I_indexterm8_d1e9854" class="endofrange" startref="ch08_projmaintREADME" significance="normal"/></para></sect2><sect2><title>Laying Out Your Library</title><para>Library files are generally kept in a <filename moreinfo="none">lib/</filename>
      directory. Generally speaking, this directory should only have one file
      in it, and one subdirectory. Earlier when we looked at Haml, we saw that
      the structure was <filename moreinfo="none">lib/haml.rb</filename> and
      <filename moreinfo="none">lib/haml/</filename>. For HighLine, it is
      <filename moreinfo="none">lib/highline.rb</filename> and
      <filename moreinfo="none">lib/highline/</filename>.<indexterm class="startofrange" id="ch08_libraryproj" significance="normal"><primary>library files in projects, directory and file
          structure</primary></indexterm><indexterm class="startofrange" id="ch08_projmaintlib" significance="normal"><primary>project maintenance</primary><secondary>conventions to know about</secondary><tertiary>library layout</tertiary></indexterm></para><para>The Ruby file in your <filename moreinfo="none">lib/</filename> dir should bear
      the name of your project and act as a jumping-off point for loading
      dependencies as well as any necessary support libraries. The top of
      <filename moreinfo="none">lib/highline.rb</filename> provides a good example of
      this:<indexterm class="startofrange" id="ch08_requires" significance="normal"><primary>requires</primary></indexterm><indexterm id="I_indexterm8_d1e9897" significance="normal"><primary>dependencies</primary></indexterm><footnote><para>Documentation omitted to simplify example.</para></footnote></para><screen format="linespecific">#!/usr/local/bin/ruby -w

require "erb"
require "optparse"
require "stringio"
require "abbrev"

require "highline/compatibility"
require "highline/system_extensions"
require "highline/question"
require "highline/menu"
require "highline/color_scheme"

class HighLine
 # ...
end</screen><para>Here we see some of the standard libraries HighLine needs to use,
      as well as the rest of the classes that make up the project. In
      HighLine’s case, there are no deeply nested classes, so most of these
      map directly to class names, such as
      <emphasis>“highline/question”</emphasis> → <literal moreinfo="none">HighLine::Question</literal>. This means that when you
      do a simple <literal moreinfo="none">require "highline"</literal>, all
      the necessary classes to use the library are loaded through this single
      file.</para><para>If you have deeply nested classes in your projects, you will
      typically repeat this process for each level of nesting. Here’s a simple
      abstract example of how that might work:<indexterm id="I_indexterm8_d1e9918" significance="normal"><primary>requires</primary><secondary>deeply nested classes in projects</secondary></indexterm></para><screen format="linespecific"># a.rb
require "a/b"

# a/b.rb

require "a/b/c"
require "a/b/d"

# a/b/c.rb

module A
  module B
    class C
      # ...
    end
  end
end

# a/b/d.rb

module A
  module B
    class D
      #...
    end
  end
end</screen><para>With a file structure as indicated by the comments in the example
      code, and the necessary <literal moreinfo="none">require</literal> statements in place,
      we end up being able to do this:</para><screen format="linespecific">&gt;&gt; require "a"
=&gt; true

&gt;&gt; A::B::C
=&gt; A::B::C

&gt;&gt; A::B::D
=&gt; A::B::D</screen><para>Although this is much more important in large systems than small
      ones, it is a good habit to get into. Essentially, unless there is a
      good reason to deviate, files will often map to class names in Ruby.
      Nested classes that are large enough to deserve their own file should be
      loaded in the file that defines the class they are nested within. Using
      this approach allows the user a single entry point into your library,
      but also allows for running parts of the system in isolation.</para><para>Although these conventions will take you far, in certain cases
      it’s fine to deviate from them. Filenames do not necessarily need to be
      representative of a class at all. For example, in HighLine, we have
      <emphasis>lib/highline/import.rb</emphasis>, which simply injects some
      of HighLine’s functionality into <literal moreinfo="none">Kernel</literal>. This code contains no class
      definitions to speak of. This is essentially organization by concept,
      and can work fine for certain needs. Prawn has a similar feature called
      <filename moreinfo="none">lib/prawn/measurement_extensions.rb</filename>, which adds
      some methods to <literal moreinfo="none">Numeric</literal> for
      simplified PDF point conversions. This is disabled by default, but once
      required, you end up with the following functionality:</para><screen format="linespecific">&gt;&gt; require "prawn/measurement_extensions"
=&gt; true
&gt;&gt; 1.in
=&gt; 72
&gt;&gt; 1.mm
=&gt; 2.83464566929134</screen><para>In the more general case, you might have files that contain
      extensions to provide backward compatibility with Ruby 1.8, or ones that
      make minor changes to core Ruby classes. Decent names for these are
      <emphasis>lib/myproject/compatibility.rb</emphasis> and
      <emphasis>lib/myproject/extensions.rb</emphasis>, respectively. When
      things get complicated, you can of course nest these and work on
      individual classes one at a time. For example, the following extension
      might be called
      <emphasis>lib/myproject/extensions/enumerable.rb</emphasis>:<indexterm id="I_indexterm8_d1e9962" significance="normal"><primary>backward-compatible code, extension files for</primary></indexterm><indexterm id="I_indexterm8_d1e9965" significance="normal"><primary>extension files</primary></indexterm></para><screen format="linespecific">module Enumerable
  def injecting(x)
    inject(x){|a,i| yield(a,i); a }
  end
end</screen><para>However you choose to organize your files, one thing is fairly
      well agreed upon: if you intend to modify core Ruby in any way, you
      should do it in files that are well marked as extension files, to help
      people hunt down changes that might conflict with other packages. Do not
      randomly go about opening core classes in your other library files,
      unless you want to frustrate your users.<indexterm id="I_indexterm8_d1e9972" significance="normal"><primary>extension files</primary></indexterm></para><para>Generally speaking, following sound naming conventions and setting
      up your <literal moreinfo="none">require</literal>s in an organized fashion helps make
      it easier to remember where to find the various classes and modules that
      your project implements. Of course, this should be done in moderation,
      as relatively small projects might meaningfully fit all in one file.
      However, if and when you do decide to break things down, following this
      general approach should serve you well.<indexterm id="I_indexterm8_d1e9980" class="endofrange" startref="ch08_requires" significance="normal"/></para><para>You’ll notice that none of the kinds of files we’ve talked about
      so far are meant to be executed directly. Though scripts and
      applications that are meant to be run directly do not belong in
      <emphasis>lib/</emphasis>, they of course have a home and some basic
      guidelines to follow, so let’s take a closer look at how to work with
      them.<indexterm id="I_indexterm8_d1e9986" class="endofrange" startref="ch08_projmaintlib" significance="normal"/><indexterm id="I_indexterm8_d1e9987" class="endofrange" startref="ch08_libraryproj" significance="normal"/></para></sect2><sect2><title>Executables</title><para>Scripts and applications are usually placed in a
      <emphasis>bin/</emphasis> dir in Ruby projects. These are typically
      ordinary Ruby scripts that have been made executable via something like
      a combination of a shebang line and a <literal moreinfo="none">chmod
      +x</literal> call. To make these appear more like ordinary command-line
      utilities, it is common to omit the file extension. As an example, we
      can take a look at the <literal moreinfo="none">haml</literal>
      executable:<indexterm id="I_indexterm8_d1e10002" significance="normal"><primary>executables</primary></indexterm><indexterm id="I_indexterm8_d1e10005" significance="normal"><primary>project maintenance</primary><secondary>conventions to know about</secondary><tertiary>executables</tertiary></indexterm></para><screen format="linespecific">#!/usr/bin/env ruby
# The command line Haml parser.

$LOAD_PATH.unshift File.dirname(__FILE__) + '/../lib'
require 'haml'
require 'haml/exec'

opts = Haml::Exec::Haml.new(ARGV)
opts.parse!</screen><para>Here we see most of the common conventions for working with Ruby
      scripts in action. You can see that the executable starts with a shebang
      line that indicates how to find the Ruby interpreter. This is followed
      by a line that adds the library to the loadpath by relative positioning.
      Finally, the remaining code simply requires the necessary library files
      and then delegates to an object that is responsible for handling
      command-line requests. Ideally speaking, most of your scripts in
      <emphasis>bin/</emphasis> will follow a similar approach.</para></sect2><sect2><title>Tests</title><para>There are a few common conventions for tests, depending on what
      your needs are. However, among the most straightforward is to simply
      place your tests in a <emphasis>/test</emphasis> folder. For something
      like Prawn, we use the format
      <emphasis>test/test_classname.rb</emphasis>, but omit the <phrase role="keep-together">namespace</phrase>. So for
      <literal moreinfo="none">Prawn::Document</literal>, we have
      <emphasis>test/document_test.rb</emphasis> rather than
      <emphasis>test/prawn_document_test.rb</emphasis>. If you have a project
      that spans multiple namespaces, it’s fine to organize your tests in a
      similar way to libraries. In the Haml library, a tool called Sass is
      also provided, so the test structure includes files like
      <emphasis>test/haml/engine_test.rb</emphasis> and
      <emphasis>test/sass/engine_test.rb</emphasis>, which share the same
      basename but coexist peacefully due to the folder structure.<indexterm id="I_indexterm8_d1e10049" significance="normal"><primary>Sass</primary></indexterm><indexterm id="I_indexterm8_d1e10052" significance="normal"><primary>tests</primary></indexterm><indexterm id="I_indexterm8_d1e10055" significance="normal"><primary>project maintenance</primary><secondary>conventions to know about</secondary><tertiary>tests</tertiary></indexterm></para><para>Consistency in naming of test files is important, because setting
      up files to run an automated test suite often involves matching a
      filename pattern. We’ll get to this a bit later, but it is worth keeping
      in mind.</para><para>Ideally speaking, each individual test case should load a test
      helper file that does the grunt work of requiring all necessary
      libraries and providing supporting functionality as needed. This is done
      via a simple dynamic <literal moreinfo="none">require</literal> relative to the position
      of the current test:</para><screen format="linespecific">require File.dirname(__FILE__) + '/test_helper'</screen><para>The purpose of a <emphasis>test_helpers.rb</emphasis> file is to
      DRY up configuration so that each test case does not begin with a chunk
      of boilerplate code that is repeated again and again. Individual test
      cases of course can have their own specific helpers within them, but
      those that are reused across many of the tests should end up here.
      Although we talk about this in much greater detail in <xref linkend="ch01" xrefstyle="chap-num-title"/>, here’s a quick sample of a
      test helper file from Haml:</para><screen format="linespecific">lib_dir = File.dirname(__FILE__) + '/../lib'
require File.dirname(__FILE__) + '/linked_rails'

require 'test/unit'
$:.unshift lib_dir unless $:.include?(lib_dir)
require 'haml'
require 'sass'

# required because of Sass::Plugin
unless defined? RAILS_ROOT
  RAILS_ROOT = '.'
  MERB_ENV = RAILS_ENV  = 'testing'
end

class Test::Unit::TestCase
  def munge_filename(opts)
    return if opts[:filename]
    test_name = caller[1].gsub(/^.*'(?:\w+ )*(\w+)'.*$/, '\1')
    opts[:filename] = "#{test_name}_inline.sass"
  end
end</screen></sect2><sect2><title>Examples</title><para>In addition to tests, examples form a great way to discover how a
      system works, as well as an extra safety net for detecting regressions.
      Typically, these files will go in an <emphasis role="keep-together">examples/</emphasis> directory.<indexterm class="startofrange" id="ch08_examples" significance="normal"><primary>examples (in projects)</primary></indexterm><indexterm class="startofrange" id="ch08_projmaintexample" significance="normal"><primary>project maintenance</primary><secondary>conventions to know about</secondary><tertiary>examples</tertiary></indexterm></para><para>It is useful to organize these examples by concept, rather than
      class name. As an illustration, here’s what HighLine’s
      <emphasis>examples/</emphasis> directory looks like:</para><screen format="linespecific">$ ls examples/
ansi_colors.rb    limit.rb    password.rb
asking_for_arrays.rb  menus.rb    trapping_eof.rb
basic_usage.rb    overwrite.rb    using_readline.rb
color_scheme.rb    page_and_wrap.rb</screen><para>Each of these names hint at what these examples will demonstrate,
      making it easy for users to find what they are interested in. If you
      have a more complex system, you can use folders to organize your
      examples into groups. Here’s what that approach looks like in
      Prawn:</para><screen format="linespecific">$ ls -R examples/
bounding_box              general      m17n
font_calculations.pdf     graphics      text

examples/bounding_box:
bounding_boxes.rb     russian_boxes.rb

examples/general:
background.rb    measurement_units.rb     page_geometry.rb
canvas.rb        multi_page_layout.rb

examples/graphics:
basic_images.rb    image_flow.rb       remote_images.rb
cmyk.rb            image_position.rb   ruport_style_helpers.rb
curves.rb          line.rb             stroke_bounds.rb
hexagon.rb         png_types.rb
image_fit.rb       polygons.rb

examples/m17n:
chinese_text_wrapping.rb   utf8.rb
euro.rb                    win_ansi_charset.rb
sjis.rb

examples/text:
alignment.rb             font_size.rb      span.rb
dfont.rb                 kerning.rb        text_box.rb
family_based_styling.rb  simple_text.rb    text_flow.rb
font_calculations.rb     simple_text_ttf.rb</screen><para>However you choose to organize your examples, you’ll want to use a
      similar trick to writing your binary files, in that your examples should
      modify the loadpath to include your library based on their relative
      positions. This is to prevent you from having to install your locally
      modified library before running your examples against it. Here’s an
      example from Prawn to see what this looks like:<indexterm id="I_indexterm8_d1e10111" significance="normal"><primary>loadpath for examples</primary></indexterm></para><screen format="linespecific"># encoding: utf-8
#
# Demonstrates how to enable absolute positioning in Prawn by temporarily
# removing the margin_box via Document#canvas()
#
$LOAD_PATH.unshift(File.join(File.dirname(__FILE__), '..', '..', 'lib'))
require "prawn"

Prawn::Document.generate("canvas.pdf") do
  canvas do
    text "This text should appear at the absolute top left"

    # stroke a line to show that the relative coordinates are the same as absolute
    stroke_line [bounds.left,bounds.bottom], [bounds.right,bounds.top]
  end
end</screen><para>There might be some other conventions to be aware of, but the ones
      we’ve covered so far are the most common. Even if they seem a bit dull
      on their own, they really will help make your project maintainable. By
      writing your code in a conventional way, you spare yourself the need to
      write copious documentation about the overall organization of your
      project. Most of the tips here focus on discoverability, which is
      essential for making your project easier for others to maintain, or for
      when you get reassigned to some of your own old code a couple years down
      the line. Here are the key things to remember about the conventions
      we’ve discussed so far:<indexterm id="I_indexterm8_d1e10118" significance="normal"><primary>project maintenance</primary><secondary>conventions to know about</secondary><tertiary>summary of key points</tertiary></indexterm></para><itemizedlist><listitem><para>Every project, large or small, deserves a README file. At a
          minimum, it should include a short description of what the project
          is useful for, a small sampling of code examples that illustrate
          some core features, and some pointers of where to dig deeper if the
          user is interested in learning more. It should also indicate whom to
          contact when something goes wrong, whether it be an individual
          developer or a team that’s operating a mailing list or bug
          tracker.</para></listitem><listitem><para>The key folders to remember are <emphasis>lib/</emphasis>,
          <emphasis>bin/</emphasis>, <emphasis>examples/</emphasis>, and
          <emphasis>test/</emphasis>. Each has its own conventions about what
          it should contain and how it should be organized, which is
          significant both for the sake of consistency and to satisfy various
          other software tools that depend on these conventions.</para></listitem><listitem><para>One thing to remember about files in <emphasis>lib/</emphasis>
          is that you should be sure to explicitly separate out core
          extensions from your main library classes. Instead, keep them in a
          file such as <emphasis>lib/projectname/extensions.rb</emphasis>. If
          you have a lot of extensions, it might make sense to break them out
          class by class, such as
          <filename moreinfo="none">lib/projectname/extensions/string.rb</filename>.</para></listitem><listitem><para>Well-organized tests and examples can go a long way to
          improving the understandability of a project, which, in turn,
          improves the maintainability.</para></listitem><listitem><para>Whether you follow standard Ruby conventions or not in your
          project organization, you should strive to be consistent. The easier
          it is to navigate around a project, the more likely it is that
          you’ll be able to understand it if you have to look at it again a
          few years down the line.</para></listitem><listitem><para>If you plan to distribute your code publicly, be sure to
          include a <filename moreinfo="none">LICENSE</filename> text file, possibly paired
          with a <filename moreinfo="none">COPYING</filename> file if you are offering the GNU
          GPL as a licensing option.<indexterm id="I_indexterm8_d1e10171" class="endofrange" startref="ch08_projmaintexample" significance="normal"/><indexterm id="I_indexterm8_d1e10172" class="endofrange" startref="ch08_examples" significance="normal"/><indexterm id="I_indexterm8_d1e10173" class="endofrange" startref="ch08_projmaintconvention" significance="normal"/></para></listitem></itemizedlist></sect2></sect1><sect1 id="I_sect18_d1e10174"><title>API Documentation via RDoc</title><para>RDoc provides an easy and powerful way to document your Ruby APIs.
    By simply writing comments in your source code with some lightweight
    markup here and there, you can automatically generate comprehensive
    documentation. Of course, a <phrase role="keep-together">documentation</phrase> tool isn’t going to be all
    that useful without some solid guidelines for how functions should
    actually be documented. We’ll cover both RDoc and Ruby documentation best
    practices here, as they complement each other nicely.<indexterm class="startofrange" id="ch08_RDoc" significance="normal"><primary>RDoc</primary><secondary>API documentation via</secondary></indexterm><indexterm class="startofrange" id="ch08_documentation" significance="normal"><primary>documentation</primary></indexterm><indexterm class="startofrange" id="ch08_projmaintdoc" significance="normal"><primary>project maintenance</primary><secondary>API documentation via RDoc</secondary></indexterm></para><sect2><title>Basic Documentation Techniques and Guidelines</title><para>Usually, you’ll want to start off the documentation for any
      function with a short description of what it does. You can then follow
      up with a description of the accepted arguments and any defaults used.
      Finally, if it makes sense to do so, an example or two helps make things
      easier to follow. <xref linkend="fig_8-2"/> shows how we do this for
      the <literal moreinfo="none" role="keep-together">Prawn::Document</literal> constructor
      method.<indexterm id="I_indexterm8_d1e10205" significance="normal"><primary>comments in source code for documentation</primary></indexterm><indexterm id="I_indexterm8_d1e10208" significance="normal"><primary>Prawn::Document, documentation</primary></indexterm><indexterm id="I_indexterm8_d1e10211" significance="normal"><primary>methods</primary><secondary>documentation</secondary></indexterm><indexterm id="I_indexterm8_d1e10216" significance="normal"><primary>functions</primary><secondary>documentation</secondary></indexterm><indexterm class="startofrange" id="ch08_projmaintdocguide" significance="normal"><primary>project maintenance</primary><secondary>API documentation via RDoc</secondary><tertiary>basic documentation guidelines</tertiary></indexterm><indexterm class="startofrange" id="ch08_RDocdoc" significance="normal"><primary>RDoc</primary><secondary>API documentation via</secondary><tertiary>basic documentation guidelines</tertiary></indexterm><indexterm class="startofrange" id="ch08_docbasic" significance="normal"><primary>documentation</primary><secondary>basic techniques and guidelines</secondary></indexterm></para><figure float="none" id="fig_8-2"><title>Sample API documentation of a method from Prawn</title><mediaobject id="d1e621"><imageobject role="print"><imagedata fileref="figs/print/rubp_0802.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/rubp_0802.png" format="PNG"/></imageobject></mediaobject></figure><?dbfo-need height=”1in”
?><para>Although the end result is nicely formatted, it doesn’t take much
      extra work in the source comments to get this sort of output. Here’s
      what the actual code comments that match <xref linkend="fig_8-2"/> look
      like:</para><screen format="linespecific">class Prawn::Document

    # Creates a new PDF Document.  The following options are available:
    #
    # &lt;tt&gt;:page_size&lt;/tt&gt;:: One of the Document::PageGeometry::SIZES [LETTER]
    # &lt;tt&gt;:page_layout&lt;/tt&gt;:: Either &lt;tt&gt;:portrait&lt;/tt&gt; or &lt;tt&gt;:landscape&lt;/tt&gt;
    # &lt;tt&gt;:left_margin&lt;/tt&gt;:: Sets the left margin in points [ 0.5 inch]
    # &lt;tt&gt;:right_margin&lt;/tt&gt;:: Sets the right margin in points [ 0.5 inch]
    # &lt;tt&gt;:top_margin&lt;/tt&gt;:: Sets the top margin in points [ 0.5 inch]
    # &lt;tt&gt;:bottom_margin&lt;/tt&gt;:: Sets the bottom margin in points [0.5 inch]
    # &lt;tt&gt;:skip_page_creation&lt;/tt&gt;:: Toggles manual page creation [false]
    # &lt;tt&gt;:compress&lt;/tt&gt;:: Compresses content streams before rendering them [false]
    # &lt;tt&gt;:background&lt;/tt&gt;:: An image path to be used as background on all pages [nil]
    #
    # Usage:
    #
    #   # New document, US Letter paper, portrait orientation
    #   pdf = Prawn::Document.new
    #
    #   # New document, A4 paper, landscaped
    #   pdf = Prawn::Document.new(:page_size =&gt; "A4", :page_layout =&gt; :landscape)
    #
    #   # New document, with background
    #   img = "#{Prawn::BASEDIR}/data/images/pigs.jpg"
    #   pdf = Prawn::Document.new(:background =&gt; img)
    #
    def initialize
       #...
    end

end</screen><para>As you can see here, we just use a little HTML-style formatting to
      indicate that the options text should be displayed in a fixed-width
      font, then use the <literal moreinfo="none">::</literal> syntax to indicate that this is
      a two-column table. The rest of the text is essentially just plain text.
      Code samples are automatically formatted, as long as they are indented a
      bit from the prose.</para><para>As another example, we can look at some of the API documentation
      from Ruby’s <emphasis>pstore</emphasis> standard library. The one in
      <xref linkend="fig_8-3"/> uses a heading to make the example stand out,
      and it also includes a warning about when using the function is valid
      and the error you will encounter otherwise.<indexterm id="I_indexterm8_d1e10268" significance="normal"><primary>pstore standard library</primary><secondary>API documentation</secondary></indexterm></para><figure float="none" id="fig_8-3"><title>API documentation with a formatted heading</title><mediaobject id="d1e652"><imageobject role="print"><imagedata fileref="figs/print/rubp_0803.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/rubp_0803.png" format="PNG"/></imageobject></mediaobject></figure><para>The comments used to generate this are simple, as you might
      expect:<indexterm id="I_indexterm8_d1e10283" significance="normal"><primary>comments in source code for documentation</primary></indexterm></para><screen format="linespecific"># Ends the current PStore#transaction, discarding any changes to the data
# store.
#
# == Example:
#
#  require "pstore"
#
#  store = PStore.new("data_file.pstore")
#  store.transaction do  # begin transaction
#    store[:one] = 1     # this change is not applied, see below...
#    store[:two] = 2     # this change is not applied, see below...
#
#    store.abort         # end transaction here, discard all changes
#
#    store[:three] = 3   # this change is never reached
#  end
#
# *WARNING*:  This method is only valid in a PStore#transaction.  It will
# raise PStore::Error if called at any other time.
#
def abort
  # ...
end</screen><para>You can see that through simple markup, you can generate nice HTML
      output without sacrificing the readability of the plain text. You might
      have also noticed that RDoc will link together documentation about
      classes or methods in your project without specifying any special
      syntax.</para><para>Although you can get very far with just the basic formatting in
      these two examples, there are times where finer-grained control is
      needed. We’ll now go over a way to give the <literal moreinfo="none">rdoc</literal> generator some hints as to how your code
      and comments should be processed.<indexterm id="I_indexterm8_d1e10296" class="endofrange" startref="ch08_docbasic" significance="normal"/><indexterm id="I_indexterm8_d1e10297" class="endofrange" startref="ch08_RDocdoc" significance="normal"/><indexterm id="I_indexterm8_d1e10298" class="endofrange" startref="ch08_projmaintdocguide" significance="normal"/></para></sect2><sect2><title>Controlling Output with RDoc Directives</title><para>Even if your code is not commented, running RDoc against it will
      generate some useful content that clearly lays out the structure of your
      API. You can get a whole lot more out of it by generating your
      documentation from commented code that includes some light formatting
      syntax. In many cases, the default behaviors for documentation
      generation work well enough, and this is why many people never bother to
      learn about the directives you can use to customize things.<indexterm class="startofrange" id="ch08_docRDoc" significance="normal"><primary>documentation</primary><secondary>API documentation via RDOC</secondary></indexterm><indexterm class="startofrange" id="ch08_projmaintRDocoutput" significance="normal"><primary>project maintenance</primary><secondary>API documentation via RDoc</secondary><tertiary>output control with RDoc directives</tertiary></indexterm><indexterm class="startofrange" id="ch08_RDOCoutput" significance="normal"><primary>RDoc</primary><secondary>API documentation via</secondary><tertiary>controlling output with directives</tertiary></indexterm></para><para>We’ll cover just a few of the things you can do with RDoc
      directives, focusing mainly on the kinds of things I’ve found useful in
      my projects and have seen used effectively in other projects. If you
      want to know the full range of what is available, be sure to consult the
      <ulink url="http://rdoc.rubyforge.org/RDoc.html">RDoc website</ulink>
      for a complete listing.<indexterm id="I_indexterm8_d1e10328" significance="normal"><primary>RDoc</primary><secondary>website</secondary></indexterm></para><para>We’ll start with one of the most simple and common directives
      available, <literal moreinfo="none">:nodoc:</literal>. Although RDoc is
      smart enough to hide private methods, it can’t really make a <phrase role="keep-together">judgment</phrase> call about whether a method
      belongs to the external or internal API of a project. Ideally speaking,
      we want to expose our users only to the functions we intend for them to
      use. By hiding everything that the typical user won’t need to know
      about, we can really cut down on the noise in our
      documentation.<indexterm id="I_indexterm8_d1e10341" significance="normal"><primary sortas="nodoc">:nodoc: directive</primary></indexterm></para><para>Using this directive is easy—just drop it in wherever you want to
      exclude some content from the generated documentation. The most simple
      case is doing this at the method level:</para><screen format="linespecific">class Prawn::Document

  # Stores the current state of the named attributes, executes the block, and
  # then restores the original values after the block has executed.
  #
  def mask(*fields) # :nodoc:
    stored = {}
    fields.each { |f| stored[f] = send(f) }
    yield
    fields.each { |f| send("#{f}=", stored[f]) }
  end

end</screen><para>Here we have a method that is part of the public interface of
      <literal moreinfo="none">Prawn::Document</literal>, but is meant
      primarily for internal use. By adding a <literal moreinfo="none">:nodoc:</literal> comment on the same line as the method
      signature, we can ensure that this method will not appear in the
      generated documentation. We can also use this directive at the
      class/module level:</para><screen format="linespecific"># reference.rb : Implementation of PDF indirect objects

module Prawn

  class Reference #:nodoc:

    # seecrets

  end

end</screen><para>End users of Prawn will likely never need to worry about how we
      implement what are essentially pointers to low-level PDF data
      structures, so we can safely hide this entire class from public view, as
      far as documentation is concerned. Because the syntax is identical to
      skipping the documentation for a function, it is easy to
      remember.</para><para>It may look like the <literal moreinfo="none">:nodoc:</literal>
      directive operates at the block level, hiding everything nested inside a
      class or module. However, this is not the case by default. This means
      that if I had a module called <literal moreinfo="none">Prawn::Reference::Helpers</literal>, it would still be
      documented unless explicitly marked otherwise with a subsequent <literal moreinfo="none">:nodoc:</literal> comment. There is a way to hide
      everything nested within a class, using the <literal moreinfo="none">:nodoc: all</literal> directive, but I would not
      recommend it, as it may accidentally hide worthwhile information.</para><para>It is important use <literal moreinfo="none">:nodoc:</literal>
      with a bit of caution. If you expose too little documentation to your
      users, they may not find the features they need easily enough. Generally
      speaking, you should use <literal moreinfo="none">:nodoc:</literal> only
      on features that are clearly a part of your project’s internals, and not
      on features that might be a bit low-level but could still be potentially
      useful to others. If in doubt, keep your documentation public, putting a
      warning or two in the comments as needed.</para><para>Sometimes you don’t need to outright hide a function’s
      documentation, but rather, just modify it a bit. The following code is
      an example of where this feature comes in handy:</para><screen format="linespecific">class Prawn::Document
  # :call-seq:
  #   bounding_box(point, options={}, &amp;block)
  #
  # A bounding box serves two important purposes:
  # * Provide bounds for flowing text, starting at a given point
  # * Translate the origin (0,0) for graphics primitives, for the purposes
  # of simplifying coordinate math.
  #
  # (rest omitted, as this documentation is pretty lengthy)
  #
  def bounding_box(*args, &amp;block)
    init_bounding_box(block) do
      translate!(args[0])
      @bounding_box = BoundingBox.new(self, *args)
    end
  end
end</screen><para>Here, the <literal moreinfo="none">:call-seq:</literal> hook is
      used to modify what will be displayed as the method signature in the
      documentation. The reason is that the function shown is nothing more
      than a simple wrapper around a constructor for another object. In cases
      like these, it’s best to slurp up all the arguments and pass them along,
      because then the exact signature of the constructor does not need to be
      known.<indexterm id="I_indexterm8_d1e10392" significance="normal"><primary sortas="call-seq directive">:call-seq: directive</primary></indexterm></para><para>However, since documentation involving <literal moreinfo="none">anything(*args, &amp;block)</literal> can be a little
      <phrase role="keep-together">opaque</phrase>, <literal moreinfo="none">:call-seq</literal> gives us a way to give a better hint
      at the interface of our function. In the end result, the documentation
      is displayed as if the method had the signature specified in <literal moreinfo="none">:call-seq:</literal>, so it is completely transparent in
      nature.</para><para>You can also use <literal moreinfo="none">:call-seq:</literal> to
      provide hints at function return values, as you can see in this example
      from Jeremy Hinegardner’s <filename moreinfo="none">hitimes</filename> library:<footnote><para>A high-resolution timer library: <ulink url="http://copiousfreetime.rubyforge.org/hitimes"/>.</para></footnote></para><screen format="linespecific">module Hitimes

  class Timer

    class &lt;&lt; self

      #
      # :call-seq:
      # Timer.now -&gt; Timer
      #
      # Return a newly allocated Timer that has already been started
      #
      def now
        t = Timer.new
        t.start
        return t
      end

      #
      # :call-seq:
      # Timer.measure { ... } -&gt; Float
      #
      # Return the number of seconds that a block of code took to
      # execute.
      #
      def measure( &amp;block )
        Interval.measure { yield }
      end
    end

    # ...
  end
end</screen><para>The <literal moreinfo="none">:call-seq:</literal> directive will
      completely replace the method signature with everything that comes after
      it continuing up until the next blank line. In this way, you can tell
      RDoc exactly how you want your method’s signature to be represented.
      Although this feature is a must-have in certain cases, you can of course
      rely on the defaults in many cases, so your best bet is to try to see
      how things look without <literal moreinfo="none">:call-seq:</literal>
      first and then tweak things as needed.</para><para>The last directive trick I’ll show before we move on provides a
      simple way to group together sets of functions into distinct sections
      within your documentation. This provides a way for RDoc to generate a
      table of contents for navigating your module or class definition.</para><para>The following example shows this directive being used within
      <literal moreinfo="none">Prawn::Measurements</literal>, which supports
      both imperial and metric conversions:</para><screen format="linespecific">module Prawn
  module Measurements

    # -------------------------------------------------------------------
    # :section: Imperial Conversions
    # Convert several metric units to one another and to PDF points
    # -------------------------------------------------------------------

    def ft2in(ft)
      return ft * 12
    end

    def in2pt(inch)
      return inch * 72
    end

    # ...

    # -------------------------------------------------------------------
    # :section: Metric Conversions
    # Convert several metric units to one another and to PDF points
    # -------------------------------------------------------------------

    def cm2mm(cm)
      return cm*10
    end

    def mm2pt(mm)
      return mm*(72 / 25.4)
    end

    # ...
  end
end</screen><para>The <literal moreinfo="none">:section:</literal> directive allows
      you to embed a description of the section that is displayed in the
      generated documentation. To get a sense of how this works, <xref linkend="fig_8-4"/> shows a screenshot of the “Imperial Conversions”
      section.<indexterm id="I_indexterm8_d1e10448" significance="normal"><primary sortas="section directive">:section: directive,
          rdoc</primary></indexterm></para><figure float="none" id="fig_8-4"><title>API documentation with section-based layout</title><mediaobject id="d1e820"><imageobject role="print"><imagedata fileref="figs/print/rubp_0804.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/rubp_0804.png" format="PNG"/></imageobject></mediaobject></figure><para>Grouping by sections in RDoc is a majorly underused feature and
      goes a long way toward making your documentation easy to approach.
      Although not all classes and modules can be meaningfully split up this
      way, it is a really good idea to use this feature if it makes sense to
      do so. Section titles and descriptions can help your users or fellow
      developers pinpoint the parts of a class they are interested in.</para><para>Though we could go on to discuss even more RDoc directives, we’ve
      probably covered enough to get you started. When you put together the
      ideas in this section, you can easily see that Ruby provides a powerful
      documentation system that is easy to work with and use. I have not
      covered the specifics of how the actual <literal moreinfo="none">rdoc</literal> <phrase role="keep-together">command-</phrase>line utility works, as this is
      something you can easily look up. However, we will cover how to build an
      RDoc generation task for Rake a little bit later in this chapter, so be
      sure to look out for that if you want an easy way to automate your
      documentation generation.<indexterm id="I_indexterm8_d1e10470" class="endofrange" significance="normal"/><indexterm id="I_indexterm8_d1e10471" class="endofrange" startref="ch08_RDOCoutput" significance="normal"/></para><para>We’re about to move on to other things, but before we do that,
      here are the key things to remember about RDoc and the process of
      documenting Ruby projects in general:<indexterm id="I_indexterm8_d1e10474" significance="normal"><primary>documentation</primary><secondary>summary of key points</secondary></indexterm></para><itemizedlist><listitem><para>Good documentation provides clear examples of how to use your
          code, clearly documents the interface of your functions, and
          provides enough contextual description to give you a sense of
          whether a given function is going to be useful to you.</para></listitem><listitem><para>Although RDoc’s formatting language is simple and does not
          greatly affect the readability of plain-text comments, it’s worth
          remembering that without a little attention to markup, the RDoc
          generated from your source files may have some minor issues.</para></listitem><listitem><para>Features that are part of the public interface of your project
          but are intended more for internal or specialized use can be hidden
          via the <literal moreinfo="none">:nodoc:</literal> directive, either
          at the function or class/module level.</para></listitem><listitem><para>The <literal moreinfo="none">:call-seq:</literal> method can
          be used to create custom overrides of documented method signatures.
          This can be quite useful for documenting methods with dynamic
          argument processing. It is also useful for indicating what a method
          might return, which is not something RDoc does by default.</para></listitem><listitem><para>Using the <literal moreinfo="none">:section:</literal>
          directive, you can break up the documentation of a class or module
          into distinctly grouped segments, each with an optional description.
          This is a great organizational technique that is severely underused
          at this point in the Ruby community.</para></listitem></itemizedlist><para>So far, we’ve been talking about nuts-and-bolts project
      maintenance techniques that make your project more accessible to others.
      Now, we’ll focus on the task of actually making your code available to
      others, in the form of RubyGems.<indexterm id="I_indexterm8_d1e10506" class="endofrange" startref="ch08_projmaintRDocoutput" significance="normal"/><indexterm id="I_indexterm8_d1e10507" class="endofrange" startref="ch08_projmaintdoc" significance="normal"/><indexterm id="I_indexterm8_d1e10508" class="endofrange" startref="ch08_documentation" significance="normal"/><indexterm id="I_indexterm8_d1e10509" class="endofrange" startref="ch08_RDoc" significance="normal"/></para></sect2></sect1><sect1 id="I_sect18_d1e10510"><title>The RubyGems Package Manager</title><para>When you run code locally, it is possible to take a lot of things
    for granted. You can use various tricks to hack Ruby’s loadpath from the
    command line, count on certain packages being installed, and otherwise
    introduce dependencies on the particular configuration of your
    machine.<indexterm class="startofrange" id="ch08_RubyGemspkg" significance="normal"><primary>RubyGems</primary><secondary>package manager</secondary></indexterm><indexterm class="startofrange" id="ch08_projmaintRG" significance="normal"><primary>project maintenance</primary><secondary>RubyGems package manager</secondary></indexterm></para><para>RubyGems provides a way to help mitigate all these concerns, in the
    form of a full-blown package management system. I assume that everyone who
    is reading this book is familiar with installing software from gems, but
    has not necessarily managed their own gems before. Knowing how to build
    your own packages can be useful, whether you’re distributing open source
    code or just sharing packages within an organization, so we’ll focus on
    that aspect here.</para><sect2><title>Writing a Gem::Specification</title><para>A gem specification (or gemspec) is essentially a project manifest
      with some special metadata that is used at package install time. The
      easiest way to describe how to build a gemspec is by working through a
      real example of one. As we’ve had good luck so far with looking at how
      Haml does things, we can turn to it yet again without being <phrase role="keep-together">disappointed</phrase>:<indexterm class="startofrange" id="ch08_Hamlgemspec" significance="normal"><primary>Haml project</primary><secondary>gem specification (gemspec)</secondary></indexterm><indexterm class="startofrange" id="ch08_gemspec" significance="normal"><primary>gem specification (gemspec)</primary></indexterm><indexterm class="startofrange" id="ch08_projmaintRGgemspec" significance="normal"><primary>project maintenance</primary><secondary>RubyGems package manager</secondary><tertiary>writing gem specification</tertiary></indexterm><indexterm class="startofrange" id="ch08_RGGemSpec" significance="normal"><primary>RubyGems</primary><secondary>package manager</secondary><tertiary>writing Gem::Specification</tertiary></indexterm></para><screen format="linespecific">require 'rubygems'
require 'rake'

HAML_GEMSPEC = Gem::Specification.new do |spec|
  spec.name = 'haml'
  spec.rubyforge_project = 'haml'
  spec.summary = "An elegant, structured XHTML/XML templating engine. " +
                 "Comes with Sass, a similar CSS templating engine."
  spec.version = File.read('VERSION').strip
  spec.authors = ['Nathan Weizenbaum', 'Hampton Catlin']
  spec.email = 'haml@googlegroups.com'
  spec.description = &lt;&lt;-END
      Haml (HTML Abstraction Markup Language) is a layer on top of XHTML or XML
      that's designed to express the structure of XHTML or XML documents
      in a non-repetitive, elegant, easy way,
      using indentation rather than closing tags
      and allowing Ruby to be embedded with ease.
      It was originally envisioned as a plugin for Ruby on Rails,
      but it can function as a stand-alone templating engine.
    END

  # We need the revision file to exist,
  # so we just create it if it doesn't.
  # It'll usually just get overwritten, though.
  File.open('REVISION', 'w') { |f| f.puts "(unknown)" } unless File.exist?('REVISION')
  readmes = FileList.new('*') do |list|
    list.exclude(/(^|[^.a-z])[a-z]+/)
    list.exclude('TODO')
    list.include('REVISION')
  end.to_a
  spec.files = FileList['rails/init.rb', 'lib/**/*', 'bin/*', 'test/**/*',
    'extra/**/*', 'Rakefile', 'init.rb'].to_a + readmes
  spec.executables = ['haml', 'html2haml', 'sass', 'css2sass']
  spec.homepage = 'http://haml.hamptoncatlin.com/'
  spec.has_rdoc = true
  spec.extra_rdoc_files = readmes
  spec.rdoc_options += [
    '--title', 'Haml',
    '--main', 'README.rdoc',
    '--exclude', 'lib/haml/buffer.rb',
    '--line-numbers',
    '--inline-source'
   ]
  spec.test_files = FileList['test/**/*_test.rb'].to_a
end</screen><para>Even if you haven’t built a <literal moreinfo="none">Gem::Specification</literal> before, you’ll note that
      most of these attributes are just routine metadata that is associated
      with any ordinary Ruby project. So let’s break things down and look at
      the more interesting aspects of the specification and what they do.
      We’ll start with the code that indicates what files should be included
      in the gem:</para><screen format="linespecific">File.open('REVISION', 'w') { |f| f.puts "(unknown)" } unless File.exist?('REVISION')
readmes = FileList.new('*') do |list|
  list.exclude(/(^|[^.a-z])[a-z]+/)
  list.exclude('TODO')
  list.include('REVISION')
end.to_a

spec.files = FileList['rails/init.rb', 'lib/**/*', 'bin/*', 'test/**/*',
    'extra/**/*', 'Rakefile', 'init.rb'].to_a + readmes</screen><para>Here we see that Haml is filtering the project files to decide
      which text files it should include as part of the package. These include
      things like <filename moreinfo="none">README.rdoc</filename>, <filename role="keep-together" moreinfo="none">MIT-LICENSE</filename>,
      <filename moreinfo="none">VERSION</filename>, <filename moreinfo="none">FAQ</filename>, and other common
      text files you’ll find littering open source Ruby projects. Using a
      <literal moreinfo="none">FileList</literal> to build up <literal moreinfo="none">readmes</literal> allows files to be automatically
      included based on a naming convention rather than explicitly added to
      the list. After this is done, the <literal moreinfo="none">readmes</literal> list is combined with another <literal moreinfo="none">FileList</literal> that uses globs to pull in all of the
      necessary library, executable, and test files, among other
      things.</para><para>It is important to keep in mind that only files specified in this
      way will be included in a gem, and those that do not match these
      patterns and globs will not be included without modification. If you
      want to see exactly what files were included in any given gem you have
      installed, you can use the <literal moreinfo="none">gem unpack</literal>
      command to dump its source into your working directory, which can be a
      useful way to debug issues with your gem specifications when it comes to
      this particular issue.</para><para>Making sure that your gem knows what files to use is the most
      important thing, but there are other configuration-related issues that
      are useful to deal with as well. If you follow the convention of putting
      your executables in <filename moreinfo="none">bin/</filename>, you can let RubyGems know
      which ones should be accessible from your system path using the
      following bit of code:<indexterm id="I_indexterm8_d1e10603" significance="normal"><primary>executables</primary><secondary>RubyGems</secondary></indexterm></para><screen format="linespecific">spec.executables = ['haml', 'html2haml', 'sass', 'css2sass']</screen><para>This code will properly install your executables in a
      system-independent way, allowing them to work even on the Windows
      command line. On Mac OS X, here’s what I see after installing the Haml
      gem:</para><screen format="linespecific">$ which haml
/usr/local/bin/haml

$ which html2haml
/usr/local/bin/html2haml</screen><para>This is a great feature, because it means that you can easily
      package and distribute not just libraries as RubyGems, but scripts,
      utilities, and applications as well.</para><para>If you want to give your users the opportunity to run your tests
      automatically at install time, you can easily do that as well. We see
      that Haml does this via a simple <literal moreinfo="none">FileList</literal> that describes the naming convention
      of its tests:<indexterm id="I_indexterm8_d1e10622" significance="normal"><primary>spec.test_files</primary></indexterm><indexterm id="I_indexterm8_d1e10625" significance="normal"><primary>tests</primary><secondary>RubyGems gemspec</secondary></indexterm></para><screen format="linespecific">spec.test_files = FileList['test/**/*_test.rb'].to_a</screen><para>This feature can be a little tricky to get right, and as it turns
      out <literal moreinfo="none">gem install haml</literal> <literal role="keep-together" moreinfo="none">--tests</literal> does not work properly on my
      machine, due to some dependency-related issues. In order for this
      feature to work properly, you need to be very explicit about your
      dependencies and very disciplined about the assumptions you make
      regarding your current <literal moreinfo="none">$LOAD_PATH</literal>. I
      include a mention of it here because it is a solid practice when done
      right—but with the warning that the vast majority of RubyGems do not
      handle this properly, whether or not they include this line in their
      gemspec.</para><para>The last interesting thing about this particular gem specification
      is that it provides some information about how its RDoc should be
      rendered. If you didn’t already know about it, RubyGems ships with a gem
      hosting/documentation server that can list all of the API documentation
      for your installed gems. This is usually fired up via the <literal moreinfo="none">gem server</literal> command, which will start a service
      that is accessible at <filename moreinfo="none">http://localhost:8808</filename>. By
      specifying some details about whether and how this RDoc should be
      generated in your gemspec, you can control what your users will end up
      seeing. Here are the RDoc-<phrase role="keep-together">related</phrase>
      lines from the Haml gemspec:<indexterm id="I_indexterm8_d1e10654" significance="normal"><primary>RDoc</primary><secondary>generation of, details in gemspec</secondary></indexterm></para><screen format="linespecific">spec.has_rdoc = true
spec.extra_rdoc_files = readmes
spec.rdoc_options += [
  '--title', 'Haml',
  '--main', 'README.rdoc',
  '--exclude', 'lib/haml/buffer.rb',
  '--line-numbers',
  '--inline-source'
 ]</screen><para>The first line here indicates that the gem does ship with a
      meaningful RDoc, allowing it to be generated for viewing from the gem
      server. The next line indicates that there are some extra files that
      should be included; by default, only files in <filename moreinfo="none">lib/</filename>
      will be processed. Finally, an array of raw options are specified to be
      passed along to the underlying <literal moreinfo="none">rdoc</literal>
      executable on the user’s system. I won’t cover these in detail, but they
      should be fairly self-explanatory.</para><para>Now that we’ve covered most of the interesting aspects of a
      <literal moreinfo="none">Gem::Specification</literal>, we can briefly
      mention how to build a gem. We showed earlier how to do this via a
      custom Rake task, but in case you want to build a standalone gem, here’s
      a quick example:<indexterm id="I_indexterm8_d1e10674" significance="normal"><primary>gems, building standalone</primary></indexterm></para><screen format="linespecific">$ gem build haml.gemspec
Successfully built RubyGem
Name: haml
Version: 2.1.0
File: haml-2.1.0.gem</screen><para>Once you have a gem in hand, you can pass it around for direct
      installation from file, host it locally via <literal moreinfo="none">gem
      server</literal> by simply installing it yourself, or upload it to a
      distributor such as RubyForge or GitHub for an open source
      release.<indexterm id="I_indexterm8_d1e10684" class="endofrange" startref="ch08_Hamlgemspec" significance="normal"/></para><para>If your gem does not depend on other Ruby libraries, you’re pretty
      much all set at this point. However, many times we build our libraries
      and applications on top of other, lower-level libraries. In those cases,
      we don’t want to force our users to manually install all the
      dependencies they’ll need. Luckily, RubyGems makes it easy to work
      around this.<indexterm id="I_indexterm8_d1e10687" class="endofrange" startref="ch08_gemspec" significance="normal"/><indexterm id="I_indexterm8_d1e10688" class="endofrange" startref="ch08_projmaintRGgemspec" significance="normal"/><indexterm id="I_indexterm8_d1e10689" class="endofrange" startref="ch08_RGGemSpec" significance="normal"/></para></sect2><sect2><title>Working with Dependencies</title><para>Manual dependency resolution can be hellish to deal with. However,
      if we configure things properly, end users should never need to think
      much about the dependencies of the gems they install. This is done
      through direct dependency mapping within a gemspec. An interesting
      application of this is in the <emphasis>prawn</emphasis> gem, which is
      really nothing more than a stub that indicates which subpackages need to
      be installed to have a full Prawn installation up and running:<indexterm class="startofrange" id="ch08_prawngem" significance="normal"><primary>prawn gem, dependencies</primary></indexterm><indexterm class="startofrange" id="ch08_gemspecdepend" significance="normal"><primary>gem specification (gemspec)</primary><secondary>dependencies</secondary></indexterm><indexterm class="startofrange" id="ch08_dependencies" significance="normal"><primary>dependencies</primary><secondary>working with in RubyGems</secondary></indexterm><indexterm class="startofrange" id="ch08_projmaintRGdepend" significance="normal"><primary>project maintenance</primary><secondary>RubyGems package manager</secondary><tertiary>dependencies</tertiary></indexterm><indexterm class="startofrange" id="ch08_RGdepend" significance="normal"><primary>RubyGems</primary><secondary>package manager</secondary><tertiary>dependencies</tertiary></indexterm></para><screen format="linespecific">Gem::Specification.new do |spec|
  spec.name = "prawn"
  spec.version = "0.5.0"
  spec.platform = Gem::Platform::RUBY
  spec.summary = "A fast and nimble PDF generator for Ruby"
  spec.add_dependency('prawn-core', '~&gt; 0.5.0')
  spec.add_dependency('prawn-layout', '~&gt; 0.2.0')
  spec.add_dependency('prawn-format', '~&gt; 0.1.0')
  spec.author = "Gregory Brown"
  spec.email = "gregory.t.brown@gmail.com"
  spec.rubyforge_project = "prawn"
  spec.homepage = "http://prawn.majesticseacreature.com"
  spec.description = "Prawn is a fast, tiny, and nimble PDF generator for Ruby"
end</screen><para>In this example, only three lines are of particular
      interest:</para><screen format="linespecific">spec.add_dependency('prawn-core', '~&gt; 0.5.0')
spec.add_dependency('prawn-layout', '~&gt; 0.2.0')
spec.add_dependency('prawn-format', '~&gt; 0.1.0')</screen><para>In this example, we are indicating that in order to install
      <emphasis>prawn</emphasis>, three other gems need to be installed:
      <emphasis>prawn-core</emphasis>, <emphasis>prawn-layout</emphasis>, and
      <emphasis>prawn-format</emphasis>. Here we are using what is called a
      pessimistic version constraint, to help ensure that the versions we
      install are compatible with one another.</para><para>The way it works is that when you use <literal moreinfo="none">~&gt;</literal>, you are indicating that your gem will
      work with any version within a certain line of releases. We could
      actually rewrite the specification in a more explicit way:</para><screen format="linespecific">spec.add_dependency('prawn-core',   '&gt;= 0.5.0', '&lt; 0.6.0')
spec.add_dependency('prawn-layout', '&gt;= 0.2.0', '&lt; 0.3.0')
spec.add_dependency('prawn-format', '&gt;= 0.1.0', '&lt; 0.2.0')</screen><para>This would mean the same exact thing, but requires a lot more
      typing. So essentially, what this operator offers is a little
      flexibility in your last version number. You could actually be even more
      flexible with this, where <literal moreinfo="none">~&gt;</literal> 1.0 means any
      1.<emphasis>x</emphasis>.<emphasis>y</emphasis> version.<indexterm id="I_indexterm8_d1e10763" significance="normal"><primary>versioning</primary><secondary>specifying in dependencies</secondary></indexterm></para><para>Because every project is maintained in a different way, the right
      string to use depends highly on individual release policies. In the case
      of Prawn, we guarantee that our officially supported gems will not
      change API at all from <literal moreinfo="none">x.y.z</literal> to
      <literal moreinfo="none">x.y.(z+1)</literal>, but that API changes are
      possible when the middle version number changes. Therefore, our gem
      specifications are tailored to fit to that maintenance strategy.</para><para>In other situations, you may want to go to one extreme or another
      regarding versioning. For example, you can lock to an exact version of a
      gem:</para><screen format="linespecific">spec.add_dependency('ruport', '=1.0.0')</screen><para>If you have this in your gemspec, Ruport 1.0.0 will be installed
      specifically, and when your library is loaded or an executable is used,
      you can be sure that exact version of the dependency will be loaded as
      well. Although this is the best way to be absolutely sure your code will
      work the same on your system as it will on others, it is also quite
      constraining. RubyGems is not currently capable of activating more than
      one version of a library simultaneously, so this means that you may
      introduce some conflicts with other packages that rely on different
      versions of your dependencies. Generally speaking, unless there is a
      very good reason for specifying an exact dependency version, you should
      be a bit more lenient, allowing the user to lock down to a particular as
      necessary via the <literal moreinfo="none">Kernel#gem</literal>
      method.<indexterm id="I_indexterm8_d1e10786" significance="normal"><primary>Kernel#gem method</primary></indexterm></para><para>On the other end of the spectrum, it is also possible to specify a
      dependency without any version at all:</para><screen format="linespecific">spec.add_dependency('highline')</screen><para>When you do this, your gem will only check to make sure the
      dependency is installed, and will do absolutely no version checking.
      This means that if the installed version of a gem on a user’s system is
      ancient or bleeding edge while yours is somewhere in between, some
      conflicts may arise. Of course, this does put the power back in the
      user’s hands. The important thing to remember if you go this route is to
      clearly document which versions of your dependencies are required, but
      at that point, you might as well just go ahead and use either version
      ranges or pessimistic version constraints.</para><para>That having been said, this feature can be quite useful in alpha-
      or beta-level projects that have not yet solidified what exact versions
      of various libraries they will depend on, as it allows for the greatest
      level of control from the end user perspective.</para><para>A final note about developing gem specifications is that
      occasionally, some extra libraries are needed for development but not
      for actually running your software. RubyGems allows you to specify
      development dependencies that can be installed alongside the runtime
      dependencies via the <literal moreinfo="none">gem install whatever
      --development</literal> command. This can be useful for helping
      potential contributors get set up with all the necessary tools they’ll
      need for building your project and running its tests.<indexterm id="I_indexterm8_d1e10802" significance="normal"><primary>runtime dependencies</primary></indexterm><indexterm id="I_indexterm8_d1e10805" significance="normal"><primary>development dependencies</primary></indexterm></para><para>At the time of writing this chapter, we haven’t set this up yet in
      the <emphasis>prawn</emphasis> gem, but if we do, it’ll end up looking
      something like this:</para><screen format="linespecific">spec.add_runtime_dependency('prawn-core', '~&gt; 0.5.0')
spec.add_runtime_dependency('prawn-layout', '~&gt; 0.2.0')
spec.add_runtime_dependency('prawn-format', '~&gt; 0.1.0')

spec.add_development_dependency('test-unit', '= 1.2.3')
spec.add_development_dependency('test-spec', '~&gt; 0.9.0')
spec.add_development_dependency('mocha', '~&gt; 0.9.0')</screen><para>In this code, <literal moreinfo="none">add_runtime_dependency</literal> is just an alias for
      <literal moreinfo="none">add_dependency</literal>, but it provides a
      clearer indication of which dependencies are meant for runtime and which
      are solely for development. If we specified our gem in this way,
      <emphasis>prawn-core</emphasis>, <emphasis>prawn-layout</emphasis>, and
      <emphasis>prawn-format</emphasis> would always be installed, but
      <emphasis>test-unit</emphasis>, <emphasis>test-spec</emphasis>, and
      <emphasis>mocha</emphasis> would be installed only if the <literal moreinfo="none">--development</literal> flag were used. Development
      dependencies are a great idea and are fairly new in RubyGems, so with a
      little luck, more projects will start using them in the
      future.<indexterm id="I_indexterm8_d1e10845" class="endofrange" startref="ch08_prawngem" significance="normal"/><indexterm id="I_indexterm8_d1e10846" class="endofrange" startref="ch08_gemspecdepend" significance="normal"/><indexterm id="I_indexterm8_d1e10847" class="endofrange" startref="ch08_RGdepend" significance="normal"/><indexterm id="I_indexterm8_d1e10849" class="endofrange" startref="ch08_projmaintRGdepend" significance="normal"/><indexterm id="I_indexterm8_d1e10850" class="endofrange" startref="ch08_dependencies" significance="normal"/></para><para>There is a ton more we could discuss about the RubyGems system,
      but my goal was to expose you only to the things you’ll need to know to
      package your code up and start sharing it with others, whether between
      coworkers or with the Ruby community at large. I’ve tried to cover some
      of the features that first-time gem builders typically miss out on, in
      hopes that we can take better advantage of the full-blown package
      management system Ruby provides us. Here are the key things to
      remember:<indexterm id="I_indexterm8_d1e10853" significance="normal"><primary>project maintenance</primary><secondary>RubyGems package manager</secondary><tertiary>summary of key points</tertiary></indexterm><indexterm id="I_indexterm8_d1e10860" significance="normal"><primary>RubyGems</primary><secondary>package manager</secondary><tertiary>summary of key points</tertiary></indexterm></para><itemizedlist><listitem><para>Gems do not automatically include certain files or folders
          within a project. Instead, it is necessary to list explicitly in
          your gemspec which files should be included. In most cases, a
          <literal moreinfo="none">FileList</literal> is useful for
          aggregation here, which can be used by simply requiring the
          <emphasis>rake</emphasis> library.</para></listitem><listitem><para>You can specify which scripts in your gem are executable, and
          RubyGems will take care of putting these executables in the right
          place on your system, setting up proper file modes regardless of
          what operating system you are on.</para></listitem><listitem><para>If you enable RDoc generation, your gem will automatically
          generate its documentation upon install on a user’s machine,
          viewable through a locally running <literal moreinfo="none">gem
          server</literal>.</para></listitem><listitem><para>A severely underused feature is <literal moreinfo="none">spec.test_files</literal>, but special care must be
          given to both dependency specification and loadpath hackery to make
          it work properly.</para></listitem><listitem><para>RubyGems provides a fairly robust solution for dependency
          resolution that provides a high degree of flexibility when it comes
          to deciding how strict to be about versioning for any library your
          package depends on.</para></listitem><listitem><para>If your project has development-specific dependencies that are
          not needed at <phrase role="keep-together">runtime</phrase>, add
          them to your gemspec via <literal moreinfo="none">spec.add_development_dependency()</literal>.</para></listitem></itemizedlist><para>We’ve talked about organizing, documenting, and packaging your
      code. Now it’s time to talk about how to manage these tasks all in one
      place.<indexterm id="I_indexterm8_d1e10907" class="endofrange" startref="ch08_projmaintRG" significance="normal"/><indexterm id="I_indexterm8_d1e10908" class="endofrange" startref="ch08_RubyGemspkg" significance="normal"/></para></sect2></sect1><sect1 id="I_sect18_d1e10909"><title>Rake: Ruby’s Built-in Build Utility</title><para>We already covered a bit about Rake in the very beginning of this
    chapter. I am also quite sure that anyone who would buy this book at least
    knows what a Rakefile is and has probably used one before. This toolkit
    was initially popular among project maintainers for simplifying package
    and documentation generation, but was popularized by Rails as a way to
    wrap pretty much any task into something that could be conveniently
    triggered on the command line. Although <literal moreinfo="none">rake</literal> technically is little more than a Ruby
    replacement for <literal moreinfo="none">make</literal>, the flexibility
    of configuring it via a general-purpose language such as Ruby has really
    made it a powerful tool.<indexterm class="startofrange" id="ch08_projmaintRake" significance="normal"><primary>project maintenance</primary><secondary>Rake</secondary></indexterm><indexterm class="startofrange" id="ch08_Rake" significance="normal"><primary>Rake</primary></indexterm></para><para>We already covered some of the built-in features of Rake, including
    <literal moreinfo="none">Rake::GemPackageTask</literal>, but let’s take a
    look at another one. The following code is what Haml uses to provide a
    <literal moreinfo="none">rake rdoc</literal> task:<indexterm id="I_indexterm8_d1e10936" significance="normal"><primary>Rake</primary><secondary>rake rdoc task</secondary></indexterm><indexterm id="I_indexterm8_d1e10941" significance="normal"><primary>Haml project</primary><secondary>Rake::RDocTask</secondary></indexterm></para><screen format="linespecific">Rake::RDocTask.new do |rdoc|
  rdoc.title    = 'Haml/Sass'
  rdoc.options &lt;&lt; '--line-numbers' &lt;&lt; '--inline-source'
  rdoc.rdoc_files.include(*FileList.new('*') do |list|
                            list.exclude(/(^|[^.a-z])[a-z]+/)
                            list.exclude('TODO')
                          end.to_a)
  rdoc.rdoc_files.include('lib/**/*.rb')
  rdoc.rdoc_files.exclude('TODO')
  rdoc.rdoc_files.exclude('lib/haml/buffer.rb')
  rdoc.rdoc_files.exclude('lib/sass/tree/*')
  rdoc.rdoc_dir = 'rdoc'
  rdoc.main = 'README.rdoc'
end</screen><?dbfo-need height=”2in”
?><para>Here we see that the options used are very similar to what we
    discussed in the previous section about RubyGems. However, once this is
    set up, you can simply type <literal moreinfo="none" role="keep-together">rake rdoc</literal> at any time to generate the API
    documentation directly from the current source code. This does not require
    installing the library or running a long string of command-line arguments,
    which are the two main reasons it is beneficial to us. When we used this
    command earlier, we didn’t need to know a thing about it; we were able to
    just know what it did and execute it based on the <literal moreinfo="none">rake
    --tasks</literal> listing for the project.</para><para>Rake provides a great way to increase the discoverability of your
    project, in that it allows users who do not necessarily understand the
    details about the underlying processes to do administrative tasks. Any
    shell scripts to maintain projects are ripe candidates for being wrapped
    with Rake.<indexterm id="I_indexterm8_d1e10959" significance="normal"><primary>Rake</primary><secondary>rake build command</secondary></indexterm></para><para>To give you an example of how you’d use this for custom needs, I can
    show you what I use to generate a local copy of this book in PDF format. I
    have been writing it in AsciiDoc and generating DocBook XML. I then use
    <literal moreinfo="none">dblatex</literal> to render a PDF for me. Rather
    than remember all the details of how to do this, I much prefer to type the
    following command whenever I want a new build of my book:<indexterm id="I_indexterm8_d1e10969" significance="normal"><primary>Rake</primary><secondary>custom tasks</secondary></indexterm></para><screen format="linespecific">rake build</screen><para>Here’s the pair of tasks that makes it possible for me to do
    this:<footnote><para>The <literal moreinfo="none">convert_all</literal> task was
        actually based on a contribution Rick DeNatale made to my build
        process for <citetitle><ulink url="http://ruportbook.com/">The Ruport
        Book</ulink></citetitle>.</para></footnote></para><screen format="linespecific">task :convert_all do
  FileList[File.join(File.dirname(__FILE__), 'manuscript', '*.txt')].each do |src|
    target = File.join target_dir, File.basename(src).sub(".txt", ".xml")
    chap = File.basename(target)
    sh "asciidoc -d book -b docbook -a sectids! -o ch_#{chap} -s #{src}"
  end
end

task :build =&gt; [:convert_all] do
  sh "dblatex book.xml"
  sh "open book.pdf"
end</screen><para>These tasks yet again make gratuitous use of <literal moreinfo="none">FileList</literal> for doing glob-based filtering of a
    directory. In <literal moreinfo="none">:convert_all</literal>, we are
    taking all the <filename moreinfo="none">.txt</filename> files in a manuscript/directory
    and running them through <literal moreinfo="none">asciidoc</literal> to
    generate DocBook XML. Our <literal moreinfo="none">:build</literal> task
    depends on <literal moreinfo="none">convert_all</literal>, which ensures
    that new XML documents are generated from the text-based sources every
    time we end up building a PDF. The PDF is generated by
    <literal moreinfo="none">dblatex</literal> and then displayed in OS X Preview via the
    <literal moreinfo="none">open</literal> command.</para><para>This is just one example of a custom Rake task, but there are
    endless possibilities. Heading back to the Haml Rakefile, we can see that
    the developers even use Rake to manage pushing releases out to RubyForge
    using the <literal moreinfo="none">rubyforge</literal> command-line
    utility:<indexterm id="I_indexterm8_d1e11023" significance="normal"><primary>Rake</primary><secondary>rubyforge command-line utility</secondary></indexterm><footnote><para>See <ulink url="http://rubyforge.org/projects/codeforpeople">http://rubyforge.org/projects/codeforpeople</ulink>.</para></footnote></para><?dbfo-need height=”1in”
?><screen format="linespecific">desc "Release a new Haml package to Rubyforge. Requires the NAME and VERSION flags."
task :release =&gt; [:package] do
  name, version = ENV['NAME'], ENV['VERSION']
  package = "#{ENV['NAME']} (v#{ENV['VERSION']})"
  sh %{rubyforge login}
  sh %{rubyforge add_release haml haml "#{package})" pkg/haml-#{version}.gem}
  sh %{rubyforge add_file haml haml "#{package}" pkg/haml-#{version}.tar.gz}
  sh %{rubyforge add_file haml haml "#{package}" pkg/haml-#{version}.tar.bz2}
  sh %{rubyforge add_file haml haml "#{package}" pkg/haml-#{version}.zip}
end</screen><para>In HighLine, we also used Rake to upload our website and
    documentation for the project via <literal moreinfo="none">scp</literal>:<indexterm id="I_indexterm8_d1e11042" significance="normal"><primary>Rake</primary><secondary>uploading website documentation via scp</secondary></indexterm></para><screen format="linespecific">desc "Upload current documentation to Rubyforge"
task :upload_docs =&gt; [:rdoc] do
  sh "scp -r doc/html/* " +
     "bbazzarrakk@rubyforge.org:/var/www/gforge-projects/highline/doc/"
  sh "scp -r site/* " +
     "bbazzarrakk@rubyforge.org:/var/www/gforge-projects/highline/"
end</screen><para>As you can see, a well-tuned Rakefile is an asset to have in any
    project. If you want to use tasks from a number of sources, or have a
    large number of tasks that might end up causing name clashes, you can even
    use namespaces to segment things out. Though I’ll leave the details for
    the reader to discover, the basic syntax looks like this:<indexterm id="I_indexterm8_d1e11051" significance="normal"><primary>namespaces</primary><secondary>using to segment Rake tasks</secondary></indexterm><indexterm id="I_indexterm8_d1e11056" significance="normal"><primary>Rake</primary><secondary>Rakefiles</secondary></indexterm></para><screen format="linespecific">namespace :site do
  task :generate do
    puts "Generating site"
  end
end

namespace :docs do
  task :generate do
    puts "Generating Documents"
  end
end</screen><para>Here’s how you’d run each of these tasks on the command line:</para><screen format="linespecific">$ rake site:generate
(in /Users/sandal)
Generating site

$ rake docs:generate
(in /Users/sandal)
Generating Documents</screen><para>Of course, if you only have a few tasks that aren’t very related to
    one another, there is no need to worry about namespacing. Unless you are
    managing a fairly large number of tasks, or redistributing tasks as part
    of a library, you can stick to the basics.</para><?dbfo-need height=”1in”
?><para>Rake is a very powerful tool that deserves its own chapter or even
    its own cookbook. There are a ton of useful recipes out there in the wild,
    so be sure to make the Rakefile one of your first stops in any new
    codebase you need to review. Understanding and using Rake effectively is
    key to successfully managing any moderately complex Ruby project, so be
    sure not to overlook its significance and practical utility.</para><para>If you want to make the most out of this tool, there are just a few
    things to keep in mind:<indexterm id="I_indexterm8_d1e11075" significance="normal"><primary>Rake</primary><secondary>summary of key points</secondary></indexterm></para><itemizedlist><listitem><para>Rake provides custom tasks for common needs such as generating
        RDoc, running unit tests and packaging up a project for distribution.
        Because these tasks are highly configurable, it is better to use them
        than to reinvent the wheel.</para></listitem><listitem><para>Any other repetitive action that is necessary for maintaining
        your project can be wrapped in a task to simplify things. Typically,
        any lengthy command that needs to be run in the shell is fair game for
        this sort of simplification.</para></listitem><listitem><para>Any task that has a preceding <literal moreinfo="none">desc()</literal> call will be listed with a meaningful
        message in the <literal moreinfo="none">rake --tasks</literal> output
        for your project.</para></listitem><listitem><para>Rake’s ability to define prerequisite tasks allows you to build
        dependency-based workflows that allow you to model multiple-step tasks
        as needed.</para></listitem><listitem><para>Namespaces can be used to segment off tasks into their own
        subspaces, minimizing the risk of naming clashes.</para></listitem></itemizedlist><para>I’ve tried to stick mainly to the easily overlooked aspects of Rake
    here, but there is a whole lot that we could have covered and didn’t. Be
    sure to consult the Rake documentation if you’re interested in finding out
    more.<indexterm id="I_indexterm8_d1e11104" class="endofrange" startref="ch08_Rake" significance="normal"/><indexterm id="I_indexterm8_d1e11105" class="endofrange" startref="ch08_projmaintRake" significance="normal"/></para></sect1><sect1 id="I_sect18_d1e11106"><title>Conclusions</title><para>Depending on what you were looking for, this chapter may have been a
    bit different from what you were expecting based on the title. However,
    what you will find is that the things we’ve discussed here will really
    take you far when it comes to improving the maintainability of your
    projects. Though far from glamorous, things like good documentation,
    well-organized folders and files, and a way to automate as much of the
    grunt work as possible does a whole lot for your projects.</para><para>Poorly maintained projects can be a huge drain on developer
    productivity and morale, yet nicely curated code can be downright
    enjoyable to work with, even if you’re brand-new to a project. The tools
    and techniques we’ve discussed so far aren’t going to make maintenance
    completely painless, but will still provide a solid foundation to work off
    of that will grow over time.</para><para>We’ve now reached the end of the last official chapter in this book.
    However, I hope that you will not stop here, as there are still three very
    useful appendixes left for your enjoyment. If you turn the page, you’ll
    notice that these aren’t simply tables of reference data for looking up,
    but instead, tightly packed bundles of bonus material that didn’t quite
    fit into the main flow of the book. There is still a ton of real code left
    to walk through in the book, so if you put it down now, you’d be
    short-changing yourself.</para><para>Whether you continue to read on or not, I hope you have enjoyed what
    you have read so far, and that you can put it into practice in your
    day-to-day work.<indexterm id="I_indexterm8_d1e11117" class="endofrange" startref="ch08_projmaint" significance="normal"/></para></sect1></chapter><appendix id="appa"><title>Writing Backward-Compatible Code</title><para>Not everyone has the luxury of using the latest and greatest tools
  available. Though Ruby 1.9 may be gaining ground among developers, much
  legacy code still runs on Ruby 1.8. Many folks have a responsibility to keep
  their code running on Ruby 1.8, whether it is in-house, open source, or a
  commercial application. This appendix will show you how to maintain backward
  compatibility with Ruby 1.8.6 without preventing your code from running
  smoothly on Ruby 1.9.1.<indexterm class="startofrange" id="appa_backward" significance="normal"><primary>backward-compatible code, writing</primary></indexterm></para><para>I am assuming here that you are backporting code to Ruby 1.8, but this
  may also serve as a helpful guide as to how to upgrade your projects to
  1.9.1. That task is somewhat more complicated however, so your mileage may
  vary.</para><para>The earlier you start considering backward compatibility in your
  project, the easier it will be to make things run smoothly. I’ll start by
  showing you how to keep your compatibility code manageable from the start,
  and then go on to describe some of the issues you may run into when
  supporting Ruby 1.8 and 1.9 side by side.</para><para>Please note that when I mention 1.8 and 1.9 without further
  qualifications, I’m talking about Ruby 1.8.6 and its compatible
  implementations and Ruby 1.9.1 and its compatible implementations,
  respectively. We have skipped Ruby 1.8.7 and Ruby 1.9.0 because both are
  transitional bridges between 1.8.6 and 1.9.1 and aren’t truly compatible
  with either.<indexterm id="I_indexterm_d1e11132" significance="normal"><primary>versioning</primary><secondary>Ruby versions</secondary></indexterm></para><para>Another thing to keep in mind is that this is definitely not intended
  to be a comprehensive guide to the differences between the versions of Ruby.
  Please consult your favorite reference after reviewing the tips you read
  here.</para><para>But now that you have been sufficiently warned, we can move on to
  talking about how to keep things clean.</para><sect1 id="I_sect1_d1e11141"><title>Avoiding a Mess</title><para>It is very tempting to run your test suite on one version of Ruby,
    check to make sure everything passes, then run it on the other version you
    want to support and see what breaks. After seeing failures, it might seem
    easy enough to just drop in code such as the following to make things go
    green again:</para><screen format="linespecific">def my_method(string)
  lines = if RUBY_VERSION &lt; "1.9"
    string.to_a
  else
    string.lines
  end
  do_something_with(lines)
end</screen><para>Resist this temptation! If you aren’t careful, this will result in a
    giant mess that will be difficult to refactor, and will make your code
    less readable. Instead, we can approach this in a more organized
    fashion.</para><sect2><title>Selective Backporting</title><para>Before duplicating any effort, it’s important to check and see
      whether there is another reasonable way to write your code that will
      allow it to run on both Ruby 1.8 and 1.9 natively. Even if this means
      writing code that’s a little more verbose, it’s generally worth the
      effort, as it prevents the codebase from diverging.<indexterm id="I_indexterm_d1e11155" significance="normal"><primary>backward-compatible code, writing</primary><secondary>selective backporting</secondary></indexterm></para><para>If this fails, however, it may make sense to simply backport the
      feature you need to Ruby 1.8. Because of Ruby’s open classes, this is
      easy to do. We can even loosen up our changes so that they check for
      particular features rather than a specific version number, to improve
      our compatibility with other applications and Ruby <phrase role="keep-together">implementations</phrase>:</para><screen format="linespecific">class String
  unless "".respond_to?(:lines)
    alias_method :lines, :to_a
  end
end</screen><para>Doing this will allow you to rewrite your method so that it looks
      more natural:</para><screen format="linespecific">def my_method(string)
  do_something_with(string.lines)
end</screen><para>Although this implementation isn’t exact, it is good enough for
      our needs and will work as expected in most cases. However, if we wanted
      to be pedantic, we’d be sure to return an <literal moreinfo="none">Enumerator</literal>
      instead of an <literal moreinfo="none">Array</literal>:</para><screen format="linespecific">class String
  unless "".respond_to?(:lines)
    require "enumerator"

    def lines
      to_a.enum_for(:each)
    end
  end
end</screen><para>If you aren’t redistributing your code, passing tests in your
      application and code that works as expected are a good enough indication
      that your backward-compatibility patches are working. However, in code
      that you plan to distribute, open source or otherwise, you need to be
      prepared to make things more robust when necessary. Any time you
      distribute code that modifies core Ruby, you have an implicit
      responsibility of not breaking third-party libraries or application
      code, so be sure to keep this in mind and clearly document exactly what
      you have changed.</para><para>In Prawn, we use a single file,
      <emphasis>prawn/compatibility.rb</emphasis>, to store all the core
      extensions used in the library that support backward compatibility. This
      helps make it easier for users to track down all the changes made by the
      library, which can help make subtle bugs that can arise from version
      incompatibilities easier to spot.<indexterm id="I_indexterm_d1e11188" significance="normal"><primary>extension files</primary><secondary>Prawn</secondary></indexterm></para><para>In general, this approach is a fairly solid way to keep your
      application code clean while supporting both Ruby 1.8 and 1.9. However,
      you should use it only to add new functionality to Ruby 1.8.6 that isn’t
      present in 1.9.1, and not to modify existing behavior. Adding functions
      that don’t exist in a standard version of Ruby is a relatively low-risk
      procedure, whereas changing core functionality is a far more
      controversial practice.</para></sect2><sect2><title>Version-Specific Code Blocks</title><para>If you run into a situation where you really need two different
      approaches between the two major versions of Ruby, you can use a trick
      to make this a bit more attractive in your code.<indexterm id="I_indexterm_d1e11200" significance="normal"><primary>backward-compatible code, writing</primary><secondary>version-specific code blocks</secondary></indexterm></para><screen format="linespecific">if RUBY_VERSION &lt; "1.9"
  def ruby_18
    yield
  end

  def ruby_19
    false
  end
else
  def ruby_18
    false
  end

  def ruby_19
    yield
  end
end</screen><para>Here’s an example of how you’d make use of these methods:</para><screen format="linespecific">def open_file(file)
  ruby_18 { File.open("foo.txt","r") } ||
    ruby_19 { File.open("foo.txt", "r:UTF-8") }
end</screen><para>Of course, because this approach creates a divergent codebase, it
      should be used as sparingly as possible. However, this looks a little
      nicer than a conditional statement and provides a centralized place for
      changes to minor version numbers if needed, so it is a nice way to go
      when it is actually necessary.</para></sect2><sect2><title>Compatibility Shims for Common Operations</title><para>When you need to accomplish the same thing in two different ways,
      you can also consider adding a method to both versions of Ruby. Although
      Ruby 1.9.1 shipped with <literal moreinfo="none">File.binread()</literal>, this method did not exist in
      the earlier developmental versions of Ruby 1.9.<indexterm id="I_indexterm_d1e11221" significance="normal"><primary>File.binread( ) method</primary></indexterm><indexterm id="I_indexterm_d1e11224" significance="normal"><primary>backward-compatible code, writing</primary><secondary>compatibility shims for common operations</secondary></indexterm></para><para>Although a handful of <literal moreinfo="none">ruby_18</literal>
      and <literal moreinfo="none">ruby_19</literal> calls here and there
      aren’t that bad, the need for opening binary files was pervasive, and it
      got tiring to see the following code popping up everywhere this feature
      was needed:</para><screen format="linespecific">ruby_18 { File.open("foo.jpg", "rb") } ||
  ruby_19 { File.open("foo.jpg", "rb:BINARY") }</screen><para>To simplify things, we put together a simple <literal moreinfo="none">File.read_binary</literal> method that worked on both
      Ruby 1.8 and 1.9. You can see this is nothing particularly exciting or
      surprising:<indexterm id="I_indexterm_d1e11244" significance="normal"><primary>File.read_binary method</primary></indexterm></para><screen format="linespecific">if RUBY_VERSION &lt; "1.9"
  class File
    def self.read_binary(file)
      File.open(file,"rb") { |f| f.read }
    end
  end
else
  class File
    def self.read_binary(file)
      File.open(file,"rb:BINARY") { |f| f.read }
    end
  end
end</screen><para>This cleaned up the rest of our code greatly, and reduced the
      number of version checks significantly. Of course, when <literal moreinfo="none">File.binread()</literal> came along in Ruby 1.9.1, we
      went and used the techniques discussed earlier to backport it to 1.8.6,
      but prior to that, this represented a nice way to attack the same
      problem in two different ways.</para><para>Now that we’ve discussed all the relevant techniques, I can show
      you what <filename moreinfo="none">prawn/compatibility.rb</filename> looks like. This
      file allows Prawn to run on both major versions of Ruby without any
      issues, and as you can see, it is quite compact:<indexterm id="I_indexterm_d1e11259" significance="normal"><primary>prawn/compatibility.rb</primary></indexterm></para><screen format="linespecific">class String  #:nodoc:
  unless "".respond_to?(:lines)
    alias_method :lines, :to_a
  end
end
<?dbfo-need height="1in"
?>
unless File.respond_to?(:binread)
  def File.binread(file)
    File.open(file,"rb") { |f| f.read }
  end
end

if RUBY_VERSION &lt; "1.9"

  def ruby_18
    yield
  end

  def ruby_19
    false
  end

else

  def ruby_18
    false
  end

  def ruby_19
    yield
  end

end</screen><para>This code leaves Ruby 1.9.1 virtually untouched and adds only a
      couple of simple features to Ruby 1.8.6. These small modifications
      enable Prawn to have cross-<phrase role="keep-together">compatibility</phrase> between versions of Ruby
      without polluting its codebase with copious version checks and
      workarounds. Of course, there are a few areas that needed extra
      attention, and we’ll about the talk sorts of issues to look out for in
      just a moment, but for the most part, this little compatibility file
      gets the job done.</para><para>Even if someone produced a Ruby 1.8/1.9 compatibility library that
      you could include into your projects, it might still be advisable to
      copy only what you need from it. The core philosophy here is that we
      want to do as much as we can to let each respective version of Ruby be
      what it is, to avoid confusing and painful debugging sessions. By taking
      a minimalist approach and making it as easy as possible to locate your
      platform-specific changes, we can help make things run more
      smoothly.</para><para>Before we move on to some more specific details on particular
      incompatibilities and how to work around them, let’s recap the key
      points of this section:</para><itemizedlist><listitem><para>Try to support both Ruby 1.8 and 1.9 from the ground up.
          However, be sure to write your code against Ruby 1.9 first and then
          backport to 1.8 if you want prevent yourself from writing too much
          legacy code.</para></listitem><listitem><para>Before writing any version-specific code or modifying core
          Ruby, attempt to find a way to write code that runs natively on both
          Ruby 1.8 and 1.9. Even if the solution turns out to be less
          beautiful than usual, it’s better to have code that works without
          introducing redundant implementations or modifications to core
          Ruby.</para></listitem><listitem><para>For features that don’t have a straightforward solution that
          works on both versions, consider backporting the necessary
          functionality to Ruby 1.8 by adding new methods to existing core
          classes.</para></listitem><listitem><para>If a feature is too complicated to backport or involves
          separate procedures across versions, consider adding a helper method
          that behaves the same on both versions.</para></listitem><listitem><para>If you need to do inline version checks, consider using the
          <literal moreinfo="none">ruby_18</literal> and <literal moreinfo="none">ruby_19</literal> blocks
          shown in this appendix. These centralize your version-checking logic
          and provide room for refactoring and future extension.</para></listitem></itemizedlist><para>With these thoughts in mind, let’s check out some
      incompatibilities you just can’t work around, and how to avoid
      them.</para></sect2></sect1><sect1 id="I_sect1_d1e11300"><title>Nonportable Features in Ruby 1.9</title><para>There are some features in Ruby 1.9 that you simply cannot backport
    to 1.8 without modifying the interpreter itself. Here we’ll talk about
    just a few of the more obvious ones, to serve as a reminder of what to
    avoid if you plan to have your code run on both versions of Ruby. In no
    particular order, here’s a fun list of things that’ll cause a backport to
    grind to a halt if you’re not careful.<indexterm class="startofrange" id="appa_backwardnonport" significance="normal"><primary>backward-compatible code, writing</primary><secondary>nonportable features in Ruby 1.9</secondary></indexterm></para><sect2><title>Pseudo-Keyword Hash Syntax</title><para>Ruby 1.9 adds a cool feature that lets you write things
      like:<indexterm id="I_indexterm_d1e11315" significance="normal"><primary>pseudo-keyword hash syntax</primary></indexterm><indexterm id="I_indexterm_d1e11318" significance="normal"><primary>backward-compatible code, writing</primary><secondary>nonportable features in Ruby 1.9</secondary><tertiary>pseudo-keyword hash syntax</tertiary></indexterm></para><programlisting id="I_programlisting_d1e11325" format="linespecific">foo(a: 1, b: 2)</programlisting><para>But on Ruby 1.8, we’re stuck using the old key =&gt; value
      syntax:</para><programlisting id="I_programlisting_d1e11329" format="linespecific">foo(:a =&gt; 1, :b =&gt; 2)</programlisting></sect2><sect2><title>Multisplat Arguments</title><para>Ruby 1.9.1 offers a downright insane amount of ways to process
      arguments to methods. But even the more simple ones, such as multiple
      splats in an argument list, are not backward compatible. Here’s an
      example of something you can do on Ruby 1.9 that you can’t do on Ruby
      1.8, which is something to be avoided in backward-compatible
      code:<indexterm id="I_indexterm_d1e11336" significance="normal"><primary>multisplat arguments</primary></indexterm><indexterm id="I_indexterm_d1e11339" significance="normal"><primary>arguments</primary><secondary>multisplat</secondary></indexterm><indexterm id="I_indexterm_d1e11344" significance="normal"><primary>backward-compatible code, writing</primary><secondary>nonportable features in Ruby 1.9</secondary><tertiary>multisplat arguments</tertiary></indexterm></para><programlisting id="I_programlisting_d1e11351" format="linespecific">def add(a,b,c,d,e)
  a + b + c + d + e
end

add(*[1,2], 3, *[4,5]) #=&gt; 15</programlisting><para>The closest thing we can get to this on Ruby 1.8 would be
      something like this:</para><programlisting id="I_programlisting_d1e11355" format="linespecific">add(*[[1,2], 3, [4,5]].flatten) #=&gt; 15</programlisting><para>Of course, this isn’t nearly as appealing. It doesn’t even handle
      the same edge cases that Ruby 1.9 does, as this would not work with any
      array arguments that are meant to be kept as an array. So it’s best to
      just not rely on this kind of interface in code that needs to run on
      both 1.8 and 1.9.</para></sect2><sect2><title>Block-Local Variables</title><para>On Ruby 1.9, block variables will shadow outer local variables,
      resulting in the following behavior:<indexterm id="I_indexterm_d1e11364" significance="normal"><primary>backward-compatible code, writing</primary><secondary>nonportable features in Ruby 1.9</secondary><tertiary>block-local variables</tertiary></indexterm><indexterm id="I_indexterm_d1e11371" significance="normal"><primary>variables, block-local</primary></indexterm><indexterm id="I_indexterm_d1e11374" significance="normal"><primary>block-local variables</primary></indexterm></para><programlisting id="I_programlisting_d1e11377" format="linespecific">&gt;&gt; a = 1
=&gt; 1
&gt;&gt; (1..10).each { |a| a }
=&gt; 1..10
&gt;&gt; a
=&gt; 1</programlisting><para>This is not the case on Ruby 1.8, where the variable will be
      modified even if not explicitly set:</para><programlisting id="I_programlisting_d1e11381" format="linespecific">&gt;&gt; a = 1
=&gt; 1
&gt;&gt; (1..10).each { |a| a }
=&gt; 1..10
&gt;&gt; a
=&gt; 10</programlisting><para>This can be the source of a lot of subtle errors, so if you want
      to be safe on Ruby 1.8, be sure to use different names for your
      block-local variables so as to avoid accidentally overwriting outer
      local variables.</para></sect2><sect2><title>Block Arguments</title><para>In Ruby 1.9, blocks can accept block arguments, which is most
      commonly seen in <literal moreinfo="none">define_method</literal>:<indexterm id="I_indexterm_d1e11393" significance="normal"><primary>arguments</primary><secondary>block</secondary></indexterm><indexterm id="I_indexterm_d1e11398" significance="normal"><primary>block arguments</primary></indexterm><indexterm id="I_indexterm_d1e11401" significance="normal"><primary>backward-compatible code, writing</primary><secondary>nonportable features in Ruby 1.9</secondary><tertiary>block arguments</tertiary></indexterm></para><programlisting id="I_programlisting_d1e11408" format="linespecific">define_method(:answer) { |&amp;b| b.call(42) }</programlisting><para>However, this won’t work on Ruby 1.8 without some very ugly
      workarounds, so it might be best to rethink things and see whether you
      can do them in a different way if you’ve been relying on this
      functionality.</para></sect2><sect2><title>New Proc Syntax</title><para>Both the stabby <literal moreinfo="none">Proc</literal> and the
      <literal moreinfo="none">.()</literal> call are new in 1.9, and aren’t
      parseable by the Ruby 1.8 interpreter. This means that calls like this
      need to go:<indexterm id="I_indexterm_d1e11423" significance="normal"><primary>Proc objects</primary><secondary>new syntax in Ruby 1.9</secondary></indexterm><indexterm id="I_indexterm_d1e11428" significance="normal"><primary>backward-compatible code, writing</primary><secondary>nonportable features in Ruby 1.9</secondary><tertiary>new Proc syntax</tertiary></indexterm></para><programlisting id="I_programlisting_d1e11435" format="linespecific">&gt;&gt; -&gt;(a) { a*3 }.(4)
=&gt; 12</programlisting><para>Instead, use the trusty <literal moreinfo="none">lambda</literal> keyword and
      <literal moreinfo="none">Proc#call</literal> or <literal moreinfo="none">Proc#[]</literal>:</para><programlisting id="I_programlisting_d1e11448" format="linespecific">&gt;&gt; lambda { |a| a*3 }[4]
=&gt; 12</programlisting></sect2><sect2><title>Oniguruma</title><para>Although it is possible to build the Oniguruma regular expression
      engine into Ruby 1.8, it is not distributed by default, and thus should
      not be used in backward-<phrase role="keep-together">compatible</phrase>
      code. This means that if you’re using named groups, you’ll need to ditch
      them. The following code uses named groups:<indexterm id="I_indexterm_d1e11458" significance="normal"><primary>regular expressions</primary><secondary>Oniguruma engine</secondary></indexterm><indexterm id="I_indexterm_d1e11463" significance="normal"><primary>Oniguruma</primary></indexterm><indexterm id="I_indexterm_d1e11466" significance="normal"><primary>backward-compatible code, writing</primary><secondary>nonportable features in Ruby 1.9</secondary><tertiary>Oniguruma</tertiary></indexterm></para><programlisting id="I_programlisting_d1e11473" format="linespecific">&gt;&gt; "Gregory Brown".match(/(?&lt;first_name&gt;\w+) (?&lt;last_name&gt;\w+)/)
=&gt; #&lt;MatchData "Gregory Brown" first_name:"Gregory" last_name:"Brown"&gt;</programlisting><para>We’d need to rewrite this as:</para><programlisting id="I_programlisting_d1e11477" format="linespecific">&gt;&gt; "Gregory Brown".match(/(\w+) (\w+)/)
=&gt; #&lt;MatchData "Gregory Brown" 1:"Gregory" 2:"Brown"&gt;</programlisting><para>More advanced regular expressions, including those that make use
      of positive or negative look-behind, will need to be completely
      rewritten so that they work on both Ruby 1.8’s regular expression engine
      and Oniguruma.<indexterm id="I_indexterm_d1e11481" class="endofrange" startref="appa_backwardnonport" significance="normal"/></para></sect2><sect2><title>Most m17n Functionality</title><para>Though it may go without saying, Ruby 1.8 is not particularly well
      suited for working with character encodings. There are some workarounds
      for this, but things like magic comments that tell what encoding a file
      is in or <literal moreinfo="none">String</literal> objects that are aware of their
      current encoding are completely missing from Ruby 1.8.<indexterm id="I_indexterm_d1e11490" significance="normal"><primary>m17n (multilingualization)</primary><secondary>Ruby 1.8 and</secondary></indexterm><indexterm id="I_indexterm_d1e11495" significance="normal"><primary>backward-compatible code, writing</primary><secondary>nonportable features in Ruby 1.9</secondary><tertiary>m17n functionality</tertiary></indexterm></para><para>Although we could go on, I’ll leave the rest of the
      incompatibilities for you to research. Keeping an eye on the issues
      mentioned in this section will help you avoid some of the most common
      problems, and that might be enough to make things run smoothly for you,
      depending on your needs.</para><para>So far we’ve focused on the things you can’t work around, but
      there are lots of other issues that can be handled without too much
      effort, if you know how to approach them. We’ll take a look at a few of
      those now.</para></sect2></sect1><sect1 id="I_sect1_d1e11506"><title>Workarounds for Common Issues</title><para>Although we have seen that some functionality is simply not portable
    between Ruby 1.8 and 1.9, there are many more areas in which Ruby 1.9 just
    does things a little differently or more conveniently. In these cases, we
    can develop suitable workarounds that allow our code to run on both
    versions of Ruby. Let’s take a look at a few of these issues and how we
    can deal with them.<indexterm id="I_indexterm_d1e11511" significance="normal"><primary>backward-compatible code, writing</primary><secondary>workarounds for common issues</secondary></indexterm></para><sect2><title>Using Enumerator</title><para>In Ruby 1.9, you can get back an <literal moreinfo="none">Enumerator</literal> for
      pretty much every method that iterates over a collection:<indexterm id="I_indexterm_d1e11524" significance="normal"><primary>Enumerator objects</primary><secondary>backward-compatible code</secondary></indexterm><indexterm id="I_indexterm_d1e11529" significance="normal"><primary>backward-compatible code, writing</primary><secondary>workarounds for common issues</secondary><tertiary>using Enumerator</tertiary></indexterm></para><programlisting id="I_programlisting_d1e11536" format="linespecific">&gt;&gt; [1,2,3,4].map.with_index { |e,i| e + i }
=&gt; [1, 3, 5, 7]</programlisting><para>In Ruby 1.8, <literal moreinfo="none">Enumerator</literal> is part of the standard
      library instead of core, and isn’t quite as feature-packed. However, we
      can still accomplish the same goals by being a bit more verbose:</para><programlisting id="I_programlisting_d1e11543" format="linespecific">&gt;&gt; require "enumerator"
=&gt; true
&gt;&gt; [1,2,3,4].enum_for(:each_with_index).map { |e,i| e + i }
=&gt; [1, 3, 5, 7]</programlisting><para>Because Ruby 1.9’s implementation of <literal moreinfo="none">Enumerator</literal>
      is mostly backward-compatible with Ruby 1.8, you can write your code in
      this legacy style without fear of breaking anything.</para></sect2><sect2><title>String Iterators</title><para>In Ruby 1.8, <literal moreinfo="none">Strings</literal> are
      <literal moreinfo="none">Enumerable</literal>, whereas in Ruby 1.9, they are not. Ruby
      1.9 provides <literal moreinfo="none">String#lines</literal>, <literal moreinfo="none">String#each_line</literal>, <literal moreinfo="none">String#each_char</literal>, and <literal moreinfo="none">String#each_byte</literal>, all of which are not present
      in Ruby 1.8.<indexterm id="I_indexterm_d1e11574" significance="normal"><primary>String iterators</primary></indexterm><indexterm id="I_indexterm_d1e11577" significance="normal"><primary>backward-compatible code, writing</primary><secondary>workarounds for common issues</secondary><tertiary>String iterators</tertiary></indexterm></para><para>The best bet here is to backport the features you need to Ruby
      1.8, and avoid treating a <literal moreinfo="none">String</literal> as an
      <literal moreinfo="none">Enumerable</literal> sequence of lines. When you need that
      functionality, use <literal moreinfo="none">String#lines</literal> followed by whatever
      enumerable method you need.</para><para>The underlying point here is that it’s better to stick with Ruby
      1.9’s functionality, <phrase role="keep-together">because</phrase> it’ll
      be less likely to confuse others who might be reading your code.</para></sect2><sect2><title>Character Operations</title><para>In Ruby 1.9, strings are generally character-aware, which means
      that you can index into them and get back a single character, regardless
      of encoding:<indexterm id="I_indexterm_d1e11605" significance="normal"><primary>strings</primary><secondary>character-awareness</secondary></indexterm><indexterm id="I_indexterm_d1e11610" significance="normal"><primary>character operations</primary></indexterm><indexterm id="I_indexterm_d1e11613" significance="normal"><primary>backward-compatible code, writing</primary><secondary>workarounds for common issues</secondary><tertiary>character operations</tertiary></indexterm></para><programlisting id="I_programlisting_d1e11620" format="linespecific">&gt;&gt; "Foo"[0]
=&gt; "F"</programlisting><para>This is not the case in Ruby 1.8.6, as you can see:</para><programlisting id="I_programlisting_d1e11624" format="linespecific">&gt;&gt; "Foo"[0]
=&gt; 70</programlisting><para>If you need to do character-aware operations in Ruby 1.8 and 1.9,
      you’ll need to process things using a regex trick that gets you back an
      array of characters. After setting <literal moreinfo="none">$KCODE="U"</literal>,<footnote><para>This is necessary to work with UTF-8 on Ruby 1.8, but it has
          no effect on 1.9.</para></footnote> you’ll need to do things like substitute calls to <literal moreinfo="none">String#reverse</literal> with the following:</para><programlisting id="I_programlisting_d1e11638" format="linespecific">&gt;&gt; "résumé".scan(/./m).reverse.join
=&gt; "émusér"</programlisting><para>Or as another example, you’ll replace <literal moreinfo="none">String#chop</literal> with this:</para><programlisting id="I_programlisting_d1e11645" format="linespecific">&gt;&gt; r = "résumé".scan(/./m); r.pop; r.join
=&gt; "résum"</programlisting><para>Depending on how many of these manipulations you’ll need to do,
      you might consider breaking out the Ruby 1.8-compatible code from the
      clearer Ruby 1.9 code using the techniques discussed earlier in this
      appendix. However, the thing to remember is that anywhere you’ve been
      enjoying Ruby 1.9’s m17n support, you’ll need to do some rework. The
      good news is that many of the techniques used on Ruby 1.8 still work on
      Ruby 1.9, but the bad news is that they can appear quite convoluted to
      those who have gotten used to the way things work in newer versions of
      Ruby.</para></sect2><sect2><title>Encoding Conversions</title><para>Ruby 1.9 has built-in support for transcoding between various
      character encodings, whereas Ruby 1.8 is more limited. However, both
      versions support <literal moreinfo="none">Iconv</literal>. If you know exactly what
      formats you want to translate between, you can simply replace your
      <literal moreinfo="none">string.encode("ISO-8859-1")</literal> calls with something like
      this:<indexterm id="I_indexterm_d1e11660" significance="normal"><primary>transcoding</primary><secondary sortas="character encodings">between character
          encodings</secondary></indexterm><indexterm id="I_indexterm_d1e11665" significance="normal"><primary>character encodings</primary><secondary>conversions</secondary></indexterm><indexterm id="I_indexterm_d1e11670" significance="normal"><primary>backward-compatible code, writing</primary><secondary>workarounds for common issues</secondary><tertiary>encoding conversions</tertiary></indexterm></para><programlisting id="I_programlisting_d1e11677" format="linespecific">Iconv.conv("ISO-8859-1", "UTF-8", string)</programlisting><para>However, if you want to let Ruby 1.9 stay smart about its
      transcoding while still providing backward compatibility, you will just
      need to write code for each version. Here’s an example of how this was
      done in an early version of Prawn:</para><screen format="linespecific">if "".respond_to?(:encode!)
  def normalize_builtin_encoding(text)
    text.encode!("ISO-8859-1")
  end
else
  require 'iconv'
  def normalize_builtin_encoding(text)
    text.replace Iconv.conv('ISO-8859-1//TRANSLIT', 'utf-8', text)
  end
end</screen><para>Although there is duplication of effort here, the Ruby 1.9-based
      code does not assume UTF-8-based input, whereas the Ruby 1.8-based code
      is forced to make this assumption. In cases where you want to support
      many encodings on Ruby 1.9, this may be the right way to go.</para><para>Although we’ve just scratched the surface, this handful of tricks
      should cover most of the common issues you’ll encounter. For everything
      else, consult your favorite language reference.</para></sect2></sect1><sect1 id="I_sect1_d1e11687"><title>Conclusions</title><para>Depending on the nature of your project, getting things running on
    both Ruby 1.8 and 1.9 can be either trivial or a major undertaking. The
    more string processing you are doing, and the greater your need for
    multilingualization support, the more complicated a backward-compatible
    port of your software to Ruby 1.8 will be. Additionally, if you’ve been
    digging into some of the fancy new features that ship with Ruby 1.9, you
    might find yourself doing some serious rewriting when the time comes to
    support older versions of Ruby.</para><para>In light of all this, it’s best to start (if you can afford to) by
    supporting both versions from the ground up. By writing your code in a
    fairly backward-compatible subset of Ruby 1.9, you’ll minimize the amount
    of duplicated effort that is needed to support both versions. If you keep
    your compatibility hacks well organized and centralized, it’ll be easier
    to spot any problems that might crop up.</para><para>If you find yourself writing the same workaround several times,
    think about extending the core with some helpers to make your code
    clearer. However, keep in mind that when you redistribute code, you have a
    responsibility not to break existing language features and that you should
    strive to avoid conflicts with third-party libraries.</para><para>But don’t let all these caveats turn you away. Writing code that
    runs on both Ruby 1.8 and 1.9 is about the most friendly thing you can do
    in terms of open source Ruby, and will also be beneficial in other
    scenarios. Start by reviewing the guidelines in this appendix, then
    remember to keep testing your code on both versions of Ruby. As long as
    you keep things well organized and try as best as you can to minimize
    version-specific code, you should be able to get your project working on
    both Ruby 1.8 and 1.9 without conflicts. This gives you a great degree of
    flexibility, which is often worth the extra effort.<indexterm id="I_indexterm_d1e11698" class="endofrange" startref="appa_backward" significance="normal"/></para></sect1></appendix><appendix id="appb"><title>Leveraging Ruby’s Standard Library</title><para>Most of this book has emphasized that understanding how to use tools
  effectively is just as important as having a nice collection of tools.
  However, that’s not to say that knowing where to find the right tool for the
  job isn’t an invaluable skill to have. In this appendix, we’ll take a look
  at a small sampling of Ruby’s vast standard library. What you will find is
  that it is essentially a treasure chest of goodies designed to make your
  Ruby programs more enjoyable to write.</para><sect1 id="I_sect1_d1e11704"><title>Why Do We Need a Standard Library?</title><para>Because of RubyGems, we tend to leverage a lot of third-party
    software. For this reason, we are often more likely to resort to a Google
    search instead of a search of Ruby’s API documentation when we want to
    solve a problem that isn’t immediately handled in core Ruby. This isn’t
    necessarily a bad thing, but it is important not to overlook the benefits
    that come with using a standard library when it is available. When all
    else is equal, the gains you’ll get from using standard Ruby are easy to
    enumerate:</para><itemizedlist><listitem><para>Ruby standard libraries are typically distributed with Ruby
        itself, which means that no extra software needs to be installed to
        make them work.</para></listitem><listitem><para>Standard libraries don’t change rapidly. Their APIs tend to be
        stable and mature, and will likely outlast your application’s
        development cycle. This removes the need for frequent compatibility
        updates that you might experience with third-party <phrase role="keep-together">software</phrase>.</para></listitem><listitem><para>Except for a few obvious exceptions, Ruby standard libraries are
        guaranteed to run anywhere Ruby runs, avoiding platform-specific
        issues.</para></listitem><listitem><para>Using standard libraries improves the understandability of your
        code, as they are available to everyone who uses Ruby. For open source
        projects, this might make contributions to your project easier, for
        the same reason.</para></listitem></itemizedlist><?dbfo-need height=”1in”
?><para>These reasons are compelling enough to encourage us to check Ruby’s
    standard library before doing a Google search for third-party libraries.
    However, it might be more <phrase role="keep-together">convincing</phrase>
    if you have some practical examples of what can be accomplished without
    resorting to dependency code.</para><para>I’ve handpicked 10 of the libraries I use day in and day out. This
    isn’t necessarily meant to be a “best of” sampling, nor is it meant to
    point out the top 10 libraries you need to know about. We’ve implicitly
    and explicitly covered many standard libraries throughout the book, and
    some of those may be more essential than what you’ll see here. However,
    I’m fairly certain that after reading this appendix, you’ll find at least
    a few useful tricks in it, and you’ll also get a clear picture of how
    diverse Ruby’s standard library is.</para><para>Be sure to keep in mind that while we’re looking at 10 examples
    here, there are more than 100 standard libraries packaged with Ruby, about
    half of which are considered mature. These vary in complexity from simple
    tools to solve a single task to full-fledged frameworks. Even though you
    certainly won’t need to be familiar with every last package and what it
    does, it’s important to be aware of the fact that what we’re about to
    discuss is just the tip of the iceberg.</para><para>Now, on to the fun. I’ve included this appendix because I think it
    embodies a big part of the joy of Ruby programming to me. I hope that when
    reading through the examples, you feel the same way.</para></sect1><sect1 id="I_sect1_d1e11737"><title>Pretty-Printer for Ruby Objects (pp)</title><para>As I mentioned before, Ruby standard libraries run the gamut from
    extreme simplicity to deep complexity. I figured we’d kick things off with
    something in the former <phrase role="keep-together">category</phrase>.<indexterm class="startofrange" id="appb_prettyprinter" significance="normal"><primary>pretty-printer for Ruby objects (pp)</primary></indexterm><indexterm class="startofrange" id="appb_pplibrary" significance="normal"><primary>pp (prettyprint) standard library</primary></indexterm></para><para>If you’re reading this book, you’ve certainly made use of <literal moreinfo="none">Kernel#p</literal> during debugging. This handy method,
    which calls <literal moreinfo="none">#inspect</literal> on an object and
    then prints out its result, is invaluable for basic debugging needs.
    However, reading its output for even relatively modest objects can be
    daunting:</para><screen format="linespecific">friends = [ { first_name: "Emily", last_name: "Laskin" },
            { first_name: "Nick",  last_name: "Mauro" },
            { first_name: "Mark",  last_name: "Maxwell" } ]

me = { first_name: "Gregory", last_name: "Brown", friends: friends }

p me # Outputs:

{:first_name=&gt;"Gregory", :last_name=&gt;"Brown", :friends=&gt;[{:first_name=&gt;"Emily",
:last_name=&gt;"Laskin"}, {:first_name=&gt;"Nick", :last_name=&gt;"Mauro"}, {:first_name=
&gt;"Mark", :last_name=&gt;"Maxwell"}]}</screen><para>We don’t typically write our code this way, because the structure of
    our objects actually means something to us. Luckily, the
    <emphasis>pp</emphasis> standard library understands this and provides
    much nicer human-readable output. The changes to use <literal moreinfo="none">pp</literal> instead of <literal moreinfo="none">p</literal> are fairly simple:</para><screen format="linespecific">require "pp"

friends = [ { first_name: "Emily", last_name: "Laskin" },
            { first_name: "Nick",  last_name: "Mauro" },
            { first_name: "Mark",  last_name: "Maxwell" } ]

me = { first_name: "Gregory", last_name: "Brown", friends: friends }

pp me # Outputs:

{:first_name=&gt;"Gregory",
 :last_name=&gt;"Brown",
 :friends=&gt;
  [{:first_name=&gt;"Emily", :last_name=&gt;"Laskin"},
   {:first_name=&gt;"Nick", :last_name=&gt;"Mauro"},
   {:first_name=&gt;"Mark", :last_name=&gt;"Maxwell"}]}</screen><para>Like when you use <literal moreinfo="none">p</literal>, there is a
    hook to set up <literal moreinfo="none">pp</literal> overrides for your
    custom objects. This is called <literal moreinfo="none">pretty_print</literal>. Here’s a simple implementation
    that shows how you might use it:<indexterm id="I_indexterm_d1e11785" significance="normal"><primary>pretty_print method</primary></indexterm></para><screen format="linespecific">require "pp"

class Person
  def initialize(first_name, last_name, friends)
    @first_name, @last_name, @friends = first_name, last_name, friends
  end

  def pretty_print(printer)
    printer.text "Person &lt;#{object_id}&gt;:\n" &lt;&lt;
                 "  Name: #@first_name #@last_name\n  Friends:\n"
    @friends.each do |f|
      printer.text "    #{f[:first_name]} #{f[:last_name]}\n"
    end
  end

end

friends = [ { first_name: "Emily", last_name: "Laskin" },
            { first_name: "Nick",  last_name: "Mauro" },
            { first_name: "Mark",  last_name: "Maxwell" } ]

person = Person.new("Gregory", "Brown", friends)
pp person #=&gt; outputs:

Person &lt;1013900&gt;:
  Name: Gregory Brown
  Friends:
    Emily Laskin
    Nick Mauro
    Mark Maxwell</screen><para>As you can see here, <literal moreinfo="none">pretty_print</literal>
    takes an argument, which is an instance of the current <literal moreinfo="none">pp</literal> object. Because <literal moreinfo="none">pp</literal> inherits from <literal moreinfo="none">PrettyPrint</literal>, a class provided by Ruby’s
    <emphasis role="keep-together">prettyprint</emphasis> standard library, it
    provides a whole host of formatting <phrase role="keep-together">helpers</phrase> for <phrase role="keep-together">indenting</phrase>, grouping, and wrapping structured
    data output. We’ve stuck with the raw <literal moreinfo="none">text()</literal> call here, but it’s worth mentioning that
    there is a lot more available to you if you need it.<indexterm id="I_indexterm_d1e11817" significance="normal"><primary>PrettyPrint class</primary></indexterm></para><para>A benefit of indirectly displaying your output through a printer
    object is that it <phrase role="keep-together">allows <literal moreinfo="none">pp</literal></phrase> to give you an
    <literal moreinfo="none">inspect</literal>-like method that returns a string. Try <literal moreinfo="none" role="keep-together">person.pretty_print_inspect</literal>
    to see how this works. The string represents exactly what would be printed
    to the console, just like <literal moreinfo="none">obj.inspect</literal>
    would. If you wish to use <literal moreinfo="none">pretty_print_inspect</literal> as your default inspect
    method (and therefore make <literal moreinfo="none">p</literal> and <literal moreinfo="none">pp</literal>
    work the same), you can do so easily with an alias:<indexterm id="I_indexterm_d1e11846" significance="normal"><primary>pretty_print_inspect method</primary></indexterm></para><screen format="linespecific">class Person
  # other code omitted

  alias_method :inspect, :pretty_print_inspect
end</screen><para>Generally speaking, <literal moreinfo="none">pp</literal> does a
    pretty good job of rendering the debugging output for even relatively
    complex objects, so you may not need to customize its behavior often.
    However, if you do have a need for specialized output, you’ll find that
    the <literal moreinfo="none">pretty_print</literal> hook provides
    something that is actually quite a bit more powerful than Ruby’s default
    <literal moreinfo="none">inspect</literal> hook, and that can really come
    in handy for certain needs.<indexterm id="I_indexterm_d1e11863" class="endofrange" startref="appb_prettyprinter" significance="normal"/><indexterm id="I_indexterm_d1e11864" class="endofrange" startref="appb_pplibrary" significance="normal"/></para></sect1><sect1 id="I_sect1_d1e11865"><title>Working with HTTP and FTP (open-uri)</title><para>Like most other modern programming languages, Ruby ships with
    libraries for working with some of the most common network protocols,
    including FTP and HTTP. However, the <literal moreinfo="none">Net::FTP</literal> and <literal moreinfo="none">Net::HTTP</literal> libraries are designed primarily for
    heavy lifting at the low level. They are great for this purpose, but they
    leave something to be desired for when all that is needed is to grab a
    remote file or do some basic web scraping. This is where <literal moreinfo="none">open-uri</literal> shines.<indexterm id="I_indexterm_d1e11879" significance="normal"><primary>FTP, working with, using open-uri</primary></indexterm><indexterm id="I_indexterm_d1e11882" significance="normal"><primary>HTTP, working with, using open-uri</primary></indexterm><indexterm class="startofrange" id="appb_openuri" significance="normal"><primary>open-uri standard library</primary></indexterm></para><para>The way <literal moreinfo="none">open-uri</literal> works is by
    patching <literal moreinfo="none">Kernel#open</literal> to accept URIs.
    This means we can directly open remote files and work with them. For
    example, here’s how we’d print out Ruby’s license using <literal moreinfo="none">open-uri</literal>:<indexterm id="I_indexterm_d1e11899" significance="normal"><primary>Kernel#open, patching to accept URIs</primary></indexterm></para><screen format="linespecific">require "open-uri"

puts open("http://www.ruby-lang.org/en/LICENSE.txt").read #=&gt;

"Ruby is copyrighted free software by Yukihiro Matsumoto &lt;matz@netlab.co.jp&gt;.
You can redistribute it and/or modify it under either the terms of the GPL
(see COPYING.txt file), or the conditions below: ..."</screen><para>If we encounter an HTTP error, an <literal moreinfo="none">OpenURI::HTTPError</literal> will be raised, including the
    relevant error code:<indexterm id="I_indexterm_d1e11909" significance="normal"><primary>OpenURI::HTTPError</primary></indexterm></para><?dbfo-need height=”1in”
?><screen format="linespecific">&gt;&gt; open("http://majesticseacreature.com/a_totally_missing_document")
OpenURI::HTTPError: 404 Not Found
        from /usr/local/lib/ruby/1.8/open-uri.rb:287:in 'open_http'
        from /usr/local/lib/ruby/1.8/open-uri.rb:626:in 'buffer_open'
        from /usr/local/lib/ruby/1.8/open-uri.rb:164:in 'open_loop'
        from /usr/local/lib/ruby/1.8/open-uri.rb:162:in 'catch'
        from /usr/local/lib/ruby/1.8/open-uri.rb:162:in 'open_loop'
        from /usr/local/lib/ruby/1.8/open-uri.rb:132:in 'open_uri'
        from /usr/local/lib/ruby/1.8/open-uri.rb:528:in 'open'
        from /usr/local/lib/ruby/1.8/open-uri.rb:30:in 'open'
        from (irb):10
        from /usr/local/lib/ruby/1.8/uri/generic.rb:250

&gt;&gt; open("http://prism.library.cornell.edu/control/authBasic/authTest/")
OpenURI::HTTPError: 401 Authorization Required
        from /usr/local/lib/ruby/1.8/open-uri.rb:287:in 'open_http'
        from /usr/local/lib/ruby/1.8/open-uri.rb:626:in 'buffer_open'
        from /usr/local/lib/ruby/1.8/open-uri.rb:164:in 'open_loop'
        from /usr/local/lib/ruby/1.8/open-uri.rb:162:in 'catch'
        from /usr/local/lib/ruby/1.8/open-uri.rb:162:in 'open_loop'
        from /usr/local/lib/ruby/1.8/open-uri.rb:132:in 'open_uri'
        from /usr/local/lib/ruby/1.8/open-uri.rb:528:in 'open'
        from /usr/local/lib/ruby/1.8/open-uri.rb:30:in 'open'
        from (irb):7
        from /usr/local/lib/ruby/1.8/uri/generic.rb:250</screen><para>The previous example was a small hint about another feature of
    <emphasis>open-uri</emphasis>, HTTP basic authentication. Notice what
    happens when we provide a username and password <phrase role="keep-together">accessing</phrase> the same URI:<indexterm id="I_indexterm_d1e11923" significance="normal"><primary>authentication</primary><secondary>HTTP</secondary></indexterm></para><screen format="linespecific">&gt;&gt; open("http://prism.library.cornell.edu/control/authBasic/authTest/",
?&gt;   :http_basic_authentication =&gt; ["test", "this"])
=&gt; #&lt;StringIO:0x2d1810&gt;</screen><para>Success! You can see here that <emphasis>open-uri</emphasis>
    represents the returned file as a <literal moreinfo="none">StringIO</literal> object,
    which is why we can call <literal moreinfo="none">read</literal> to get
    its contents. Of course, we can use most other <phrase role="keep-together">I/O</phrase> operations as well, but I won’t get into
    that here.<indexterm id="I_indexterm_d1e11944" significance="normal"><primary>StringIO objects, returned by open-uri</primary></indexterm></para><para>As I mentioned before, <emphasis>open-uri</emphasis> also wraps
    <literal moreinfo="none">Net::FTP</literal>, so you could even do
    something like download Ruby with it:<indexterm id="I_indexterm_d1e11955" significance="normal"><primary>Net::FTP module</primary></indexterm></para><screen format="linespecific">open("ftp://ftp.ruby-lang.org/pub/ruby/1.9/ruby-1.9.1-p0.tar.bz2") do |o|
  File.open(File.basename(o.base_uri.path), "w") { |f| f &lt;&lt; o.read }
end</screen><para>Here we see that even though the object returned by <literal moreinfo="none">open()</literal> is a <literal moreinfo="none">StringIO</literal> object, it includes some extra
    metadata, such as the <literal moreinfo="none">base_uri</literal> of your
    request. These helpers are provided by the <literal moreinfo="none">OpenURI::Meta</literal> module, and are worth looking over
    if you need to get more than just the contents of a file back.<indexterm id="I_indexterm_d1e11975" significance="normal"><primary>OpenURI::Meta module</primary></indexterm></para><para>Although there are some advanced features to <literal moreinfo="none">open-uri</literal>, it is most useful for the simple cases
    shown here. Because it returns a <literal moreinfo="none">StringIO</literal> object, this means that any fairly
    flexible interface can be extended to support remote file downloads. For a
    practical example, we can take a look at Prawn’s image embedding, which
    assumes only that an object you pass to it must respond to <literal moreinfo="none">#read</literal>:</para><screen format="linespecific">Prawn::Document.generate("remote_images.pdf") do
  image open("http://prawn.majesticseacreature.com/media/prawn_logo.png")
end</screen><para>This feature was accidentally enabled when we allowed the <literal moreinfo="none">image()</literal> method to accept
    <literal moreinfo="none">Tempfile</literal> objects. Because <emphasis>open-uri</emphasis>
    smoothly integrates with the rest of Ruby, you might find situations where
    it can come in handy in a similar way in your own applications.<indexterm id="I_indexterm_d1e12002" class="endofrange" startref="appb_openuri" significance="normal"/></para></sect1><sect1 id="I_sect1_d1e12003"><title>Working with Dates and Times (date)</title><para>Core Ruby has a <literal moreinfo="none">Time</literal> class, but
    we will encounter a lot of situations where we also need to work with
    dates, or combinations of dates and times. Ruby’s
    <emphasis>date</emphasis> standard library gives us <literal moreinfo="none">Date</literal> and <literal moreinfo="none">DateTime</literal>, and extends <literal moreinfo="none">Time</literal> with conversion methods for each of them.
    This library comes packed with a powerful parser that can handle all sorts
    of date formats, and a solid date formatting engine to output data based
    on a template. Here are just a couple of trivial examples to give you a
    sense of its flexibility:<indexterm id="I_indexterm_d1e12024" significance="normal"><primary>Date objects</primary></indexterm><indexterm id="I_indexterm_d1e12027" significance="normal"><primary>Time class</primary></indexterm><indexterm class="startofrange" id="appb_datelibrary" significance="normal"><primary>date standard library</primary></indexterm></para><screen format="linespecific">&gt;&gt; Date.strptime("12/08/1985","%m/%d/%Y").strftime("%Y-%m-%d")
=&gt; "1985-12-08"
&gt;&gt; Date.strptime("1985-12-08","%Y-%m-%d").strftime("%m/%d/%Y")
=&gt; "12/08/1985"
&gt;&gt; Date.strptime("December 8, 1985","%b%e, %Y").strftime("%m/%d/%Y")
=&gt; "12/08/1985"</screen><para><literal moreinfo="none">Date</literal> objects can also be queried
    for all sorts of information, as well as manipulated to produce new
    days:</para><screen format="linespecific">&gt;&gt; date = Date.today
=&gt; #&lt;Date: 2009-02-09 (4909743/2,0,2299161)&gt;
&gt;&gt; date + 1
=&gt; #&lt;Date: 2009-02-10 (4909745/2,0,2299161)&gt;
&gt;&gt; date &lt;&lt; 1
=&gt; #&lt;Date: 2009-01-09 (4909681/2,0,2299161)&gt;
&gt;&gt; date &gt;&gt; 1
=&gt; #&lt;Date: 2009-03-09 (4909799/2,0,2299161)&gt;
&gt;&gt; date.year
=&gt; 2009
&gt;&gt; date.month
=&gt; 2
&gt;&gt; date.day
=&gt; 9
&gt;&gt; date.wday
=&gt; 1
&gt;&gt; date + 36
=&gt; #&lt;Date: 2009-03-17 (4909815/2,0,2299161)&gt;</screen><para>Here we’ve just scratched the surface, but in the interest of
    keeping a quick pace, we’ll dive right into an example. So far, we’ve been
    looking at <literal moreinfo="none">Date</literal>, but now we’re going to
    work with <literal moreinfo="none">DateTime</literal>. The two are
    basically the same, except that the latter can hold time values as
    well:<indexterm id="I_indexterm_d1e12049" significance="normal"><primary>DateTime objects</primary></indexterm><footnote><para>A <literal moreinfo="none">DateTime</literal> is also similar to
        Ruby’s <literal moreinfo="none">Time</literal> object, but it is not
        constrained to representing only those dates that can be represented
        in Unix time. See <ulink url="http://en.wikipedia.org/wiki/Unix_time"/>.</para></footnote></para><screen format="linespecific">&gt;&gt; dtime = DateTime.now
=&gt; #&lt;DateTime: 2009-02-09T03:56:17-05:00 (...)&gt;
&gt;&gt; [:month, :day, :year, :hour, :minute, :second].map { |attr| dtime.send(attr) }
=&gt; [2, 9, 2009, 3, 56, 17]
&gt;&gt; dtime.between?(DateTime.now - 1, DateTime.now + 1)
=&gt; true
&gt;&gt; dtime.between?(DateTime.now - 1, DateTime.now - 1)
=&gt; false</screen><para>What follows is a simplified look at a common problem: event
    scheduling. Basically, we want an object that provides functionality like
    this:<indexterm id="I_indexterm_d1e12067" significance="normal"><primary>event scheduling</primary></indexterm></para><screen format="linespecific">sched = Scheduler.new
sched.event "2009.02.04 10:00", "2009.02.04 11:30", "Eat Snow"
sched.event "2009.02.03 14:00", "2009.02.04 14:00", "Wear Special Suit"
sched.display_events_at '2009.02.04 10:20'</screen><para>When given a specific date and time, <literal moreinfo="none">display_events_at</literal> would look up all the events
    that were happening at that exact moment:</para><programlisting id="I_programlisting_d1e12077" format="linespecific">Events occurring around 10:20 on 02/04/2009
--------------------------------------------
14:00 (02/03) - 14:00 (02/04): Wear Special Suit
10:00 (02/04) - 11:30 (02/04): Eat Snow</programlisting><para>This means that if we look a little later in the day, as you can see
    that in this particular example, although eating snow is a short-lived
    experience, the passion for wearing a special suit carries on:</para><programlisting id="I_programlisting_d1e12082" format="linespecific">sched.display_events_at '2009.02.04 11:45'

## OUTPUTS ##

Events occurring around 11:45 on 02/04/2009
--------------------------------------------
14:00 (02/03) - 14:00 (02/04): Wear Special Suit</programlisting><para>As it turns out, implementing the <literal moreinfo="none">Scheduler</literal> class is pretty straightforward,
    because <literal moreinfo="none">DateTime</literal> objects can be used as
    endpoints in a Ruby range object. So when we look at these two events,
    what we’re really doing is something similar to this:<indexterm id="I_indexterm_d1e12092" significance="normal"><primary>Scheduler class, implementing</primary></indexterm></para><screen format="linespecific">&gt;&gt; a = DateTime.parse("2009.02.03 14:00") .. DateTime.parse("2009.02.04 14:00")
&gt;&gt; a.cover?(DateTime.parse("2009.02.04 11:45"))
=&gt; true

&gt;&gt; b = DateTime.parse("2009.02.04 10:00") .. DateTime.parse("2009.02.04 11:30")
&gt;&gt; b.cover?(DateTime.parse("2009.02.04 11:45"))
=&gt; false</screen><para>When you combine this with things we’ve already discussed, like
    flexible date parsing and formatting, you end up with a fairly vanilla
    implementation:</para><screen format="linespecific">require "date"

class Scheduler

  def initialize
    @events = []
  end

  def event(from, to, message)
    @events &lt;&lt; [DateTime.parse(from) .. DateTime.parse(to),  message]
  end

  def display_events_at(datetime)
    datetime = DateTime.parse(datetime)
    puts "Events occurring around #{datetime.strftime("%H:%M on %m/%d/%Y")}"
    puts "--------------------------------------------"
    events_at(datetime).each do |range, message|
      puts "#{time_abbrev(range.first)} - #{time_abbrev(range.last)}: #{message}"
    end
  end

  private

  def time_abbrev(datetime)
    datetime.strftime("%H:%M (%m/%d)")
  end

  def events_at(datetime)
    @events.each_with_object([]) do |event, matched|
      matched &lt;&lt; event if event.first.cover?(datetime)
    end
  end

end</screen><para>We can start by looking at how <literal moreinfo="none">event()</literal> works:</para><screen format="linespecific">def event(from, to, message)
  @events &lt;&lt; [DateTime.parse(from) .. DateTime.parse(to),  message]
end</screen><para>Here we see that each event is simply a tuple consisting of two
    elements: a datetime <literal moreinfo="none">Range</literal>, and a
    message. We parse the strings on the fly using <literal moreinfo="none">DateTime.parse</literal>. This <phrase role="keep-together">method</phrase> should typically be used with
    caution, as it is much more reliable to use <literal moreinfo="none" role="keep-together">Date.strptime</literal>, and much faster to construct
    a <literal moreinfo="none">DateTime</literal> manually than it is to
    attempt to guess the date format. That having been said, there is no
    substitute when you cannot rely on a standardized date format, and it does
    a good job of providing a flexible <phrase role="keep-together">interface</phrase> when one is needed.<indexterm id="I_indexterm_d1e12129" significance="normal"><primary>Date.strptime method</primary></indexterm><indexterm id="I_indexterm_d1e12132" significance="normal"><primary>DateTime.parse method</primary></indexterm></para><para>As this fairly pedestrian code completely covers storing events,
    what remains to be shown is how they are selectively retrieved and
    displayed. We’ll start with the helper method that looks up what events
    are going on at a particular time:<indexterm id="I_indexterm_d1e12137" significance="normal"><primary>event scheduling</primary><secondary>selective retrieval and display of events</secondary></indexterm></para><screen format="linespecific">def events_at(datetime)
  @events.each_with_object([]) do |event, matched|
    matched &lt;&lt; event if event.first.cover?(datetime)
  end
end</screen><para>Here, we build up our list of matching events by simply iterating
    over the event list and including those only those events in which the
    datetime <literal moreinfo="none">Range</literal> covers the time in
    <phrase role="keep-together">question</phrase>. This, along with the
    self-explanatory <literal moreinfo="none">time_abbrev</literal> code, is
    used to keep <literal moreinfo="none" role="keep-together">display_events_at</literal> nice and clean:<indexterm id="I_indexterm_d1e12159" significance="normal"><primary>display_events_at function</primary></indexterm></para><screen format="linespecific">def display_events_at(datetime)
  datetime = DateTime.parse(datetime)
  puts "Events occurring around #{datetime.strftime("%H:%M on %m/%d/%Y")}"
  puts "--------------------------------------------"
  events_at(datetime).each do |range, message|
    puts "#{time_abbrev(range.first)} - #{time_abbrev(range.last)}: #{message}"
  end
end</screen><para>Here, we’re doing little more than parsing the date and time passed
    in as a string to get us a <literal moreinfo="none">DateTime</literal>
    object, and then displaying the results of <literal moreinfo="none">events_at</literal>. We take advantage of <literal moreinfo="none">strftime</literal> for that, and recover the endpoints of
    the range to include in our output, to show exactly when an event starts
    and stops. There’s really not much more to it.<indexterm id="I_indexterm_d1e12175" significance="normal"><primary>events_at method</primary></indexterm></para><para>Although this example is obviously a bit oversimplified, you’ll find
    that similar problems crop up again and again. The key thing to remember
    is to take advantage of the ability of <literal moreinfo="none">DateTime</literal> objects to be used within ranges, and
    whenever possible, to avoid parsing dates yourself. If you need finer
    granularity, use <literal moreinfo="none">strptime()</literal>, but for
    many needs <literal moreinfo="none">parse()</literal> will do the trick
    while providing a more flexible interface to your users.</para><para>We’ve covered some of the most common uses of Ruby’s standard
    <emphasis>date</emphasis> library here, but there are of course plenty of
    other features for the edge case. As with the other topics in this
    appendix, hit up the API documentation if you need to know more.<indexterm id="I_indexterm_d1e12194" class="endofrange" startref="appb_datelibrary" significance="normal"/></para></sect1><sect1 id="I_sect1_d1e12195"><title>Lexical Parsing with Regular Expressions (strscan)</title><para>Although Ruby’s <literal moreinfo="none">String</literal> object provides many
    powerful features that rely on regular expressions, it can be cumbersome
    to build any sort of parser with them. Most operations that you can do
    directly on strings work on the whole string at once, providing <literal moreinfo="none" role="keep-together">MatchData</literal> that can be used
    to index into the original content. This is great when a single pattern
    fits the bill, but when you want to consume some text in chunks, switching
    up strategies as needed along the way, things get a little more hairy.
    This is where the <emphasis>strscan</emphasis> library comes in.<indexterm class="startofrange" id="appb_stringsparse" significance="normal"><primary>strings</primary><secondary>lexical parsing with regular expressions
        (strscan)</secondary></indexterm><indexterm class="startofrange" id="appb_regexpparsing" significance="normal"><primary>regular expressions</primary><secondary>lexical parsing with (strscan)</secondary></indexterm><indexterm class="startofrange" id="appb_strscanlib" significance="normal"><primary>strscan standard library</primary></indexterm></para><para>When you require <emphasis>strscan</emphasis>, it provides a class
    called <literal moreinfo="none">StringScanner</literal>. The underlying
    purpose of using this object is that it keeps track of where you are in
    the string as you consume parts of it via regex patterns. Just to clear up
    what this means, we can take a look at the example used in the
    RDoc:<indexterm id="I_indexterm_d1e12230" significance="normal"><primary>StringScanner class</primary></indexterm></para><screen format="linespecific">s = StringScanner.new('This is an example string')
s.eos?               # -&gt; false

p s.scan(/\w+/)      # -&gt; "This"
p s.scan(/\w+/)      # -&gt; nil
p s.scan(/\s+/)      # -&gt; " "
p s.scan(/\s+/)      # -&gt; nil
p s.scan(/\w+/)      # -&gt; "is"
s.eos?               # -&gt; false

p s.scan(/\s+/)      # -&gt; " "
p s.scan(/\w+/)      # -&gt; "an"
p s.scan(/\s+/)      # -&gt; " "
p s.scan(/\w+/)      # -&gt; "example"
p s.scan(/\s+/)      # -&gt; " "
p s.scan(/\w+/)      # -&gt; "string"
s.eos?               # -&gt; true

p s.scan(/\s+/)      # -&gt; nil
p s.scan(/\w+/)      # -&gt; nil</screen><para>From this simple example, it’s clear to see that the index is
    advanced only when a match is made. Once the end of the string is reached,
    there is nothing left to match. Although this may seem a little simplistic
    at first, it forms the essence of what <literal moreinfo="none">StringScanner</literal> does for us. We can see that by
    looking at how it is used in the context of something a little more
    real.</para><para>We’re about to look at how to parse JSON (JavaScript Object
    Notation), but the example we’ll use is primarily for educational
    purposes, as it demonstrates an elegant use of
    <literal moreinfo="none">StringScanner</literal>. If you have a real need for this
    functionality, be sure to look at the <emphasis>json</emphasis> standard
    library that ships with Ruby, as that is designed to provide the kind of
    speed and robustness you’ll need in production.<indexterm id="I_indexterm_d1e12248" significance="normal"><primary>JSON (JavaScript Object Notation)</primary><secondary>parsing</secondary></indexterm></para><para>In Ruby Quiz #155, James Gray builds up a JSON parser by
    hand-rolling a recursive descent parser using <literal moreinfo="none">StringScanner</literal>. He actually covers the full
    solution in depth on the <ulink url="http://rubyquiz.com/quiz155.html">Ruby Quiz website</ulink>, but this
    abridged version focuses specifically on his use of <literal role="keep-together" moreinfo="none">StringScanner</literal>. To keep things simple, we’ll
    discuss roughly how he manages to get this small set of assertions to
    pass:<indexterm id="I_indexterm_d1e12264" significance="normal"><primary>Ruby Quiz website</primary></indexterm></para><screen format="linespecific">def test_array_parsing
  assert_equal(Array.new, @parser.parse(%Q{[]}))
  assert_equal( ["JSON", 3.1415, true],
    @parser.parse(%Q{["JSON", 3.1415, true]}) )
  assert_equal([1, [2, [3]]], @parser.parse(%Q{[1, [2, [3]]]}))
end</screen><para>We can see by the general outline how this parser works:</para><screen format="linespecific">require "strscan"

class JSONParser
  AST = Struct.new(:value)

  def parse(input)
    @input = StringScanner.new(input)
    parse_value.value
  ensure
    @input.eos? or error("Unexpected data")
  end

  private

  def parse_value
    trim_space
    parse_object or
    parse_array or
    parse_string or
    parse_number or
    parse_keyword or
    error("Illegal JSON value")
  ensure
    trim_space
  end


  # ...

end</screen><para>Essentially, a <literal moreinfo="none">StringScanner</literal>
    object is built up using the original JSON string. Then, the parser
    recursively walks down through the structure and parses the data types it
    encounters. Once the parsing completes, we expect that we’ll be at the end
    of the string, otherwise some data was left unparsed, indicating
    corruption.<indexterm id="I_indexterm_d1e12278" significance="normal"><primary>parse_value method</primary></indexterm></para><para>Looking at the way <literal moreinfo="none">parse_value</literal> is
    implemented, we see the benefit of using <literal role="keep-together" moreinfo="none">StringScanner</literal>. Before an actual value is
    parsed, whitespace is trimmed on both ends using the <literal moreinfo="none">trim_space</literal> helper. This is exactly as simple as
    you might expect it to be:<indexterm id="I_indexterm_d1e12293" significance="normal"><primary>trim_space helper method</primary></indexterm></para><screen format="linespecific">def trim_space
  @input.scan(/\s+/)
end</screen><para>Of course, to make things a little more interesting, and to continue
    our job, we need to peel back the covers on <literal moreinfo="none">parse_array</literal>:<indexterm id="I_indexterm_d1e12303" significance="normal"><primary>arrays</primary><secondary>parsing</secondary></indexterm><indexterm id="I_indexterm_d1e12308" significance="normal"><primary>parse_array method</primary></indexterm></para><screen format="linespecific">def parse_array
  if @input.scan(/\[\s*/) #1
    array       = Array.new
    more_values = false
    while contents = parse_value rescue nil #2
      array &lt;&lt; contents.value
      more_values = @input.scan(/\s*,\s*/) or break
    end
    error("Missing value") if more_values
    @input.scan(/\s*\]\s*/) or error("Unclosed array") #3
    AST.new(array)
  else
    false
  end
end</screen><para>The beauty of JSON (and this particular parsing solution) is that
    it’s very easy to see what’s going on. On a successful parse, this code
    takes three simple steps. First, it detects the opening <literal moreinfo="none">[</literal>, indicating the start of a JSON array. If it
    finds that, it creates a Ruby array to populate. Then, the second step is
    to parse out each value, separated by commas and optional whitespace. To
    do this, the parser simply calls <literal moreinfo="none">parse_value</literal> again, taking advantage of recursion
    as we mentioned before. Finally, the third step is to seek a closing
    <literal moreinfo="none">]</literal>, which, when found, ends this stage
    of parsing and returns a Ruby array wrapped in the AST struct this parser
    uses.<indexterm id="I_indexterm_d1e12324" significance="normal"><primary>JSON array, starting and end points</primary></indexterm></para><para>Going back to our three assertions, we can trace them one by one.
    The first one was meant to test parsing an empty array:<indexterm id="I_indexterm_d1e12329" significance="normal"><primary>assert_equal( ) method</primary></indexterm></para><screen format="linespecific">assert_equal(Array.new, @parser.parse(%Q{[]}))</screen><para>This one is the most simple to trace, predictably. When <literal moreinfo="none">parse_value</literal> is called to capture the contents in
    the array, it will error out, because no JSON objects start with <literal moreinfo="none">]</literal>. James is using a clever trick that banks on a
    failed parse, because that allows him to short-circuit processing the
    contents. This error is swallowed, leaving the contents empty. The string
    is then scanned for the closing <literal moreinfo="none">]</literal>,
    which is found, and an AST-wrapped empty Ruby array is returned.</para><para>The second assertion is considerably more tricky:</para><screen format="linespecific">assert_equal( ["JSON", 3.1415, true],
  @parser.parse(%Q{["JSON", 3.1415, true]}) )</screen><para>Here, we need to rely on <literal moreinfo="none">parse_value</literal>’s ability to parse strings, numbers,
    and booleans. All three of these are done using techniques similar to
    those shown so far, but a string is a little hairy due to some tricky edge
    cases. However, to give you a few extra samples, we can take a look at the
    other two:<indexterm id="I_indexterm_d1e12354" significance="normal"><primary>parse_value method</primary><secondary>parsing strings, numbers, and booleans</secondary></indexterm></para><screen format="linespecific">def parse_number
  @input.scan(/-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?\b/) and
    AST.new(eval(@input.matched))
end

def parse_keyword
  @input.scan(/\b(?:true|false|null)\b/) and
    AST.new(eval(@input.matched.sub("null", "nil")))
end</screen><para>In both cases, James takes advantage of the similarities between
    Ruby and JSON when it comes to numbers and keywords, and essentially just
    <literal moreinfo="none">eval</literal>s the results after a bit of massaging. The numeric
    pattern is a little hairy, and you don’t necessarily need to understand
    it. Instead, the interesting thing to note about these two examples is
    their use of <literal moreinfo="none">StringScanner#matched</literal>. As
    the name suggests, this method returns the actual string that was just
    matched by the pattern. This is a common way to extract values while
    conditionally scanning for matches.<indexterm id="I_indexterm_d1e12370" significance="normal"><primary>StringScanner#matched method</primary></indexterm></para><para>This pretty much wraps up the interesting bits about getting the
    second assertion to pass. Here, the parser just keeps attempting to pull
    off new values if it can, while the array code wipes out any intermediate
    commas. Once the values are exhausted, the <literal moreinfo="none">]</literal> is then searched for, as before.</para><para>The third and final case for array parsing may initially seem
    complicated:</para><screen format="linespecific">assert_equal([1, [2, [3]]], @parser.parse(%Q{[1, [2, [3]]]}))</screen><para>However, if you recall that the way <literal moreinfo="none">parse_array</literal> works is to repeatedly call <literal moreinfo="none">parse_value</literal> until all its elements are consumed,
    it’s clear what is going on. Because an array can be parsed by <literal moreinfo="none">parse_value</literal> just the same as any other job, the
    nested arrays have no trouble repeating the same process to find their
    elements, which can also be arrays. At some point, this process bottoms
    out, and the whole structure is built up. That means that we actually get
    to pass this third assertion <emphasis>for free</emphasis>, as the
    implementation already uses recursive calls through <literal moreinfo="none">parse_value</literal>.</para><para>Although this doesn’t cover 100% of how James’s parser works, it
    gives you a good sense of when <literal moreinfo="none">StringScanner</literal> might be a good tool to have
    around. You can see how powerful it is to keep a single reference to a
    <literal moreinfo="none">StringScanner</literal> and use it in a number of
    different methods to consume a string part by part. This allows better
    decomposition of your program, and simplifies the code by removing some of
    the low-level plumbing from the equation. So next time you want to do
    regular expression processing on a string chunk by chunk rather than all
    at once, you might want to give <literal role="keep-together" moreinfo="none">StringScanner</literal> a try.<indexterm id="I_indexterm_d1e12410" class="endofrange" startref="appb_stringsparse" significance="normal"/><indexterm id="I_indexterm_d1e12411" class="endofrange" startref="appb_regexpparsing" significance="normal"/><indexterm id="I_indexterm_d1e12412" class="endofrange" startref="appb_strscanlib" significance="normal"/></para></sect1><sect1 id="I_sect1_d1e12413"><title>Cryptographic Hash Functions (digest)</title><para>Though it might not be something we do every day, having easy access
    to the common cryptographic hash functions can be handy for all sorts of
    things. The <emphasis>digest</emphasis> standard library provides several
    options, including MD5, SHA1, and SHA2. We’ll cover three simple use cases
    here: calculating the checksum of a file, uniquely hashing files based on
    their content, and encrypted password storage.<indexterm class="startofrange" id="appb_cryptohash" significance="normal"><primary>cryptographic hash functions (digest)</primary></indexterm><indexterm class="startofrange" id="appb_digestlib" significance="normal"><primary>digest standard library</primary></indexterm></para><para>I won’t get into the details about the differences between various
    hashing algorithms or their limitations. Though they all have a potential
    risk for what is known as a <emphasis>collision</emphasis>, where two
    distinct content keys are hashed to the same value, this is rare enough to
    not need to worry about in most practical scenarios. Of course, if you’re
    new to encryption in general, you will want to read up on these techniques
    elsewhere before attempting to use them for anything nontrivial. Assuming
    that you accept this responsibility, we can move on to see how these
    hashing functions can be used in your Ruby applications.<indexterm id="I_indexterm_d1e12432" significance="normal"><primary>collision, risk with hashing algorithms</primary></indexterm></para><para>We’ll start with checksums, because these are pretty easy to find in
    the wild. If you’ve downloaded open source software before, you’ve
    probably seen MD5 or SHA256 hashes before. I’ll be honest: most of the
    time I just ignore these, but they do come in handy when you want to
    verify that an automated download completed correctly. They’re also useful
    if you have a tendency toward paranoia and want to be sure that the file
    you are receiving is really what you think it is. Using the Ruby 1.9.1
    release notes themselves as an example, we can see what a digitally signed
    file download looks like:<indexterm id="I_indexterm_d1e12437" significance="normal"><primary>SHA256 hashes</primary></indexterm><indexterm id="I_indexterm_d1e12440" significance="normal"><primary>MD5 hashes</primary></indexterm><indexterm id="I_indexterm_d1e12443" significance="normal"><primary>checksums</primary></indexterm><indexterm id="I_indexterm_d1e12446" significance="normal"><primary>digitally signed file downloads</primary></indexterm></para><screen format="linespecific">== Location
* ftp://ftp.ruby-lang.org/pub/ruby/1.9/ruby-1.9.1-p0.tar.bz2
 SIZE:   7190271 bytes
 MD5:    0278610ec3f895ece688de703d99143e
 SHA256: de7d33aeabdba123404c21230142299ac1de88c944c9f3215b816e824dd33321</screen><para>Once we’ve downloaded the file, pulling the relevant hashes is
    trivial. Here’s how we’d grab the MD5 hash:<indexterm id="I_indexterm_d1e12453" significance="normal"><primary>Digest::MD5</primary></indexterm><indexterm id="I_indexterm_d1e12456" significance="normal"><primary>hexdigest( ) method</primary><secondary>calling on Digest::MD5</secondary></indexterm></para><screen format="linespecific">&gt;&gt; require "digest/md5"
=&gt; true
&gt;&gt; Digest::MD5.hexdigest(File.binread("ruby-1.9.1-p0.tar.bz2"))
=&gt; "0278610ec3f895ece688de703d99143e"</screen><para>If we preferred the slightly more secure SHA256 hash, we don’t need
    to work any harder:<indexterm id="I_indexterm_d1e12465" significance="normal"><primary>Digest::SHA256</primary></indexterm><indexterm id="I_indexterm_d1e12468" significance="normal"><primary>hexdigest( ) method</primary><secondary>calling on Digest::SHA256</secondary></indexterm></para><screen format="linespecific">&gt;&gt; require "digest/sha2"
=&gt; true
&gt;&gt; Digest::SHA256.hexdigest(File.binread("ruby-1.9.1-p0.tar.bz2"))
=&gt; "de7d33aeabdba123404c21230142299ac1de88c944c9f3215b816e824dd33321"</screen><para>As both of these match the release notes, we can be reasonably sure
    that nothing nefarious is going on, and also that our file integrity has
    been preserved. That’s the most common use of this form of hashing.</para><para>Of course, in addition to identifying a particular file uniquely,
    cryptographic hashes allow us to identify the uniqueness of a file’s
    content. If you’ve used the revision control system <literal moreinfo="none">git</literal>, you may have noticed that the revisions are
    actually identified by SHA1 hashes that describe the changesets. We can do
    similar things in our Ruby applications.<indexterm id="I_indexterm_d1e12482" significance="normal"><primary>git revision control system</primary></indexterm><indexterm id="I_indexterm_d1e12485" significance="normal"><primary>revision control system, git</primary></indexterm></para><para>For example, in Prawn, we support embedding images in PDF documents.
    Because these images can be from any number of sources ranging from a temp
    file to a directly downloaded image from the Web, we cannot rely on unique
    filenames mapping to unique images. Processing images can be pretty
    costly, especially when we do things like split out alpha channels for
    PNGs, so we want to avoid reprocessing images when we can avoid it. The
    solution to this problem is simple: we use SHA1 to generate a
    <literal moreinfo="none">hexdigest</literal> for the image content and then use that as a
    key into a hash. A rough <phrase role="keep-together">approximation</phrase> of what we’re doing looks like
    this:<indexterm id="I_indexterm_d1e12497" significance="normal"><primary>Digest::SHA1</primary></indexterm><indexterm id="I_indexterm_d1e12500" significance="normal"><primary>hexdigest( ) method</primary><secondary>calling on Digest::SHA1</secondary></indexterm><indexterm id="I_indexterm_d1e12505" significance="normal"><primary>PDF documents, embedding images in</primary></indexterm><indexterm id="I_indexterm_d1e12508" significance="normal"><primary>images, embedding in PDF documents</primary></indexterm></para><?dbfo-need height=”1in”
?><screen format="linespecific">require "digest/sha1"

def image_registry(raw_image_data)
  img_sha1 = Digest::SHA1.hexdigest(raw_image_data)
  @image_registry[img_sha1] ||= build_image_obj(raw_image_data)
end</screen><para>This technique clearly isn’t limited to PDF generation. To name just
    a couple of other use cases, I use a similar hashing technique to make
    sure the content of my blog has changed before reuploading the static
    files it generates, so it uploads only the files it needs. I’ve also seen
    this used in the context of web applications to prevent identical content
    from being copied again and again to new files. Fundamentally, these ideas
    are nearly identical to the previous code sample, so I won’t illustrate
    them explicitly.</para><para>However, while we’re on the topic of web applications, we can work
    our way into our last example: secure password storage.<indexterm id="I_indexterm_d1e12518" significance="normal"><primary>password storage, secure</primary></indexterm><indexterm id="I_indexterm_d1e12521" significance="normal"><primary>secure password storage</primary></indexterm></para><para>It should be pretty obvious that even if we restrict access to our
    databases, we should not store passwords in clear text. We have a
    responsibility to offer users a reasonable amount of privacy, and through
    cryptographic hashing, even administrators can be kept in the dark about
    what individual users’ passwords actually are. Using the techniques
    already shown, we get most of the way to a solution.</para><para>The following example is from an ActiveRecord model as part of a
    Rails application, but it is fairly easily adaptable to any system in
    which the user information is remotely stored outside of the application
    itself. Regardless of whether you are familiar with ActiveRecord, the code
    should be fairly straightforward to follow with a little explanation.
    Everything except the relevant authentication code has been omitted, to
    keep things well focused:</para><screen format="linespecific">class User &lt; ActiveRecord::Base

  def password=(pass)
    @password = pass
    salt = [Array.new(6){rand(256).chr}.join].pack("m").chomp
    self.password_salt, self.password_hash =
      salt, Digest::SHA256.hexdigest(pass + salt)
  end

  def self.authenticate(username,password)
    user = find_by_username(username)
    hash = Digest::SHA256.hexdigest(password + user.password_salt)
    if user.blank? || hash != user.password_hash
      raise AuthenticationError, "Username or password invalid"
    end

    user
  end

end</screen><para>Here we see two functions: one for setting an individual user’s
    password, and another for authenticating and looking up a user by username
    and password. We’ll start with setting the password, as this is the most
    crucial part:<indexterm id="I_indexterm_d1e12532" significance="normal"><primary>passwords, setting</primary></indexterm></para><screen format="linespecific">def password=(pass)
  @password = pass
  salt = [Array.new(6){rand(256).chr}.join].pack("m").chomp
  self.password_salt, self.password_hash =
    salt, Digest::SHA256.hexdigest(pass + salt)
end</screen><para>Here we see that the password is hashed using <literal moreinfo="none">Digest::SHA256</literal>, in a similar fashion to our
    earlier examples. However, this password isn’t directly hashed, but
    instead, is combined with a <literal moreinfo="none">salt</literal> to make it more
    difficult to guess. This technique has been shown in many Ruby cookbooks
    and tutorials, so you may have encountered it before. Essentially, what
    you are seeing here is that for each user in our database, we generate a
    random six-byte sequence and then pack it into a base64-encoded string,
    which gets appended to the password before it is hashed. This makes
    several common attacks much harder to execute, at a minimal complexity
    cost to us.<indexterm id="I_indexterm_d1e12545" significance="normal"><primary>salt, adding to password hash</primary></indexterm><indexterm id="I_indexterm_d1e12548" significance="normal"><primary>Digest::SHA256</primary></indexterm></para><para>An important thing to notice is that what we store is the
    fingerprint of the password after it has been salted rather than the
    password itself, which means that we never store the original content and
    it cannot be recovered. So although we can tell whether a given password
    matches this fingerprint, the original password cannot be retrieved from
    the data we are storing.</para><para>If this more or less makes sense to you, the <literal moreinfo="none">authenticate</literal> method will be easy to follow
    now:</para><screen format="linespecific">def self.authenticate(username,password)
  user = find_by_username(username)
  hash = Digest::SHA256.hexdigest(password + user.password_salt)
  if user.blank? || hash != user.password_hash
    raise AuthenticationError, "Username or password invalid"
  end

  user
end</screen><para>Here, we first retrieve the user from the database. Assuming that
    the username is valid, we then look up the <literal moreinfo="none">salt</literal> and add
    it to our bare password string. Because we never stored the actual
    password, but only its salted hash, we call <literal moreinfo="none">hexdigest</literal> again and compare the hash to the one
    stored in the database. If they match, we return our user object and all
    is well; if they don’t, an error is raised. This completes the cycle of
    secure password storage and authentication and demonstrates the role that
    cryptographic hashes play in it.</para><para>With that, we’ve probably talked enough about <literal moreinfo="none">digest</literal> for now. There are some more advanced
    features available, but as long as you know that <literal moreinfo="none">Digest::MD5</literal>, <literal moreinfo="none">Digest::SHA1</literal> and <literal moreinfo="none">Digest::SHA256</literal> exist and how to call <literal moreinfo="none">hexdigest()</literal> on each of them, you have all you’ll
    need to know for most occasions. Hopefully, the examples here have
    illustrated some of the common use cases, and helped you think of your own
    in the process.<indexterm id="I_indexterm_d1e12587" class="endofrange" startref="appb_digestlib" significance="normal"/><indexterm id="I_indexterm_d1e12588" class="endofrange" startref="appb_cryptohash" significance="normal"/><indexterm id="I_indexterm_d1e12589" significance="normal"><primary>Digest::SHA1</primary></indexterm><indexterm id="I_indexterm_d1e12592" significance="normal"><primary>Digest::MD5</primary></indexterm><indexterm id="I_indexterm_d1e12595" significance="normal"><primary>hexdigest( ) method</primary></indexterm></para></sect1><sect1 id="I_sect1_d1e12598"><title>Mathematical Ruby Scripts (mathn)</title><para>The <emphasis>mathn</emphasis> standard library, when combined with
    the core <literal moreinfo="none">Math</literal> module, serves to make
    mathematical operations more pleasant in Ruby. The main purpose of
    <emphasis>mathn</emphasis> is to pull in other standard libraries and
    integrate them with the rest of Ruby’s numeric system. You’ll notice this
    right away when doing basic arithmetic:<indexterm id="I_indexterm_d1e12612" significance="normal"><primary>Math module</primary></indexterm><indexterm class="startofrange" id="appb_mathn" significance="normal"><primary>mathn standard library</primary></indexterm></para><?dbfo-need height=”1in”
?><screen format="linespecific">&gt;&gt; 1 / 2
=&gt; 0
&gt;&gt; Math.sqrt(-1)
Errno::EDOM: Numerical argument out of domain - sqrt ..

&gt;&gt; require "mathn"
=&gt; true
&gt;&gt; 1 / 2
=&gt; 1/2
&gt;&gt; 1 / 2  + 5 / 7
=&gt; 17/14
&gt;&gt; Math.sqrt(-1)
=&gt; (0+1i)</screen><para>As you can see, integer division gives way when
    <emphasis>mathn</emphasis> is loaded, in favor of returning <literal moreinfo="none">Rational</literal> objects. These behave like the
    fractions you learned in grade school, and keep values in exact terms
    rather than expressing them as floats where possible. Numbers also
    gracefully extend into the <literal moreinfo="none">Complex</literal> field, without
    error. Although this sort of <phrase role="keep-together">behavior</phrase> might seem unnecessary for
    day-to-day programming needs, it can be very helpful for mathematical
    applications.<indexterm id="I_indexterm_d1e12635" significance="normal"><primary>integer division</primary></indexterm><indexterm id="I_indexterm_d1e12638" significance="normal"><primary>Rational objects</primary></indexterm></para><para>In addition to changing the way basic arithmetic works,
    <emphasis>mathn</emphasis> pulls in a few of the higher-level mathematical
    constructs. For those interested in enumerating prime numbers (for
    whatever fun reason you might have in mind), a class is provided. To give
    you a peek at how it works, we can do things like ask for the first 10
    primes or how many primes exist up to certain numbers:<indexterm id="I_indexterm_d1e12646" significance="normal"><primary>Prime class</primary></indexterm></para><screen format="linespecific">&gt;&gt; Prime.first(10)
=&gt; [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

&gt;&gt; Prime.find_index { |e| e &gt; 1000 }
=&gt; 168</screen><para>In addition to enabling <literal moreinfo="none">Prime</literal>,
    <emphasis>mathn</emphasis> also allows you to use <literal moreinfo="none">Matrix</literal> and <literal moreinfo="none">Vector</literal> without an explicit
    <literal moreinfo="none">require</literal>:<indexterm id="I_indexterm_d1e12669" significance="normal"><primary>Vector class</primary></indexterm><indexterm id="I_indexterm_d1e12672" significance="normal"><primary>Matrix class</primary></indexterm></para><screen format="linespecific">&gt;&gt; Vector[1,2,3] * 3
=&gt; Vector[3, 6, 9]
&gt;&gt; Matrix[[5,1,2],[3,1,4]].transpose
=&gt; Matrix[[5, 3], [1, 1], [2, 4]]</screen><para>These classes can do all sorts of useful linear algebra functions,
    but I don’t want to overwhelm the casual Rubyist with mathematical
    details. Instead, we’ll look at a practical use of them and leave the
    theory as a homework assignment. Consider the simple drawing in <xref linkend="fig_AB-1"/>.</para><figure float="none" id="fig_AB-1"><title>A pair of triangles with a mathematical relationship</title><mediaobject id="d1e809"><imageobject role="print"><imagedata fileref="figs/print/rubp_ab01.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/rubp_ab01.png" format="PNG"/></imageobject></mediaobject></figure><para>We see two rather exciting triangles, nuzzling up against each other
    at a single point. As it turns out, the smaller triangle is nothing more
    than a clone of the larger one, reflected, rotated, and scaled to fit.
    Here’s the code that makes all that happen:<footnote><para>To run this example, you’ll need my Prawn-based helpers. These
        are included in this book’s git repository.</para></footnote></para><screen format="linespecific">include Math

Canvas.draw("triangles.pdf") do
  points = Matrix[[0,0], [100,200], [200,100]]

  paint_triangle(*points)

  # reflect across y-axis
  points *= Matrix[[-1, 0],[0,1]]

  # rotate so bottom is flush with x axis.
  theta = -atan(1/2)
  points *= Matrix[[cos(theta), -sin(theta)],
                    [sin(theta),  cos(theta)]]

  # scale down by 50%
  points  *= 1/2
  paint_triangle(*points)
end</screen><para>You don’t need to worry about the graphics-drawing code. Instead,
    focus on the use of <literal moreinfo="none">Matrix</literal> manipulations here, and
    watch what happens to the points in each step. We start off with our
    initial triangle’s coordinates, as such:</para><screen format="linespecific">&gt;&gt; points = Matrix[[0,0], [100,200], [200,100]]
=&gt; Matrix[[0, 0], [100, 200], [200, 100]]</screen><para>Then, we multiply by a 2 × 2 matrix that performs a reflection
    across the <emphasis>y</emphasis>-axis:</para><screen format="linespecific">&gt;&gt; points *= Matrix[[-1, 0],[0,1]]
=&gt; Matrix[[0, 0], [-100, 200], [-200, 100]]</screen><para>Notice here that the <emphasis>x</emphasis> values are inverted,
    while the <emphasis>y</emphasis> value is left untouched. This is what
    translates our points from the right side to the left. Our next task uses
    a bit of trigonometry to rotate our triangle to lie flat along the
    <emphasis>x</emphasis>-axis. Notice here that we use the arctan of 1/2,
    because the bottom-edge triangle on the right rises halfway toward the
    upper boundary before terminating. If you aren’t familiar with how this
    calculation works, don’t worry—just observe its results:</para><screen format="linespecific">&gt;&gt; theta = -atan(1/2)
=&gt; -0.463647609000806
&gt;&gt; points *= Matrix[[cos(theta), -sin(theta)],
?&gt;                  [sin(theta), cos(theta)] ]
=&gt; Matrix[[0.0, 0.0], [-178.885438199983, 134.164078649987], [-223.606797749979, 0.0]]</screen><para>The numbers got a bit ugly after this calculation, but there is a
    key observation to make here. The triangle’s dimensions were preserved,
    but two of the points now lie on the <emphasis>x</emphasis>-axis. This
    means our rotation was successful.</para><para>Finally, we do scalar multiplication to drop the whole triangle down
    to half its original size:</para><screen format="linespecific">&gt;&gt; points *= 1/2
=&gt; Matrix[[0.0, 0.0], [-89.4427190999915, 67.0820393249935], [-111.803398874989, 0.0]]</screen><para>This completes the transformation and shows how the little triangle
    was developed simply by manipulating the larger one. Although this is
    certainly a bit of an abstract example, it hopefully serves as sufficient
    motivation for learning a bit more about <phrase role="keep-together">matrixes</phrase>. Although they can certainly be
    used for more hardcore calculations, simple linear transformations such as
    the ones shown in this example come cheap and easy and demonstrate an
    effective way to do some interesting graphics work.</para><para>Although truly hardcore math might be better suited for a more
    special-purpose language, Ruby is surprisingly full-featured enough to
    write interesting math programs with. As this particular topic can run far
    deeper than I have time to discuss, I will leave further investigation to
    the interested reader. The key thing to remember is that
    <emphasis>mathn</emphasis> puts Ruby in a sort of “math mode” by including
    some of the most helpful standard libraries and modifying the way that
    Ruby does its basic arithmetic. This feature is so useful that
    <emphasis>irb</emphasis> includes a special switch <literal moreinfo="none">-m</literal>, which essentially requires
    <emphasis>mathn</emphasis> and then includes the <literal moreinfo="none">Math</literal> module in at the top level.</para><para>A small caveat to keep in mind when working with
    <emphasis>mathn</emphasis> is that it is fairly aggressive about the
    changes it makes. If you are building a Ruby library, you may want to be a
    bit more conservative and use the individual packages it enables one by
    one rather than having to deal with the consequences of potentially
    breaking code that relies on <phrase role="keep-together">behaviors</phrase> such as integer division.</para><para>All that having been said, if you’re working on your math homework,
    or building a specialized mathematical application in Ruby, feel free to
    go wild with all that <emphasis>mathn</emphasis> has to offer.<indexterm id="I_indexterm_d1e12769" class="endofrange" startref="appb_mathn" significance="normal"/></para></sect1><sect1 id="I_sect1_d1e12770"><title>Working with Tabular Data (csv)</title><para>If you need to represent a data table in plain-text format, CSV
    (comma-separated value) files are about as simple as you can get. These
    files can easily be processed by almost any programming language, and Ruby
    is no exception. The <emphasis>csv</emphasis> standard library is fast for
    pure Ruby, internationalized, and downright pleasant to work
    with.<indexterm id="I_indexterm_d1e12778" significance="normal"><primary>CSV (comma-separated-value) files</primary></indexterm><indexterm class="startofrange" id="appb_csvlibrary" significance="normal"><primary>csv standard library</primary></indexterm><indexterm class="startofrange" id="appb_tabulardata" significance="normal"><primary>tabular data, working with (csv)</primary></indexterm></para><para>In the most simple cases, it’d be hard to make things easier. For
    example, say you had a CSV file (<filename moreinfo="none">payments.csv</filename>) that
    looked like this:<indexterm id="I_indexterm_d1e12792" significance="normal"><primary>csv standard library</primary><secondary>reading files</secondary></indexterm></para><screen format="linespecific">name,payment
Gregory Brown,100
Joe Comfort,150
Jon Juraschka,200
Gregory Brown,75
Jon Juraschka,250
Jia Wu,25
Gregory Brown,50
Jia Wu,75</screen><para>If you want to just slurp this into an array of arrays, it can’t be
    easier:</para><screen format="linespecific">&gt;&gt; require "csv"
=&gt; true
&gt;&gt; CSV.read("payments.csv")
=&gt; [["name", "payment"], ["Gregory Brown", "100"], ["Joe Comfort", "150"],
    ["Jon Juraschka", "200"], ["Gregory Brown", "75"], ["Jon Juraschka", "250"],
    ["Jia Wu", "25"], ["Gregory Brown", "50"], ["Jia Wu", "75"]]</screen><para>Of course, slurping files isn’t a good idea if you want to handle
    only a subset of data, but <emphasis>csv</emphasis> makes row-by-row
    handling easy. Here’s an example of how you’d capture only my
    records:</para><screen format="linespecific">&gt;&gt; data = []
=&gt; []
&gt;&gt; CSV.foreach("payments.csv") { |row| data &lt;&lt; row if row[0] == "Gregory Brown" }
=&gt; nil
&gt;&gt; data
=&gt; [["Gregory Brown", "100"], ["Gregory Brown", "75"], ["Gregory Brown", "50"]]</screen><para>A common convention is to have the first row of a CSV file represent
    header data. <emphasis>csv</emphasis> can give you nicer accessors in this
    case:</para><screen format="linespecific">&gt;&gt; data
=&gt; []
&gt;&gt; CSV.foreach("payments.csv", :headers =&gt; true) do |row|
?&gt;   data &lt;&lt; row if row['name'] == "Gregory Brown"
&gt;&gt; end
=&gt; nil
&gt;&gt; data
=&gt; [#&lt;CSV::Row "name":"Gregory Brown" "payment":"100"&gt;,
    #&lt;CSV::Row "name":"Gregory Brown" "payment":"75"&gt;,
    #&lt;CSV::Row "name":"Gregory Brown" "payment":"50"&gt;]</screen><para><literal moreinfo="none">CSV::Row</literal> is a sort of hash/array
    hybrid. The primary feature that distinguishes it from a hash is that it
    allows for duplicate field names. Here’s an example of how that works.
    Given a simple file with nonunique column names like this
    (<filename moreinfo="none">phone_numbers.csv</filename>):<indexterm id="I_indexterm_d1e12824" significance="normal"><primary>CSV::Row</primary></indexterm></para><screen format="linespecific">applicant,phone_number,spouse,phone_number
James Gray,555 555 5555,Dana Gray,123 456 7890
Gregory Brown,098 765 4321,Jia Wu,222 222 2222</screen><para>we can extract both <literal moreinfo="none">"phone_number"</literal> fields, as shown here:</para><screen format="linespecific">&gt;&gt; data = CSV.read("phone_numbers.csv", :headers =&gt; true)
=&gt; #&lt;CSV::Table mode:col_or_row row_count:3&gt;
&gt;&gt; data.map { |r| r["phone_number"], r["phone_number",2] }
=&gt; [["555 555 5555", "123 456 7890"], [" 098 765 4321", "222 222 2222"]]</screen><para>We see that <literal moreinfo="none">CSV::Row#[]</literal> takes an optional second
    argument that is an offset from which to begin looking for a field name.
    For this particular data, <literal moreinfo="none">r["phone_number",0]</literal> and <literal moreinfo="none">r["phone_number",1]</literal> would resolve as the first
    phone number field; an index of 2 or 3 would look up the second phone
    number. If we know the names of the columns near each phone number, we can
    do this in a bit of a smarter way:</para><screen format="linespecific">&gt;&gt; data.map { |r| [ r["phone_number", r.index("applicant")],
?&gt;                  r["phone_number", r.index("spouse")] ] }
=&gt; [[" 555 555 5555", "123 456 7890"], ["098 765 4321", "222 222 2222"]]</screen><para>Although this still depends on ordinal positioning to some extent,
    it allows us to do a relative index lookup. If we know that “phone number”
    is always going to be next to “applicant” and “spouse,” it doesn’t matter
    which column they start at. Whenever you can take advantage of this sort
    of flexibility, it’s a good idea to do so.</para><para>So far, we’ve talked about reading files, but the
    <emphasis>csv</emphasis> library handles writing as well. Rather than
    continue with our <emphasis>irb</emphasis>-based exploration, I’ll just
    combine the features that we’ve already gone over with a couple new ones,
    so that we can look at a tiny but fully functional script.<indexterm id="I_indexterm_d1e12860" significance="normal"><primary>reports, writing from CSV files</primary></indexterm><indexterm id="I_indexterm_d1e12863" significance="normal"><primary>csv standard library</primary><secondary>writing summary report from CSV file</secondary></indexterm></para><para>Our task is to convert the previously mentioned
    <filename moreinfo="none">payments.csv</filename> file into a summary report
    (<filename moreinfo="none">payment_summary.csv</filename>), which will look like
    this:<indexterm id="I_indexterm_d1e12876" significance="normal"><primary>grouping-and-summing operation</primary></indexterm></para><screen format="linespecific">name,total payments
Gregory Brown,225
Joe Comfort,150
Jon Juraschka,450
Jia Wu,100</screen><para>Here, we’ve done a grouping on name and summed up the payments. If
    you thought this might be a complicated process, you thought wrong. Here’s
    all that needs to be done:</para><?dbfo-need height=”1in”
?><screen format="linespecific">require "csv"

@totals = Hash.new(0)

csv_options = {:headers =&gt; true, :converters =&gt; :numeric }

CSV.foreach("payments.csv", csv_options) do |row|
  @totals[row['name']] += row['payment']
end

CSV.open("payment_summary.csv", "w") do |csv|
  csv &lt;&lt; ["name","total payments"]
  @totals.each { |row| csv &lt;&lt; row }
end</screen><para>The core mechanism for doing the grouping-and-summing operation is
    just a hash with default values of zero for unassigned keys. If you
    haven’t seen this technique before, be sure to make a note of it, because
    you’ll see it all over Ruby scripts. The rest of the work is easy once we
    exploit this little trick.</para><para>As far as processing the initial CSV file goes, the only new trick
    we’ve added is to specify the option <literal moreinfo="none">:converters
    =&gt; :numeric</literal>. This tells <emphasis>csv</emphasis> to hit each
    cell with a check to see whether it contains a valid Ruby number. It then
    does the right thing and converts it to a <literal moreinfo="none">Fixnum</literal> or <literal moreinfo="none">Float</literal> if there’s a match. This lets us normalize
    our data as soon as it’s loaded, rather than litter our code with <literal moreinfo="none">to_i</literal> and <literal moreinfo="none">to_f</literal>
    calls.</para><para>For this reason, the <literal moreinfo="none">foreach</literal> loop
    is nothing more than simple addition, keying the name to a running total
    of payments.</para><para>Finally, we get to the writing side of things. We use <literal moreinfo="none">CSV.open</literal> in a similar way to how we might use
    <literal moreinfo="none">File.open</literal>, and we populate a <literal moreinfo="none">CSV</literal> object by shoving arrays that represent rows
    into it. This code is a little prettier than it might be in the general
    case, as we’re working with only two columns, but you should be able to
    see that the process is relatively straightforward nonetheless.<indexterm id="I_indexterm_d1e12926" significance="normal"><primary>CSV.open method</primary></indexterm></para><para>Here we see a useful little script based on the
    <emphasis>csv</emphasis> library weighing in at around 10 lines of code.
    As impressive as that might be, we haven’t even scratched the surface on
    this one, so be sure to dig deeper if you have a need for processing
    tabular datafiles. One thing that I didn’t show at all is that
    <emphasis>csv</emphasis> handles reading and writing from strings just as
    well as it does files, which may be useful in web applications and other
    places where there is a need to stream files rather than work directly
    with the filesystem. Another is dealing with different column and row
    record separators. Luckily, the <emphasis>csv</emphasis> library is
    comparably well documented, so all of these things are just a quick API
    documentation search away.</para><para>A great thing about the newly revamped <emphasis>csv</emphasis>
    standard library is that you don’t necessarily need to upgrade to Ruby 1.9
    to use it. It started as a third-party alternative to Ruby 1.8’s CSV
    standard library, under the name <literal moreinfo="none">FasterCSV</literal>, and this project is still supported
    under Ruby 1.8.6. So if you like what you see here, and you want to use it
    in some of your legacy Ruby code, you can always install the
    <emphasis>fastercsv</emphasis> gem and be up and running.<indexterm id="I_indexterm_d1e12951" significance="normal"><primary>fastercsv gem</primary></indexterm><indexterm id="I_indexterm_d1e12954" class="endofrange" startref="appb_tabulardata" significance="normal"/><indexterm id="I_indexterm_d1e12955" class="endofrange" startref="appb_csvlibrary" significance="normal"/></para></sect1><sect1 id="I_sect1_d1e12956"><title>Transactional Filesystem-Based Data Storage (pstore)</title><para><literal moreinfo="none">PStore</literal> provides a simple,
    transactional database for storing Ruby objects within a file. This gives
    you a persistence layer without relying on any external resources, which
    can be very handy. Using <literal moreinfo="none">PStore</literal> is so
    simple that I can forgo most of the details and jump right into some code
    that I use for a Sinatra microapp at work. What follows is a very simple
    backend for storing replies to an anonymous survey:<indexterm class="startofrange" id="appb_transactfsstorage" significance="normal"><primary>transactional filesystem-based data storage</primary></indexterm><indexterm class="startofrange" id="appb_pstorelib" significance="normal"><primary>pstore standard library</primary></indexterm></para><screen format="linespecific">class SuggestionBox
  def initialize(filename="suggestions.pstore")
    @filename = filename
  end

  def store
    @store ||= PStore.new(@filename)
  end

  def add_reply(reply)
    store.transaction do
      store[:replies] ||= []
      store[:replies] &lt;&lt; reply
    end
  end

  def replies(readonly=true)
    store.transaction do
      store[:replies]
    end
  end

  def clear_replies
    store.transaction do
      store[:replies] = []
    end
  end
end</screen><para>In our application, the usage of this object for storing responses
    is quite simple. Given that <literal moreinfo="none">box</literal> is just
    a <literal moreinfo="none">SuggestionBox</literal> in the following code,
    we just have a single call to <literal moreinfo="none">add_reply</literal>
    that looks something like this:</para><screen format="linespecific">box.add_reply(:question1 =&gt; params["question1"],
              :question2 =&gt; params["question2"])</screen><para>Later, when we need to generate a PDF report of all the replies in
    the suggestion box, we do something like this to extract the responses to
    the two questions:</para><screen format="linespecific">question1_replies = []
question2_replies = []
box.replies.each do |reply|
  question1_replies &lt;&lt; reply[:question1]
  question2.replies &lt;&lt; reply[:question2]
end</screen><para>So that covers the usage, but let’s go back in a little more detail
    to the implementation. You can see that our <literal moreinfo="none">store</literal> is initialized by just constructing a new
    <literal moreinfo="none">PStore</literal> object and passing it a filename:<indexterm id="I_indexterm_d1e12999" significance="normal"><primary>PStore objects, constructing and using</primary></indexterm></para><screen format="linespecific">def store
  @store ||= PStore.new(@filename)
end</screen><para>Then, when it comes to using our <literal moreinfo="none">PStore</literal>, it
    basically looks like we’re dealing with a hash-like object, but all of our
    interactions with it are through these <literal moreinfo="none">transaction</literal> blocks:</para><screen format="linespecific">def add_reply(reply)
  store.transaction do
    store[:replies] ||= []
    store[:replies] &lt;&lt; reply
  end
end

def replies
  store.transaction(readonly=true) do
    store[:replies]
  end
end

def clear_replies
  store.transaction do
    store[:replies] = []
  end
end</screen><para>So the real question here is what do we gain? The answer is,
    predictably, a whole lot.<footnote><para>The following paragraph summarizes a
        <emphasis>ruby-talk</emphasis> post from Ara T. Howard, found at
        <ulink url="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/177666"/>.</para></footnote></para><para>By using <literal moreinfo="none">PStore</literal>, we can be sure
    that only one write-mode transaction is open at a time, preventing issues
    with partial reads/writes in multiprocessed applications. This means that
    if we attempt to produce a report against <literal moreinfo="none">SuggestionBox</literal> while a new suggestion is being
    written, our report will wait until the write operation completes before
    it processes. However, when all transactions are read-only, they will not
    block each other, allowing them to run concurrently.</para><para>Every transaction reloads the file at its start, keeping things
    up-to-date and synchronized. Every write that is done checks the MD5 sum
    of the contents to avoid unnecessary writes for unchanging data. If
    something goes wrong during a write, all the write operations in a
    transaction are rolled back and an exception is raised. In short, <literal moreinfo="none">PStore</literal> provides a fairly robust persistence
    framework that is suitable for use across multiple applications or
    threads.<indexterm id="I_indexterm_d1e13038" significance="normal"><primary>MD5 checksums, using to check for changes in data</primary></indexterm></para><para>Of course, though it is great for what it does, <literal moreinfo="none">PStore</literal> has notable limitations. Because it loads
    the entire dataset on every read, and writes the whole dataset on every
    write, it is very I/O-intensive. Therefore, it’s not meant to handle very
    high load or large datasets. Additionally, as it is essentially nothing
    more than a file-based <literal moreinfo="none">Hash</literal> object, it
    cannot serve as a substitute for some sort of SQL server when dealing with
    relational data that needs to be efficiently queried. Finally, because it
    uses the core utility <literal moreinfo="none" role="keep-together">Marshal</literal> to serialize objects to
    disk,<footnote><para>The <emphasis>yaml/store</emphasis> library will allow you to
        use YAML in place of <literal moreinfo="none">Marshal</literal>, but with many of the
        same limitations.</para></footnote> <literal moreinfo="none">PStore</literal> cannot be used to
    store certain objects. These include anonymous classes and <literal moreinfo="none">Proc</literal> objects, among other things.</para><para>Despite these limitations, <literal moreinfo="none">PStore</literal> has a very wide
    sweet spot in which it is the right way to go. Whenever you need to
    persist a modest amount of nonrelational data and possibly share it across
    processes or threads, it is usually the proper tool for the job. Although
    it is possible to code up your own persistence solutions on top of Ruby’s
    raw serialization support, <literal moreinfo="none">PStore</literal>
    solves most of the common needs in a rather elegant way.<indexterm id="I_indexterm_d1e13077" class="endofrange" startref="appb_transactfsstorage" significance="normal"/><indexterm id="I_indexterm_d1e13078" class="endofrange" startref="appb_pstorelib" significance="normal"/></para></sect1><sect1 id="I_sect1_d1e13080"><title>Human-Readable Data Serialization (json)</title><para><ulink url="http://json.org/">JavaScript Object Notation
    (JSON)</ulink> is an object serialization format that has been gaining a
    ton of steam lately. With the rise of a service-oriented Web, the need for
    a simple, language-independent data serialization format has become more
    and more apparent.<indexterm id="I_indexterm_d1e13087" significance="normal"><primary>JSON (JavaScript Object Notation)</primary></indexterm><indexterm class="startofrange" id="appb_serialhuman" significance="normal"><primary>serialization</primary><secondary>human-readable (json)</secondary></indexterm><indexterm class="startofrange" id="appb_jsonlib" significance="normal"><primary>json standard library</primary></indexterm></para><para>Historically, XML has been used for interoperable data
    serialization. However, using XML for this is a bit like going bird
    hunting with a bazooka: it’s just way more firepower than the job
    requires. JSON aims to do one thing and do it well, and these constraints
    give rise to a human-readable, human-editable, easy-to-parse, and
    easy-to-produce data interchange format.</para><para>The primitive constructs provided by JSON are limited to hashes
    (called <emphasis>objects</emphasis> in JSON), arrays, strings, numbers,
    and the conditional triumvirate of <literal moreinfo="none">true</literal>, <literal moreinfo="none">false</literal>,
    and <literal moreinfo="none">nil</literal> (called <literal moreinfo="none">null</literal> in JSON). It’s easy to see that these
    concepts trivially map to core Ruby objects. Let’s take a moment to see
    how each of these data types are represented in JSON:<indexterm id="I_indexterm_d1e13118" significance="normal"><primary>JSON (JavaScript Object Notation)</primary><secondary>primitive constructs provided by</secondary></indexterm></para><programlisting id="I_programlisting_d1e13123" format="linespecific">require "json"

hash = { "Foo" =&gt; [Math::PI, 1, "kittens"],
         "Bar" =&gt; [false, nil, true], "Baz" =&gt; { "X" =&gt; "Y" } } #...

puts hash.to_json #=&gt; Outputs
{"Foo":[3.14159265358979,1,"kittens"],"Bar":[false,null,true],"Baz":{"X":"Y"}}</programlisting><para>There isn’t really much to it. In fact, JSON is somewhat
    syntactically similar to Ruby. Though the similarity is only superficial,
    it is nice to be able to read and write structures in a format that
    doesn’t feel completely alien.</para><para>If we go the other direction, from JSON into Ruby, you’ll see that
    the transformation is just as easy:<indexterm id="I_indexterm_d1e13129" significance="normal"><primary>JSON (JavaScript Object Notation)</primary><secondary>converting JSON to Ruby</secondary></indexterm></para><programlisting id="I_programlisting_d1e13134" format="linespecific">require "json"

json_string = '{"Foo":[3.14159265358979,1,"kittens"], ' +
              '"Bar":[false,null,true],"Baz":{"X":"Y"}}'

hash = JSON.parse(json_string)

p hash["Bar"] #=&gt; Outputs
[false,nil,true]

p hash["Baz"] #=&gt; Outputs
{ "X"=&gt;"Y" }</programlisting><para>Without knowing much more about Ruby’s <emphasis>json</emphasis>
    standard library, you can move on to building useful things. As long as
    you know how to navigate the nested hash and array structures, you can
    work with pretty much any service that exposes a JSON interface as if it
    were responding to you with Ruby structures. As an example, we can look at
    a fairly simple interface that does a web search and processes the JSON
    dataset it returns:</para><programlisting id="I_programlisting_d1e13141" format="linespecific">require "json"
require "open-uri"
require "cgi"

module GSearch
  extend self

  API_BASE_URI =
    "http://ajax.googleapis.com/ajax/services/search/web?v=1.0&amp;q="

  def show_results(query)
    results = response_data(query)
    results["responseData"]["results"].each do |match|
      puts CGI.unescapeHTML(match["titleNoFormatting"]) + ":\n  " + match["url"]
    end
  end

  def response_data(query)
    data = open(API_BASE_URI + URI.escape(query),
                  "Referer" =&gt; "http://rubybestpractices.com").read
    JSON.parse(data)
  end

end</programlisting><para>Here we’re using <emphasis>json</emphasis> and the
    <emphasis>open-uri</emphasis> library, which was discussed earlier in this
    <phrase role="keep-together">appendix</phrase> as a way to wrap a simple
    Google web search. When run, this code will print out a few page titles
    and their URLs for any query you enter. Here’s a sample of <literal moreinfo="none">GSearch</literal> in action:<indexterm id="I_indexterm_d1e13157" significance="normal"><primary>search results, from Google web search</primary></indexterm><indexterm id="I_indexterm_d1e13160" significance="normal"><primary>open-uri standard library</primary><secondary>using with json</secondary></indexterm><indexterm id="I_indexterm_d1e13166" significance="normal"><primary>GSearch.show_results method</primary></indexterm></para><?dbfo-need height=”1in”
?><programlisting id="I_programlisting_d1e13171" format="linespecific">GSearch.show_results("Ruby Best Practices") # OUTPUTS

Ruby Best Practices: Rough Cuts Version | O'Reilly Media:
  http://oreilly.com/catalog/9780596156749/
Ruby Best Practices: The Book and Interview with Gregory Brown:
  http://www.rubyinside.com/ruby-best-practices-gregory-brown-interview-1332.html
On Ruby: A 'Ruby Best Practices' Blogging Contest:
  http://on-ruby.blogspot.com/2008/12/ruby-best-practices-blogging-contest.html
Gluttonous : Rails Best Practices, Tips and Tricks:
  http://glu.ttono.us/articles/2006/02/06/rails-best-practices-tips-and-tricks</programlisting><para>Maybe by the time this book comes out, we’ll have nabbed all four of
    the top spots, but that’s beside the point. You’ll want to notice that the
    <literal moreinfo="none">GSearch</literal> module interacts with the
    <emphasis>json</emphasis> library in a sum total of one line, in order to
    convert the dataset into Ruby. After that, the rest is business as
    usual.</para><para>The interesting thing about this particular example is that I didn’t
    read any of the documentation for the search API. Instead, I tried a
    sample query, converted the JSON to Ruby, and then used <literal moreinfo="none">Hash#keys</literal> to tell me what attributes were
    available. From there I continued to use ordinary Ruby reflection and
    inspection techniques straight from <emphasis>irb</emphasis> to figure out
    which fields were needed to complete this example. By thinking of JSON
    datasets as nothing more than the common primitive Ruby objects, you can
    accomplish a lot using the skills you’re already familiar with.<indexterm id="I_indexterm_d1e13189" significance="normal"><primary>Hash#keys method</primary></indexterm></para><para>After seeing how easy it is to consume JSON, you might be wondering
    how you’d go about producing it using your own custom objects. As it turns
    out, there really isn’t that much to it. Say, for example, you had a
    <literal moreinfo="none">Point</literal> class that was responsible for
    doing some calculations, but that at its essence it was basically just an
    ordered pair representing an
    [<emphasis>x</emphasis>,<emphasis>y</emphasis>] coordinate. Producing the
    JSON to match this is easy:<indexterm id="I_indexterm_d1e13203" significance="normal"><primary>JSON (JavaScript Object Notation)</primary><secondary>producing, using your custom objects</secondary></indexterm></para><programlisting id="I_programlisting_d1e13208" format="linespecific">require "json"

class Point

  def initialize(x,y)
    @x, @y = x, y
  end

  def distance_to(point)
    Math.hypot(point.x - x, point.y - y)
  end

  attr_reader :x, :y

  def to_json(*args)
    [x,y].to_json(*args)
  end

end

point_a = Point.new(1,2)
puts point_a.to_json #=&gt; "[1,2]"

point_data = JSON.parse('[4,6]')
point_b = Point.new(*point_data)

puts point_b.distance_to(point_a) #=&gt; 5.0</programlisting><para>Here, we have simply represented our core data in primitives and
    then wrapped our object model around it. In many cases, this is the most
    simple, implementation-<phrase role="keep-together">independent</phrase>
    way to represent one of our objects.</para><para>However, in some cases you may wish to let the object internally
    interpret the structure of a JSON document and do the wrapping for you.
    The Ruby <emphasis>json</emphasis> library provides a simple hook that
    depends on a bit of metadata to convert our parsed JSON into a customized
    higher-level Ruby object. If we rework our example, we can see how it
    works:<indexterm id="I_indexterm_d1e13220" significance="normal"><primary>JSON (JavaScript Object Notation)</primary><secondary>converting parsed JSON into custom higher-level Ruby
        object</secondary></indexterm></para><programlisting id="I_programlisting_d1e13225" format="linespecific">require "json"

class Point
  def initialize(x,y)
    @x, @y = x, y
  end

  def distance_to(point)
    Math.hypot(point.x - x, point.y - y)
  end

  attr_reader :x, :y

  def to_json(*args)
    { 'json_class' =&gt; self.class.name,
      'data' =&gt; [@x, @y] }.to_json(*args)
  end

  def self.json_create(obj)
    new(*obj['data'])
  end
end

point_a = Point.new(1,2)
puts point_a.to_json #=&gt; {"json_class":"Point","data":[1,2]}


point_b = JSON.parse('{"json_class":"Point","data":[4,6]}')
puts point_b.distance_to(point_a) #=&gt; 5.0</programlisting><para>Although a little more work needs to be done here, we can see that
    the underlying mechanism for a direct Ruby→JSON→Ruby round trip is simple.
    The JSON library depends on the attribute <literal moreinfo="none">json_class</literal>, which points to a string that
    represents a Ruby class name. If this class has a method called <literal moreinfo="none">json_create</literal>, the parsed JSON data is passed to
    this method and its return value is returned by <literal moreinfo="none">JSON.parse</literal>. Although this approach involves
    rolling up our sleeves a bit, it is nice to see that there is not much
    magic to it.<indexterm id="I_indexterm_d1e13238" significance="normal"><primary>json_create method</primary></indexterm><indexterm id="I_indexterm_d1e13241" significance="normal"><primary>json_class attribute</primary></indexterm></para><para>Although this adds some extra noise to our JSON output, it does not
    add any new constructs, so there is not an issue with other programming
    languages being able to parse it and use the underlying data. It simply
    comes with the added benefit of Ruby applications being able to simply map
    raw primitive data to the classes that wrap them.</para><para>Depending on your needs, you may prefer one technique over the
    other. The benefit of providing a simple <literal moreinfo="none">to_json</literal> hook that produces raw primitive values
    is that it keeps your serialized data completely implementation-agnostic.
    This will come in handy if you need to support a wide range of clients.
    The benefit of using the <literal moreinfo="none">"json_class"</literal>
    attribute is that you do not have to think about manually building up
    high-level objects from your object data. This is most beneficial when you
    are serving up data to primarily Ruby clients, or when your data is
    complex enough that manually constructing objects would be painful.</para><para>No matter what your individual needs are, it’s safe to say that JSON
    is something to keep an eye on moving forward. Ruby’s implementation is
    fast and easy to work with. If you need to work with or write your own web
    services, this is definitely a tool you will want to familiarize yourself
    with.<indexterm id="I_indexterm_d1e13257" class="endofrange" startref="appb_serialhuman" significance="normal"/><indexterm id="I_indexterm_d1e13258" class="endofrange" startref="appb_jsonlib" significance="normal"/></para></sect1><sect1 id="I_sect1_d1e13259"><title>Embedded Ruby for Code Generation (erb)</title><para>Code generation can be useful for dynamically generating static
    files based on a template. When we need this sort of functionality, we can
    turn to the <emphasis>erb</emphasis> standard library. ERB stands for
    <emphasis>Embedded Ruby</emphasis>, which is ultimately exactly what the
    library facilitates.<indexterm class="startofrange" id="appb_codegenERB" significance="normal"><primary>code generation with Embedded Ruby (erb)</primary></indexterm><indexterm id="I_indexterm_d1e13273" significance="normal"><primary>Embedded Ruby (ERB)</primary></indexterm><indexterm class="startofrange" id="appb_erblib" significance="normal"><primary>erb (Embedded Ruby) standard library</primary></indexterm></para><para>In the most basic case, a simple ERB template<indexterm id="I_indexterm_d1e13281" significance="normal"><primary>ERB templates</primary><secondary>creating</secondary></indexterm><footnote><para>Credit: this is the first example in the ERB API
        documentation.</para></footnote> might look like this:</para><programlisting id="I_programlisting_d1e13290" format="linespecific">require 'erb'

x = 42
template = ERB.new("The value of x is: &lt;%= x %&gt;")
puts template.result(binding)</programlisting><para>The resulting text looks like this:</para><programlisting id="I_programlisting_d1e13294" format="linespecific">The value of x is: 42</programlisting><para>If you’ve not worked with ERB before, you may be wondering how this
    differs from ordinary string interpolation, such as this:<indexterm id="I_indexterm_d1e13298" significance="normal"><primary>string interpolation versus ERB</primary></indexterm></para><programlisting id="I_programlisting_d1e13301" format="linespecific">x = 42
puts "The value of x is: #{x}"</programlisting><para>The key difference to recognize here is the way the two strings are
    evaluated. When we use string interpolation, our values are substituted
    immediately. When we evaluate an ERB template, we do not actually evaluate
    the expression inside the <literal moreinfo="none">&lt;%= ...
    %&gt;</literal> until we call <literal moreinfo="none">ERB#result</literal>. That means that although this code
    does not work at all:<indexterm id="I_indexterm_d1e13311" significance="normal"><primary>ERB#result method</primary></indexterm></para><programlisting id="I_programlisting_d1e13314" format="linespecific">string = "The value of x is: #{x}"
x = 42
puts string</programlisting><para>the following code will work without any problems:</para><programlisting id="I_programlisting_d1e13319" format="linespecific">require 'erb'

template = ERB.new("The value of x is: &lt;%= x %&gt;")
x = 42

puts template.result(binding)</programlisting><para>This is the main reason why ERB can be useful to us. We can write
    templates ahead of time, referencing variables and methods that may not
    exist yet, and then bind them just before rendering time using <literal moreinfo="none">binding</literal>.<indexterm id="I_indexterm_d1e13326" significance="normal"><primary>binding data to a template</primary></indexterm><indexterm id="I_indexterm_d1e13329" significance="normal"><primary>ERB.new method</primary></indexterm></para><para>We can also include some logic in our files, to determine what
    should be printed:</para><programlisting id="I_programlisting_d1e13334" format="linespecific">require "erb"

class A

  def initialize(x)
    @x = x
  end

  attr_reader :x

  public :binding

  def eval_template(string)
    ERB.new(string,0,'&lt;&gt;').result(binding)
  end

end

template = &lt;&lt;-EOS
&lt;% if x == 42 %&gt;
You have stumbled across the Answer to the Life, the Universe, and Everything
&lt;% else %&gt;
The value of x is &lt;%= x %&gt;
&lt;% end %&gt;
EOS

foo = A.new(10)
bar = A.new(21)
baz = A.new(42)

[foo, bar, baz].each { |e| puts e.eval_template(template) }</programlisting><para>Here, we run the same template against three different objects,
    evaluating it within the context of each of their bindings. The more
    complex <literal moreinfo="none">ERB.new</literal> call here sets the
    <literal moreinfo="none">safe_level</literal> the template is executed in to 0 (the
    default), but this is just because we want to provide the third argument,
    <literal moreinfo="none">trim_mode</literal>. When <literal moreinfo="none">trim_mode</literal> is set to
    <literal moreinfo="none">"&lt;&gt;"</literal>, the newlines are omitted
    for lines starting with <literal moreinfo="none">&lt;%</literal> and
    ending with <literal moreinfo="none">%&gt;</literal>. As this is useful
    for embedding logic, we need to turn it on to keep the generated string
    from having ugly stray newlines. The final output of the script looks like
    this:<indexterm id="I_indexterm_d1e13360" significance="normal"><primary>trim_mode</primary></indexterm><indexterm id="I_indexterm_d1e13363" significance="normal"><primary>safe_level</primary></indexterm></para><programlisting id="I_programlisting_d1e13366" format="linespecific">The value of x is 10
The value of x is 21
You have stumbled across the Answer to the Life, the Universe, and Everything</programlisting><para>As you can see, ERB does not emit text when it is within a
    conditional block that is not satisfied. This means a lot in the way of
    building up dynamic output, as you can use all your normal control
    structures to determine what text should and should not be
    rendered.</para><para>The documentation for the <emphasis>erb</emphasis> library is quite
    good, so I won’t attempt to dig much deeper here. Of course, no mention of
    ERB would be complete without an example of HTML templating. Although the
    API documentation goes into much more complicated examples, I can’t resist
    showing the template that I use for rendering entries in my blog
    engine.<indexterm id="I_indexterm_d1e13375" significance="normal"><primary>HTML templating with ERB</primary></indexterm><footnote><para>See <ulink url="http://github.com/sandal/blaag">http://github.com/sandal/blaag</ulink>.</para></footnote> This doesn’t include the site layout, but just the code that
    gets run for each entry:</para><programlisting id="I_programlisting_d1e13385" format="linespecific">&lt;h2&gt;&lt;%= title %&gt;&lt;/h2&gt;

&lt;%= entry %&gt;

&lt;div align="right"&gt;
&lt;p&gt;&lt;small&gt;Written by &lt;%= Blaag::AUTHOR %&gt; on
&lt;%= published_date.strftime("%Y.%m%.%d") %&gt; at
&lt;%= published_date.strftime("%H:%M" )%&gt;  | &lt;%= related %&gt;
&lt;/small&gt;
  &lt;/p&gt;
&lt;/div&gt;</programlisting><para>This code is evaluated in the context of a <literal moreinfo="none">Blaag::Entry</literal> object, which, as you can clearly
    see, does most of the heavy lifting through helper methods. Although this
    example might be boring and a bit trivial, it shows something worth
    keeping in mind. Just because you can do all sorts of logic in your ERB
    templates doesn’t mean that you should. The fact that these templates can
    be evaluated in a custom binding means that you are able to keep your code
    where it should be while avoiding messy string interpolation. If your ERB
    templates start to look more like Ruby scripts than templates, you’ll want
    to clean things up before you start pulling your hair out.<indexterm id="I_indexterm_d1e13392" significance="normal"><primary>Blaag::Entry objects</primary></indexterm></para><para>Using <literal moreinfo="none">ERB</literal> for templating can
    really come in handy. Whether you need to generate a form letter or just
    plug some values into a complicated data format, the ability to late-bind
    data to a template and generate dynamic content on the fly from static
    templates is powerful indeed. Just be sure to keep in mind that ERB is
    meant to supplement your ordinary code rather than replace it, and you’ll
    be able to take advantage of this useful library without creating a big
    mess.<indexterm id="I_indexterm_d1e13400" class="endofrange" startref="appb_codegenERB" significance="normal"/><indexterm id="I_indexterm_d1e13401" class="endofrange" startref="appb_erblib" significance="normal"/></para></sect1><sect1 id="I_sect1_d1e13402"><title>Conclusions</title><para>Hopefully these examples have shown the diversity you can come to
    expect from Ruby’s standard library. What you have probably noticed by now
    is that there really is a lot there—so much so that it might be a little
    overwhelming at first. Another observation you may have made is that there
    seems to be little consistency in interface between the libraries. This is
    because many were written by different people at different stages in
    Ruby’s evolution.</para><para>However, assuming that you can tolerate the occasional wart, a solid
    working knowledge of what is available in Ruby’s standard libraries is a
    key part of becoming a masterful Rubyist. It goes beyond simply knowing
    about and using these tools, though. Many of the libraries discussed here
    are written in pure Ruby, which means that you can actually learn a lot by
    grabbing a copy of Ruby’s source and reading through their
    implementations. I know I’ve learned a lot in this manner, so I
    wholeheartedly recommend it as a way to test and polish your Ruby
    chops.</para></sect1></appendix><appendix><title>Ruby Worst Practices</title><para>If you’ve read through most of this book, you’ll notice that it
  doesn’t have much of a “Do this, not that” theme. Ruby as a language doesn’t
  fit well into that framework, as there are always exceptions to any rule you
  can come up with.<indexterm id="I_indexterm_d1e13414" significance="normal"><primary>worst practices</primary><see>Ruby worst practices</see></indexterm><indexterm class="startofrange" id="appc_worst" significance="normal"><primary>Ruby worst practices</primary></indexterm></para><para>However, there are certainly a few things you really shouldn’t do,
  unless you know exactly why you are doing them. This appendix is meant to
  cover a handful of those scenarios and show you some better alternatives.
  I’ve done my best to stick to issues that I’ve been bit by myself, in the
  hopes that I can offer some practical advice for problems you might actually
  have run into.</para><para>A bad practice in programming shouldn’t simply be characterized as
  some ill-defined aesthetic imposed upon folks by the “experts.” Instead, we
  can often track antipatterns in code down to either flaws in the high-level
  design of an object-oriented system, or failed attempts at cleverness in the
  underlying feature implementations. These bits of unsavory code produced by
  bad habits or the misunderstanding of certain Ruby peculiarities can be a
  drag on your whole project, creating substantial technical debt as they
  <phrase role="keep-together">accumulate</phrase>.</para><para>We’ll start with the high-level design issues and then move on to the
  common sticking points when implementing tricky Ruby features. Making an
  improvement to even a couple of these problem areas will make a major
  difference, so even if you already know about most of these pitfalls, you
  might find one or two tips that will go a long way.</para><sect1 id="I_sect1_d1e13431"><title>Not-So-Intelligent Design</title><para>Well-designed object-oriented systems can be a dream to work with.
    When every component seems to fit together nicely, with clear, simple
    integration code between the major subsystems, you get the feeling that
    the architecture is working for you, and not against you.<indexterm id="I_indexterm_d1e13436" significance="normal"><primary>Ruby worst practices</primary><secondary>unintelligent design</secondary></indexterm></para><para>If you’re not careful, all of this can come crashing down. Let’s
    look at a few things to watch out for, and how to get around them.</para><sect2><title>Class Variables Considered Harmful</title><para>Ruby’s class variables are one of the easiest ways to break
      encapsulation and create headaches for yourself when designing class
      hierarchies. To demonstrate the problem, I’ll show an example in which
      class variables were tempting but ultimately the wrong
      solution.<indexterm class="startofrange" id="appc_classvariables" significance="normal"><primary>class variables</primary></indexterm><indexterm class="startofrange" id="appc_worstclassvariables" significance="normal"><primary>Ruby worst practices</primary><secondary>unintelligent design</secondary><tertiary>class variables</tertiary></indexterm></para><para>In my abstract formatting library <emphasis>fatty</emphasis>, I
      provide a formatter base class that users must inherit from to make use
      of the system. This provides helpers that build up anonymous classes for
      certain formats. To get a sense of what this looks like, check out this
      example:</para><programlisting id="I_programlisting_d1e13463" format="linespecific">class Hello &lt; FattyRBP::Formatter
  format :text do
    def render
      "Hello World"
    end
  end

  format :html do
    def render
      "&lt;b&gt;Hello World&lt;/b&gt;"
    end
  end
end

puts Hello.render(:text) #=&gt; "Hello World"
puts Hello.render(:html) #=&gt; "&lt;b&gt;Hello World&lt;/b&gt;"</programlisting><para>Though I’ve omitted most of the actual functionality that
      <emphasis>fatty</emphasis> provides, a simple <phrase role="keep-together">implementation</phrase> of this system using class
      variables might look like this:</para><programlisting id="I_programlisting_d1e13473" format="linespecific">module FattyRBP
  class Formatter
     @@formats = {}

     def self.format(name, options={}, &amp;block)
       @@formats[name] = Class.new(FattyRBP::Format, &amp;block)
     end

     def self.render(format, options={})
       @@formats[format].new(options).render
     end
   end

   class Format
     def initialize(options)
       # not important
     end

     def render
       raise NotImplementedError
     end
   end
end</programlisting><para>This code will make the example shown earlier work as advertised.
      Now let’s see what happens when we add another subclass into the
      mix:</para><programlisting id="I_programlisting_d1e13477" format="linespecific">class Goodbye &lt; FattyRBP::Formatter
  format :text do
    def render
      "Goodbye Cruel World!"
    end
  end
end

puts Goodbye.render(:text) #=&gt; "Goodbye Cruel World!"</programlisting><para>At first glance, things seem to be working. But if we dig deeper,
      we see two problems:</para><programlisting id="I_programlisting_d1e13481" format="linespecific"># Should not have changed
puts Hello.render(:text) #=&gt; "Goodbye Cruel World!"

# Shouldn't exist
puts Goodbye.render(:html) #=&gt; "&lt;b&gt;Hello World&lt;/b&gt;"</programlisting><para>And here, we see the problem with class variables. If we think of
      them as class-level state, we’d be wrong. They are actually
      class-hierarchy variables that can have their state modified by any
      subclass, whether direct or many levels down the ancestry chain. This
      means they’re fairly close to global state in nature, which is usually a
      bad thing. So unless you were actually counting on this behavior, an
      easy fix is to just dump class variables and use class instance
      variables instead:</para><programlisting id="I_programlisting_d1e13486" format="linespecific">module FattyRBP
  class Formatter

    def self.formats
      @formats ||= {}
    end

     def self.format(name, options={}, &amp;block)
       formats[name] = Class.new(FattyRBP::Format, &amp;block)
     end

     def self.render(format, options={})
       formats[format].new(options).render
     end
   end

   class Format
     def initialize(options)
       # not important
     end
   end
end</programlisting><para>Although this prevents direct access to the variable from
      instances, it is easy to define accessors at the class level. The
      benefit is that each subclass carries its own instance variable, just
      like ordinary objects do. With this new code, everything works as
      <phrase role="keep-together">expected</phrase>:</para><programlisting id="I_programlisting_d1e13493" format="linespecific">puts Hello.render(:text)   #=&gt; "Hello World"
puts Hello.render(:html)   #=&gt; "&lt;b&gt;Hello World&lt;/b&gt;"
puts Goodbye.render(:text) #=&gt; "Goodbye Cruel World"

puts Hello.render(:text)   #=&gt; "Hello World"
puts Goodbye.render(:html) #=&gt; raises an error</programlisting><para>So the moral of the story here is that class-level state should be
      stored in class instance variables if you want to allow subclassing.
      Reserve class variables for data that needs to be shared across an
      entire class hierarchy.<indexterm id="I_indexterm_d1e13497" class="endofrange" startref="appc_worstclassvariables" significance="normal"/><indexterm id="I_indexterm_d1e13498" class="endofrange" startref="appc_classvariables" significance="normal"/></para></sect2><sect2><title>Hardcoding Yourself Into a Corner</title><para>One good practice is to provide alternative constructors for your
      classes when there are common configurations that might be generally
      useful. One such example is in Prawn, when a user wants to build up a
      document via a simplified interface and then immediately render it to
      file:<indexterm class="startofrange" id="appc_worsthardcoding" significance="normal"><primary>Ruby worst practices</primary><secondary>unintelligent design</secondary><tertiary>hardcoding class names</tertiary></indexterm></para><programlisting id="I_programlisting_d1e13511" format="linespecific">Prawn::Document.generate("hello.pdf") do
  text "Hello Prawn!"
end</programlisting><para>Implementing this method was very simple, as it simply wraps the
      constructor and calls an extra method to render the file
      afterward:</para><programlisting id="I_programlisting_d1e13515" format="linespecific">module Prawn
  class Document

    def self.generate(filename,options={},&amp;block)
      pdf = Prawn::Document.new(options,&amp;block)
      pdf.render_file(filename)
    end

  end
end</programlisting><para>However, some months down the line, a bug report made me realize
      that I made a somewhat stupid mistake here. I accidentally prevented
      users from being able to write code like this:</para><programlisting id="I_programlisting_d1e13519" format="linespecific">class MyDocument &lt; Prawn::Document
  def say_hello
    text "Hello MyDocument"
  end
end

MyDocument.generate("hello.pdf") do
  say_hello
end</programlisting><para>The problem, of course, is that <literal moreinfo="none">Prawn::Document.generate</literal> hardcodes the
      constructor call, which prevents subclasses from ever being instantiated
      via <literal moreinfo="none">generate</literal>. The fix is so easy that
      it is somewhat embarrassing to share:</para><programlisting id="I_programlisting_d1e13529" format="linespecific">module Prawn
  class Document

    def self.generate(filename,options={},&amp;block)
      pdf = new(options,&amp;block)
      pdf.render_file(filename)
    end

  end
end</programlisting><para>By removing the explicit receiver, we now construct an object
      based on whatever <literal moreinfo="none">self</literal> is, rather
      than only building up <literal moreinfo="none">Prawn::Document</literal>
      objects. This affords us additional flexibility at virtually no cost. In
      fact, because hardcoding the name of the current class in your method
      definitions is almost always an accident, this applies across the board
      as a good habit to get into.</para><para>Although much less severe, the same thing goes for class method
      definitions as well. Throughout this book, you will see class methods
      defined using <literal moreinfo="none">def self.my_method</literal>
      rather than <literal moreinfo="none">def MyClass.my_method</literal>.
      The reason for this is much more about maintainability than it is about
      style. To illustrate this, let’s do a simple comparison. We start off
      with two boring class definitions for the classes <literal moreinfo="none">A</literal> and <literal moreinfo="none">B</literal>:</para><programlisting id="I_programlisting_d1e13554" format="linespecific">class A
  def self.foo
    # ..
  end

  def self.bar
    # ..
  end
end

class B
  def B.foo
    # ...
  end

  def B.bar
    # ...
  end
end</programlisting><para>These two are functionally equivalent, each defining the class
      methods <literal moreinfo="none">foo</literal> and <literal moreinfo="none">bar</literal> on their respective classes. But now,
      let’s refactor our code a bit, renaming <literal moreinfo="none">A</literal> to <literal moreinfo="none">C</literal> and
      <literal moreinfo="none">B</literal> to <literal moreinfo="none">D</literal>. Observe the work involved in doing
      each:</para><?dbfo-need height=”1in”
?><programlisting id="I_programlisting_d1e13578" format="linespecific">class C
  def self.foo
    # ..
  end

  def self.bar
    # ..
  end
end

class D
  def D.foo
    # ...
  end

  def D.bar
    # ...
  end
end</programlisting><para>To rename <literal moreinfo="none">A</literal> to <literal moreinfo="none">C</literal>, we simply change the name of our class, and
      we don’t need to touch the method definitions. But when we change
      <literal moreinfo="none">B</literal> to <literal moreinfo="none">D</literal>, each and every method needs to be reworked.
      Though this might be OK for an object with one or two methods at the
      class level, you can imagine how tedious this could be when that number
      gets larger.</para><para>So we’ve now found two points against hardcoding class names, and
      could probably keep growing the list if we wanted. But for now, let’s
      move on to some even higher-level design issues.<indexterm id="I_indexterm_d1e13596" class="endofrange" startref="appc_worsthardcoding" significance="normal"/></para></sect2><sect2><title>When Inheritance Becomes Restrictive</title><para>Inheritance is very nice when your classes have a clear
      hierarchical structure between them. However, it can get in the way when
      used inappropriately. Problems begin to crop up when we try to model
      cross-cutting concerns using ordinary inheritance. For examples of this,
      it’s easy to look directly into core Ruby.<indexterm class="startofrange" id="appc_inheritance" significance="normal"><primary>inheritance</primary><secondary>restrictive</secondary></indexterm><indexterm class="startofrange" id="appc_worstinheritance" significance="normal"><primary>Ruby worst practices</primary><secondary>unintelligent design</secondary><tertiary>inheritance becoming restrictive</tertiary></indexterm></para><para>Imagine if <literal moreinfo="none">Comparable</literal> were a
      class instead of a module. Then, you would be writing code like
      this:</para><programlisting id="I_programlisting_d1e13619" format="linespecific">class Person &lt; Comparable

  def initialize(first_name, last_name)
    @first_name = first_name
    @last_name  = last_name
  end

  attr_reader :first_name, :last_name

  def &lt;=&gt;(other_person)
    [last_name, first_name] &lt;=&gt; [other_person.last_name, other_person.first_name]
  end

end</programlisting><para>However, after seeing this, it becomes clear that it’d be nice to
      use a <literal moreinfo="none">Struct</literal> here. If we ignore the
      features provided by <literal moreinfo="none">Comparable</literal> here
      for a moment, the benefits of a struct to represent this simple data
      structure become obvious.</para><programlisting id="I_programlisting_d1e13629" format="linespecific">class Person &lt; Struct.new(:first_name, :last_name)
  def full_name
    "#{first_name} #{last_name}"
  end
end</programlisting><para>Because Ruby supports single inheritance only, this example
      clearly demonstrates the problems we run into when relying too heavily
      on hierarchical structure. A <literal moreinfo="none">Struct</literal>
      is certainly not always <literal moreinfo="none">Comparable</literal>.
      And it is just plain silly to think of all <literal moreinfo="none">Comparable</literal> objects being <literal moreinfo="none">Struct</literal> objects. The key distinction here is
      that a <literal moreinfo="none">Struct</literal> defines what an object
      is made up of, whereas <literal moreinfo="none">Comparable</literal>
      defines a set of features associated with certain objects. For this
      reason, the real Ruby code to accomplish this modeling makes a whole lot
      of sense:</para><programlisting id="I_programlisting_d1e13652" format="linespecific">class Person &lt; Struct.new(:first_name, :last_name)

  include Comparable

  def &lt;=&gt;(other_person)
    [last_name, first_name] &lt;=&gt; [other_person.last_name, other_person.first_name]
  end

  def full_name
     "#{first_name} #{last_name}"
  end

end</programlisting><para>Keep in mind that although we are constrained to exactly one
      superclass, we can include as many modules as we’d like. For this
      reason, modules are often used to implement features that are completely
      orthogonal to the underlying class definition that they are mixed into.
      Taking an example from the Ruby API documentation, we see <literal moreinfo="none" role="keep-together">Forwardable</literal> being used to
      very quickly implement a simple <literal moreinfo="none">Queue</literal>
      structure by doing little more than delegating to an underlying <literal moreinfo="none">Array</literal>:</para><programlisting id="I_programlisting_d1e13665" format="linespecific">require "forwardable"

class Queue
  extend Forwardable

  def initialize
    @q = [ ]
  end

  def_delegator :@q, :push, :enq
  def_delegator :@q, :shift, :deq

  def_delegators :@q, :clear, :first, :push, :shift, :size
end</programlisting><para>Although <literal moreinfo="none">Forwardable</literal> would make
      no sense anywhere in a class hierarchy, it accomplishes its task
      beautifully here. If we were constrained to a purely inheritance-based
      model, such cleverness would not be so easy to pull off.</para><para>The key thing to remember here is not that you should avoid
      inheritance at all costs, by any means. Instead, you should simply
      remember not to go out of your way to construct an artificial
      hierarchical structure to represent cross-cutting or orthogonal
      concerns. It’s important to remember that Ruby’s core is not special or
      magical in its abundant use of mixins, but instead, is representative of
      a very pragmatic and powerful object model. You can and should apply
      this technique within your own designs, whenever it makes sense to do
      so.<indexterm id="I_indexterm_d1e13675" class="endofrange" startref="appc_inheritance" significance="normal"/><indexterm id="I_indexterm_d1e13676" class="endofrange" startref="appc_worstinheritance" significance="normal"/></para></sect2></sect1><sect1 id="I_sect1_d1e13677"><title>The Downside of Cleverness</title><para>Ruby lets you do all sorts of clever, fancy tricks. This cleverness
    is a big part of what makes Ruby so elegant, but it also can be downright
    dangerous in the wrong hands. To illustrate this, we’ll look at the kind
    of trouble you can get in if you aren’t careful.<indexterm id="I_indexterm_d1e13682" significance="normal"><primary>Ruby worst practices</primary><secondary>downside of cleverness</secondary></indexterm></para><sect2><title>The Evils of eval( )</title><para>Throughout this book, we’ve dynamically evaluated code blocks all
      over the place. However, what you have not seen much of is the use of
      <literal moreinfo="none">eval()</literal>, <literal moreinfo="none">class_eval()</literal>, or even <literal moreinfo="none">instance_eval()</literal> with a string. Some might
      wonder why this is, because <literal moreinfo="none">eval()</literal>
      can be so useful! For example, imagine that you are exposing a way for
      users to filter through some data. You would like to be able to support
      an interface like this:<indexterm class="startofrange" id="appc_evalevil" significance="normal"><primary>eval( ) method, evils of</primary></indexterm><indexterm class="startofrange" id="appc_worsteval" significance="normal"><primary>Ruby worst practices</primary><secondary>downside of cleverness</secondary><tertiary>evils of eval( )</tertiary></indexterm></para><programlisting id="I_programlisting_d1e13714" format="linespecific">user1 = User.new("Gregory Brown", balance: 2500)
user2 = User.new("Arthur Brown", balance: 3300)
user3 = User.new("Steven Brown", balance: 3200)

f = Filter.new([user1, user2, user3])
f.search("balance &gt; 3000") #=&gt; [user2, user3]</programlisting><para>Armed with <literal moreinfo="none">instance_eval</literal>, this
      task is so easy that you barely bat an eye as you type out the following
      code:</para><programlisting id="I_programlisting_d1e13721" format="linespecific">class User
  def initialize(name, options)
    @name    = name
    @balance = options[:balance]
  end

  attr_reader :name, :balance
end

class Filter
  def initialize(enum)
    @collection = enum
  end

  def search(query)
    @collection.select { |e| e.instance_eval(query) }
  end
end</programlisting><para>Running the earlier example, you see that this code works great,
      exactly as expected. But unfortunately, trouble strikes when you see
      queries like this:</para><programlisting id="I_programlisting_d1e13725" format="linespecific">&gt;&gt; f.search("@balance = 0")
=&gt; [#&lt;User:0x40caa4 @name="Gregory Brown", @balance=0&gt;,
    #&lt;User:0x409138 @name="Arthur Brown", @balance=0&gt;,
    #&lt;User:0x402874 @name="Steven Brown", @balance=0&gt;]</programlisting><para>Or, perhaps even scarier:</para><programlisting id="I_programlisting_d1e13729" format="linespecific">&gt;&gt; f.search("system('touch hacked')")
=&gt; [#&lt;User:0x40caa4 @name="Gregory Brown", ...]
&gt;&gt; File.exist?('hacked')
=&gt; true</programlisting><para>Because the ability for user-generated strings to execute
      arbitrary system commands or damage the internals of an object aren’t
      exactly appealing, you code up a regex filter to protect against
      this:</para><programlisting id="I_programlisting_d1e13733" format="linespecific">def search(query)
  raise "Invalid query" unless query =~ /^(\w+) ([&gt;&lt;!]=?|==) (\d+)$/
  @collection.select { |e| e.instance_eval(query) }
end</programlisting><para>This protects against the two issues we saw before, which is
      great:</para><programlisting id="I_programlisting_d1e13738" format="linespecific">&gt;&gt; f.search("system('touch hacked')")
RuntimeError: Invalid query
        from (irb):33:in `search'
        from (irb):38
        from /Users/sandal/lib/ruby19_1/bin/irb:12:in `&lt;main&gt;'

&gt;&gt; f.search("@balance = 0")
RuntimeError: Invalid query
        from (irb):33:in `search'
        from (irb):39
        from /Users/sandal/lib/ruby19_1/bin/irb:12:in `&lt;main&gt;'</programlisting><para>But if you weren’t paying very close attention, you would have
      missed that we got our anchors wrong. That means there’s still a hole to
      be exploited here:</para><programlisting id="I_programlisting_d1e13742" format="linespecific">&gt;&gt; f.search("balance == 0\nsystem('touch hacked_again')")
=&gt; [#&lt;User:0x40caa4 @name="Gregory Brown", @balance=0  ...]
&gt;&gt; File.exist?('hacked_again')
=&gt; true</programlisting><para>Because our regex checked the first line and not the whole string,
      we were able to sneak by the validation. Arguably, if you’re very
      careful, you could come up with the right pattern and be reasonably
      safe. But as you are already validating the syntax, why play with fire?
      We can rewrite this code to accomplish the same goals with none of the
      associated risks:</para><programlisting id="I_programlisting_d1e13746" format="linespecific">def search(query)
  data = query.match(/^(?&lt;attr&gt;\w+) (?&lt;op&gt;[&gt;&lt;!]=?|==) (?&lt;val&gt;\d+)$/)
  @collection.select do |e|
    attr = e.public_send(data[:attr])
    attr.public_send(data[:op], Integer(data[:val]))
  end
end</programlisting><para>Here, we don’t expose any of the object’s internals, preserving
      encapsulation. Because we parse out the individual components of the
      statement and use <literal moreinfo="none">public_send</literal> to pass
      the messages on to our objects, we have completely eliminated the
      possibility of arbitrary code execution. All in all, this code is much
      more secure and easier to debug. As it turns out, this code will
      actually perform considerably better as well.</para><para>Every time you use <literal moreinfo="none">eval(string)</literal>, Ruby needs to fire up its parser
      and tree walker to execute the code you’ve embedded in your string. This
      means that in cases in which you just need to process a few values and
      then do something with them, using a targeted regular expression is
      often a much better option, as it greatly reduces the amount of work the
      interpreter needs to do.</para><para>For virtually every situation in which you might turn to a raw
      string <literal moreinfo="none">eval()</literal>, you can work around it
      using the tools Ruby provides. These include all sorts of methods for
      getting at whatever you need, including <literal moreinfo="none">instance_variable_get</literal>, <literal moreinfo="none">instance_variable_set</literal>, <literal moreinfo="none">const_get</literal>, <literal moreinfo="none">const_set</literal>, <literal moreinfo="none">public_send</literal>, <literal moreinfo="none">send</literal>, <literal moreinfo="none">define_method</literal>, <literal moreinfo="none">method()</literal>, and even <literal moreinfo="none">Class.new</literal>/<literal moreinfo="none">Module.new</literal>. These tools allow you to
      dynamically manipulate Ruby code without evaluating strings directly.
      For more details, you’ll definitely want to read <xref linkend="ch03" xrefstyle="chap-num-title"/>.<indexterm id="I_indexterm_d1e13797" class="endofrange" startref="appc_evalevil" significance="normal"/><indexterm id="I_indexterm_d1e13798" arch="" class="endofrange" startref="appc_worsteval" significance="normal"/></para></sect2><sect2><title>Blind Rescue Missions</title><para>Ruby provides a lot of different ways to handle exceptions. They
      run the gamut all the way from capturing the full stack trace to
      completely ignoring raised errors. This flexibility means that
      exceptions aren’t necessarily treated with the same gravity in Ruby as
      in other languages, as they are very simple to rescue once they are
      raised. In certain cases, folks have even used <literal moreinfo="none">rescue</literal> as a stand-in replacement for
      conditional statements. The classic example follows:<indexterm class="startofrange" id="appa_exceptions" significance="normal"><primary>exceptions</primary><secondary>rescuing</secondary></indexterm><indexterm class="startofrange" id="appa_worstrescue" significance="normal"><primary>Ruby worst practices</primary><secondary>downside of cleverness</secondary><tertiary>rescuing exceptions</tertiary></indexterm></para><programlisting id="I_programlisting_d1e13819" format="linespecific">name = @user.first_name.capitalize rescue "Anonymous"</programlisting><para>Usually, this is done with the intention of capturing the <literal moreinfo="none">NoMethodError</literal> raised by something like
      <literal moreinfo="none">first_name</literal> being
      <literal moreinfo="none">nil</literal> here. It accomplishes this task well, and looks
      slightly nicer than the alternative:</para><programlisting id="I_programlisting_d1e13832" format="linespecific">name = @user.first_name ? @user.first_name.capitalize : "Anonymous"</programlisting><para>However, the downside of using this trick is that you will most
      likely end up seeing this code again, at the long end of a painful
      debugging session. For demonstration purposes, let’s assume our <literal moreinfo="none">User</literal> is implemented like this:</para><programlisting id="I_programlisting_d1e13839" format="linespecific">require "pstore"

class User

  def self.data
    @data ||= PStore.new("users.store")
  end

  def self.add(id, user_data)
    data.transaction do
      data[id] = user_data
    end
  end

  def self.find(id)
    data.transaction do
      data[id] or raise "User not found"
    end
  end

  def initialize(id)
    @user_id = id
  end

  def attributes
    self.class.find(@user_id)
  end

  def first_name
    attributes[:first_name]
  end

end</programlisting><para>What we have here is basically a <literal moreinfo="none">PStore</literal>-backed user database. It’s not terribly
      important to understand every last detail, but the code should be fairly
      easy to understand if you play around with it a bit.</para><para>Firing up <emphasis>irb</emphasis>, we can see that the <literal moreinfo="none">rescue</literal> trick works fine for cases in which
      <literal moreinfo="none">User#first_name</literal> returns <literal moreinfo="none">nil</literal>:</para><programlisting id="I_programlisting_d1e13860" format="linespecific">&gt;&gt; require "user"
=&gt; true

&gt;&gt; User.add('sandal', email: 'gregory@majesticseacreature.com')

=&gt; {:email=&gt;"gregory@majesticseacreature.com"}
&gt;&gt; @user = User.new('sandal')
=&gt; #&lt;User:0x48c448 @user_id="sandal"&gt;
&gt;&gt; name = @user.first_name.capitalize rescue "Anonymous"
=&gt; "Anonymous"
=&gt; #&lt;User:0x49ab74 @user_id="sandal"&gt;
&gt;&gt; @user.first_name
=&gt; nil
&gt;&gt; @user.attributes
=&gt; {:email=&gt;"gregory@majesticseacreature.com"}</programlisting><para>Ordinary execution also works fine:</para><programlisting id="I_programlisting_d1e13865" format="linespecific">&gt;&gt; User.add('jia', first_name: "Jia", email: "jia@majesticseacreature.com")

=&gt; {:first_name=&gt;"Jia", :email=&gt;"jia@majesticseacreature.com"}
&gt;&gt; @user = User.new('jia')
=&gt; #&lt;User:0x492154 @user_id="jia"&gt;
&gt;&gt; name = @user.first_name.capitalize rescue "Anonymous"
=&gt; "Jia"
&gt;&gt; @user.attributes
=&gt; {:first_name=&gt;"Jia", :email=&gt;"jia@majesticseacreature.com"}
&gt;&gt; @user.first_name
=&gt; "Jia"
&gt;&gt; @user = User.new('sandal')</programlisting><para>It seems like everything is in order; however, you don’t need to
      look far. Notice that this line will succeed even if <literal moreinfo="none">@user</literal> is undefined:</para><programlisting id="I_programlisting_d1e13872" format="linespecific">&gt;&gt; @user = nil
=&gt; nil
&gt;&gt; name = @user.first_name.capitalize rescue "Anonymous"
=&gt; "Anonymous"</programlisting><para>This means you can’t count on catching an error when a typo or a
      renamed variable creeps into your code. This weakness of course
      propagates down the chain as well:</para><programlisting id="I_programlisting_d1e13876" format="linespecific">&gt;&gt; name = @user.a_fake_method.capitalize rescue "Anonymous"
=&gt; "Anonymous"
&gt;&gt; name = @user.a_fake_method.cannot_fail rescue "Anonymous"
=&gt; "Anonymous"</programlisting><para>Of course, issues with a one-liner like this should be easy enough
      to catch even without an exception. This is most likely the reason why
      this pattern has become so common. However, this is usually an
      oversight, because the problem exists deeper down the bunny hole as
      well. Let’s introduce a typo into our user implementation:</para><programlisting id="I_programlisting_d1e13880" format="linespecific">class User

  def first_name
    attribute[:first_name]
  end

end</programlisting><para>Now, we go back and look at one of our previously working
      examples:</para><programlisting id="I_programlisting_d1e13884" format="linespecific">&gt;&gt; @user = User.new('jia')
=&gt; #&lt;User:0x4b8548 @user_id="jia"&gt;
&gt;&gt; name = @user.first_name.capitalize rescue "Anonymous"
=&gt; "Anonymous"
&gt;&gt; @user.first_name
NameError: undefined local variable or method `attribute' for #&lt;User:0x4b8548 ...&gt;
        from (irb):23:in `first_name'
        from (irb):32
        from /Users/sandal/lib/ruby19_1/bin/irb:12:in `&lt;main&gt;'</programlisting><para>Hopefully, you’re beginning to see the picture. Although good
      testing and extensive quality assurance can catch these bugs, using this
      conditional modifier <literal moreinfo="none">rescue</literal> hack is
      like putting blinders on your code. Unfortunately, this can also go for
      code of the form:</para><programlisting id="I_programlisting_d1e13891" format="linespecific">def do_something_dangerous
  might_raise_an_error
rescue
  "default value"
end</programlisting><para>Pretty much any <literal moreinfo="none">rescue</literal> that does not capture a
      specific error may be a source of silent failure in your applications.
      The only real case in which an unqualified <literal moreinfo="none">rescue</literal> might make sense is when it is combined
      with a unqualified <literal moreinfo="none">raise</literal>, which
      causes the same error to resurface after executing some code:</para><programlisting id="I_programlisting_d1e13905" format="linespecific">begin
  # do some stuff
rescue =&gt; e
  MyLogger.error "Error doing stuff: #{e.message}"
  raise
end</programlisting><para>In other situations, be sure to either know the risks involved, or
      avoid this technique entirely. You’ll thank yourself later.<indexterm id="I_indexterm_d1e13909" class="endofrange" startref="appa_exceptions" significance="normal"/><indexterm id="I_indexterm_d1e13910" class="endofrange" startref="appa_worstrescue" significance="normal"/></para></sect2><sect2><title>Doing method_missing Wrong</title><para>One thing you really don’t want to do is mess up a <literal moreinfo="none">method_missing</literal> hook. Because the purpose of
      <literal moreinfo="none">method_missing</literal> is to handle unknown
      messages, it is a key feature for helping to find bugs in your
      code.<indexterm class="startofrange" id="appc_methodmissisng" significance="normal"><primary>method_missing( ) method</primary><secondary>done wrong</secondary></indexterm><indexterm class="startofrange" id="appc_worstmethodmissing" significance="normal"><primary>Ruby worst practices</primary><secondary>downside of cleverness</secondary><tertiary>method_missing</tertiary></indexterm></para><para>In <xref linkend="ch03" xrefstyle="chap-num-title"/>, we covered
      some examples of how to use <literal moreinfo="none">method_missing</literal> properly. Here’s an example of
      how to do it wrong:</para><programlisting id="I_programlisting_d1e13941" format="linespecific">class Prawn::Document

  # Provides the following shortcuts:
  #
  #    stroke_some_method(*args) #=&gt; some_method(*args); stroke
  #    fill_some_method(*args) #=&gt; some_method(*args); fill
  #    fill_and_stroke_some_method(*args) #=&gt; some_method(*args); fill_and_stroke
  #
  def method_missing(id,*args,&amp;block)
    case(id.to_s)
    when /^fill_and_stroke_(.*)/
      send($1,*args,&amp;block); fill_and_stroke
    when /^stroke_(.*)/
      send($1,*args,&amp;block); stroke
    when /^fill_(.*)/
      send($1,*args,&amp;block); fill
    end
  end

end</programlisting><para>Although this may look very similar to an earlier example in this
      book, it has a critical flaw. Can you see it? If not, this
      <emphasis>irb</emphasis> session should help:</para><programlisting id="I_programlisting_d1e13948" format="linespecific">&gt;&gt; pdf.fill_and_stroke_cirlce([100,100], :radius =&gt; 25)
=&gt; "0.000 0.000 0.000 rg\n0.000 0.000 0.000 RG\nq\nb\n"
&gt;&gt; pdf.stroke_the_pretty_kitty([100,100], :radius =&gt; 25)
=&gt; "0.000 0.000 0.000 rg\n0.000 0.000 0.000 RG\nq\nb\nS\n"
&gt;&gt; pdf.donuts
=&gt; nil</programlisting><para>By coding a <literal moreinfo="none">method_missing</literal> hook
      without delegating to the original <literal moreinfo="none">Object</literal> definition, we have effectively muted
      our object’s ability to complain about messages we really didn’t want it
      to handle. To add insult to injury, failure cases such as <literal moreinfo="none">fill_and_stroke_cirlce</literal> and <literal moreinfo="none">stroke_the_pretty_kitty</literal> are doubly confusing,
      as they return a non-<literal moreinfo="none">nil</literal> value, even though they do
      not produce meaningful results.</para><para>Luckily, the remedy to this is simple. We just add a call to
      <literal moreinfo="none">super</literal> in the catchall case:</para><programlisting id="I_programlisting_d1e13972" format="linespecific">def method_missing(id,*args,&amp;block)
  case(id.to_s)
  when /^fill_and_stroke_(.*)/
    send($1,*args,&amp;block); fill_and_stroke
  when /^stroke_(.*)/
    send($1,*args,&amp;block); stroke
  when /^fill_(.*)/
    send($1,*args,&amp;block); fill
  else
    super
  end
end</programlisting><para>Now, if we rerun our earlier examples, you will see much more
      predictable behavior, in line with what we’d expect if we had no hook
      set up in the first place:</para><programlisting id="I_programlisting_d1e13976" format="linespecific">&gt;&gt; pdf.fill_and_stroke_cirlce([100,100], :radius =&gt; 25)
NoMethodError: undefined method `cirlce' for #&lt;Prawn::Document:0x4e59f8&gt;
        from prawn/lib/prawn/graphics/color.rb:68:in `method_missing'
        from prawn/lib/prawn/graphics/color.rb:62:in `method_missing'
        from (irb):4
        from /Users/sandal/lib/ruby19_1/bin/irb:12:in `&lt;main&gt;'

&gt;&gt; pdf.stroke_the_pretty_kitty([100,100], :radius =&gt; 25)
NoMethodError: undefined method `the_pretty_kitty' for #&lt;Prawn::Document:0x4e59f8&gt;
        from prawn/lib/prawn/graphics/color.rb:68:in `method_missing'
        from prawn/lib/prawn/graphics/color.rb:64:in `method_missing'
        from (irb):5
        from /Users/sandal/lib/ruby19_1/bin/irb:12:in `&lt;main&gt;'

&gt;&gt; pdf.donuts
NoMethodError: undefined method `donuts' for #&lt;Prawn::Document:0x4e59f8&gt;
        from prawn/lib/prawn/graphics/color.rb:68:in `method_missing'
        from (irb):6
        from /Users/sandal/lib/ruby19_1/bin/irb:12:in `&lt;main&gt;'</programlisting><para>An important thing to remember is that in addition to ensuring
      that you call <literal moreinfo="none">super</literal> from within your
      <literal moreinfo="none">method_missing()</literal> calls, you are also
      responsible for maintaining the method’s signature. It’s possible to
      write a hook that captures only a missing method’s name while ignoring
      its arguments and associated block:</para><programlisting id="I_programlisting_d1e13987" format="linespecific">def method_missing(id)
  # ...
end</programlisting><para>However, if you set things up this way, even when you call
      <literal moreinfo="none">super</literal>, you’ll be breaking things
      farther up the chain, as <literal moreinfo="none">Object#method_missing</literal> expects the whole
      signature of the function call to remain intact. So it’s not only
      delegating to the original that is important, but delegating without
      information loss.</para><para>If you’re sure to act responsibly with your <literal moreinfo="none">method_missing</literal> calls, it won’t be that
      dangerous in most cases. However, if you get sloppy here, it is
      virtually guaranteed to come back to haunt you. If you get into this
      habit right away, it’ll be sure to save you some headaches down the
      line.<indexterm id="I_indexterm_d1e14002" class="endofrange" startref="appc_methodmissisng" significance="normal"/><indexterm id="I_indexterm_d1e14003" class="endofrange" startref="appc_worstmethodmissing" significance="normal"/></para></sect2></sect1><sect1 id="I_sect1_d1e14004"><title>Conclusions</title><para>This appendix doesn’t come close to covering all the trouble that
    you can get yourself into with Ruby. It does, however, cover some of the
    most common sources of trouble and confusion and shows some much less
    painful alternatives.</para><para>When it comes to design, much can be gained by simply reducing
    complexity. If the path you’re on seems too difficult, odds are that it
    can be made a lot easier if you just think about it in a different way. As
    for “clever” implementation tricks and shortcuts, they can be more trouble
    than they’re worth if they come at the expense of clarity or
    maintainability of your code.</para><para>Put simply, the worst practices in Ruby are ones that make you work
    much harder than you have to. If you start to introduce code that seems
    really cool at first, but later is shown to introduce complicated faults
    at the corner cases, it is generally wise to just rip it out and start
    fresh with something a little less exciting that’s more reliable.</para><para>If you maintain the balancing act between creative approaches to
    your problems and ones that work without introducing excess complexity,
    you’ll have a very happy time writing Ruby code. Because Ruby gives you
    the power to do both good and evil, it’s ultimately up to you how you want
    to maintain your projects. However, code that is maintainable and
    predictable is much more of a joy to work with than fragile and sloppy
    hacks that have been simply duct-taped together.</para><para>Now that we have reached the very end of this book, I trust that you
    have the skills necessary to go out and find Ruby Best (and Worst)
    Practices on your own. The real challenge is knowing the difference
    between the two, and that ability comes only with practical experience
    gained by working on and investigating real problems. This book has
    included enough real-world examples to give you a head start in that area,
    but the heavy lifting needs to be done by you.</para><para>I hope you have enjoyed this wild ride through Ruby with me, and I
    really hope that something or the other in this book has challenged or
    inspired you. Please go out now and write some good open source Ruby code,
    and maybe you’ll make a guest appearance in the second edition!<indexterm id="I_indexterm_d1e14019" class="endofrange" startref="appc_worst" significance="normal"/></para></sect1></appendix><index/><colophon id="colophon"><title>Colophon</title><para>The animal on the cover of <citetitle>Ruby Best Practices</citetitle>
  is a green crab (<emphasis>Carcinus maenas</emphasis>). Also known as a
  European shore crab, it is native to the coasts of the North and Baltic
  Seas. Although relatively small—adults measure three inches across—an adult
  green crab can consume up to 40 clams each day and can eat other crabs as
  large as itself. A voracious predator, the green crab also preys on oysters,
  mussels, and snails, <phrase role="keep-together">competing</phrase> for
  food with many fish and bird species.</para><para>Despite its name, the green crab’s shell color can vary from dark
  green to orange or red, sometimes with yellow patches on its underside. The
  abdomen of the male is triangular in shape, whereas the female’s is broader
  and rounder. Males and females also react differently upon being picked up:
  males typically stretch out their legs, whereas females fold them in, a
  behavior known as the egg-protection reflex.</para><para>A natural colonizer, the green crab is potentially destructive to any
  ecosystem it invades. It has already invaded many coastal communities
  outside of its native range, including Australia, South Africa, and North
  America, where it is blamed for the collapse of the softshell clam industry
  in Maine. It is ranked number 18 on the list of the 100 world’s worst
  invasive types of species. Numerous efforts around the world have been made
  to control invading populations, to varying degrees of success. One of the
  more effective experiments has been on Martha’s Vineyard, Massachusetts,
  where the town of <phrase role="keep-together">Edgartown</phrase> pays
  bounty hunters 40 cents per pound of green crab; more than 10 tons have been
  caught and destroyed as a result.</para><para>The cover image is from the Dover Pictorial Archive. The cover font is
  Adobe ITC Garamond. The text font is Linotype Birka; the heading font is
  Adobe Myriad Condensed; and the code font is LucasFont’s <phrase role="keep-together">TheSansMonoCondensed</phrase>.</para></colophon></book>
